/* Generated from Java with JSweet 2.2.0-SNAPSHOT - http://www.jsweet.org */
var actions;
(function (actions) {
    /**
     * Create an action containing the time to hold and the key combination.
     *
     * @param {number} totalTimestepsToHold Number of timesteps to hold the keys associated with this Action.
     * @param {boolean} Q                    Whether the Q key is pressed during this action.
     * @param {boolean} W                    Whether the W key is pressed during this action.
     * @param {boolean} O                    Whether the O key is pressed during this action.
     * @param {boolean} P                    Whether the P key is pressed during this action.
     * @class
     * @author Matt
     */
    class Action {
        constructor(totalTimestepsToHold, Q, W, O, P) {
            /**
             * Is this the immutable original or a derived, mutable copy. A little bit hacky, but a way of avoiding threading
             * issues without major modifications.
             */
            /*private*/ this.isExecutableCopy = false;
            if (((typeof totalTimestepsToHold === 'number') || totalTimestepsToHold === null) && ((typeof Q === 'boolean') || Q === null) && ((typeof W === 'boolean') || W === null) && ((typeof O === 'boolean') || O === null) && ((typeof P === 'boolean') || P === null)) {
                let __args = arguments;
                {
                    let __args = arguments;
                    let keysPressed = [Q, W, O, P];
                    if (this.timestepsTotal === undefined)
                        this.timestepsTotal = 0;
                    if (this.timestepsRemaining === undefined)
                        this.timestepsRemaining = 0;
                    if (this.keysPressed === undefined)
                        this.keysPressed = null;
                    this.isExecutableCopy = false;
                    if (this.timestepsTotal === undefined)
                        this.timestepsTotal = 0;
                    if (this.timestepsRemaining === undefined)
                        this.timestepsRemaining = 0;
                    if (this.keysPressed === undefined)
                        this.keysPressed = null;
                    (() => {
                        if (keysPressed.length !== 4)
                            throw Object.defineProperty(new Error("A QWOP action should have booleans for exactly 4 keys. Tried to create one with a boolean array of size: " + keysPressed.length), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                        if (totalTimestepsToHold < 0)
                            throw Object.defineProperty(new Error("New QWOP Action must have non-negative duration. Given: " + totalTimestepsToHold), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                        this.timestepsTotal = totalTimestepsToHold;
                        this.keysPressed = keysPressed;
                        this.timestepsRemaining = this.timestepsTotal;
                    })();
                }
            }
            else if (((typeof totalTimestepsToHold === 'number') || totalTimestepsToHold === null) && ((Q != null && Q instanceof Array && (Q.length == 0 || Q[0] == null || (typeof Q[0] === 'boolean'))) || Q === null) && W === undefined && O === undefined && P === undefined) {
                let __args = arguments;
                let keysPressed = __args[1];
                if (this.timestepsTotal === undefined)
                    this.timestepsTotal = 0;
                if (this.timestepsRemaining === undefined)
                    this.timestepsRemaining = 0;
                if (this.keysPressed === undefined)
                    this.keysPressed = null;
                this.isExecutableCopy = false;
                if (this.timestepsTotal === undefined)
                    this.timestepsTotal = 0;
                if (this.timestepsRemaining === undefined)
                    this.timestepsRemaining = 0;
                if (this.keysPressed === undefined)
                    this.keysPressed = null;
                (() => {
                    if (keysPressed.length !== 4)
                        throw Object.defineProperty(new Error("A QWOP action should have booleans for exactly 4 keys. Tried to create one with a boolean array of size: " + keysPressed.length), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                    if (totalTimestepsToHold < 0)
                        throw Object.defineProperty(new Error("New QWOP Action must have non-negative duration. Given: " + totalTimestepsToHold), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                    this.timestepsTotal = totalTimestepsToHold;
                    this.keysPressed = keysPressed;
                    this.timestepsRemaining = this.timestepsTotal;
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Return the keys for this action and decrement the timestepsRemaining.
         *
         * @return {Array} A 4-element array containing true/false for whether each of the Q, W, O, and P keys are pressed.
         */
        poll() {
            if (!this.isExecutableCopy)
                throw Object.defineProperty(new Error("Trying to execute the base version of the Action. Due to multi-threading, this REALLY screws with the counters in the action. Call getCopy for the version you should use."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            if (this.timestepsRemaining <= 0)
                throw Object.defineProperty(new Error("Tried to poll an action which was already completed. Call hasNext() to check before calling poll()."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            this.timestepsRemaining--;
            return this.keysPressed;
        }
        /**
         * Return the keys pressed in this action without changing the number of timesteps remaining in this action.
         *
         * @return {Array} A 4-element array containing true/false for whether each of the Q, W, O, and P keys are pressed in
         * this action.
         */
        peek() {
            return this.keysPressed;
        }
        /**
         * Check whether this action is finished (i.e. internal step counter hit zero).
         *
         * @return {boolean} Whether this action is finished.
         */
        hasNext() {
            return this.timestepsRemaining > 0;
        }
        /**
         * Reset the number of timesteps in this action remaining. Do this before repeating an action.
         */
        reset() {
            if (!this.isExecutableCopy)
                throw Object.defineProperty(new Error("Tried to reset the base copy of an action.This is not inherently wrong, but it will do nothing. Could indicate logic flaws in the caller."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            this.timestepsRemaining = this.timestepsTotal;
        }
        /**
         * Get the number of timesteps left to hold this key combination.
         *
         * @return {number} The number of timesteps remaining in this action.
         */
        getTimestepsRemaining() {
            return this.timestepsRemaining;
        }
        /**
         * Get the total duration of this action in timesteps.
         *
         * @return {number} Total duration of this action (timesteps).
         */
        getTimestepsTotal() {
            return this.timestepsTotal;
        }
        /**
         * Check if this action is equal to another in regards to keypresses and durations. Completely overrides default
         * equals, so when doing ArrayList checks, this will be the only way to judge. Note that the actions do not need
         * to have the same number of timesteps remaining to be judged as equal as long as their timestep totals and keys
         * are the same.
         *
         * @param {*} other An action to check whether it is equivalent to this action.
         * @return {boolean} Whether the other action is equivalent to this one.
         */
        equals(other) {
            if (!(other != null && other instanceof actions.Action)) {
                return false;
            }
            let otherAction = other;
            let equal = true;
            for (let i = 0; i < this.keysPressed.length; i++) {
                {
                    if (this.keysPressed[i] !== otherAction.peek()[i]) {
                        equal = false;
                        break;
                    }
                }
                ;
            }
            if (equal && this.timestepsTotal !== otherAction.getTimestepsTotal())
                equal = false;
            return equal;
        }
        /**
         * Return a string with the current action keys, total time to hold, and time remaining. This method does not
         * print, it just returns the string for the caller to use.
         *
         * @return {string} String of information about this action.
         */
        toString() {
            let reportString = " Keys pressed: ";
            reportString += this.keysPressed[0] ? "Q" : "";
            reportString += this.keysPressed[1] ? "W" : "";
            reportString += this.keysPressed[2] ? "O" : "";
            reportString += this.keysPressed[3] ? "P" : "";
            reportString += "; Timesteps elapsed/total: " + this.timestepsRemaining + "/" + this.timestepsTotal;
            return reportString;
        }
        /**
         * Get a copy of this action. This avoid multi-threading issues.
         *
         * @return {actions.Action} A poll-able copy of this Action with all timesteps of the duration remaining.
         */
        getCopy() {
            let copiedAction = new Action(this.timestepsTotal, this.keysPressed);
            copiedAction.isExecutableCopy = true;
            return copiedAction;
        }
        /**
         * Is this a mutable copy of the original action? Important if we plan to use this as a pollable queue. If the
         * action is not mutable, then you must get a copy with {@link Action#getCopy()}.
         *
         * @return {boolean} Returns whether this action can be polled. If false, then it is the original version of the action.
         */
        isMutable() {
            return this.isExecutableCopy;
        }
        /**
         * Take a list of actions and combine adjacent actions which have the same keypresses.
         * These mostly arise when doing control on a timestep-by-timestep basis. Only timestepsTotal are
         * used. Timesteps remaining are not preserved. 0-duration actions are squashed away.
         * An empty array input or one containing nothing but 0 length actions will produce an exception.
         *
         * @param {actions.Action[]} inActions A list of actions which we wish to consolidate.
         * @return {actions.Action[]} A new list of actions which is the consolidated version of the input action list.
         * @throws IllegalArgumentException When trying to consolidate a list of actions containing nothing but 0-length
         * actions.
         */
        static consolidateActions(inActions) {
            let outActions = ([]);
            if (inActions.length === 1) {
                if (inActions[0].getTimestepsTotal() === 0) {
                    throw Object.defineProperty(new Error("Input action list had only one element, and this one element had 0 duration."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                }
                /* add */ (outActions.push(/* get */ inActions[0]) > 0);
                return outActions;
            }
            let consolidations = 0;
            for (let i = 0; i < inActions.length - 1;) {
                {
                    let a1 = inActions[i];
                    let a2 = inActions[i + 1];
                    if (a1.getTimestepsTotal() === 0) {
                        i++;
                        if (inActions.length - 1 === i && a2.getTimestepsTotal() !== 0)
                            (outActions.push(a2) > 0);
                    }
                    else if (((a1, a2) => { if (a1 == null && a2 == null)
                        return true; if (a1 == null || a2 == null)
                        return false; if (a1.length != a2.length)
                        return false; for (let i = 0; i < a1.length; i++) {
                        if (a1[i] != a2[i])
                            return false;
                    } return true; })(a1.peek(), a2.peek())) {
                        /* add */ (outActions.push(new Action(a1.getTimestepsTotal() + a2.getTimestepsTotal(), a1.peek())) > 0);
                        consolidations++;
                        i += 2;
                    }
                    else {
                        /* add */ (outActions.push(a1) > 0);
                        i++;
                        if (inActions.length - 1 === i && a2.getTimestepsTotal() !== 0)
                            (outActions.push(a2) > 0);
                    }
                }
                ;
            }
            if (consolidations === 0) {
                if ((outActions.length == 0)) {
                    throw Object.defineProperty(new Error("Tried to consolidate a multi-element list of Actions. All had 0-duration, so consolidation does not make sense."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                }
                return outActions;
            }
            else {
                return Action.consolidateActions(outActions);
            }
        }
    }
    Action.serialVersionUID = 2;
    actions.Action = Action;
    Action["__class"] = "actions.Action";
    Action["__interfaces"] = ["java.io.Serializable"];
})(actions || (actions = {}));
(function (actions_1) {
    /**
     * All things related to storing and going through sequences of actions. {@link ActionQueue} itself acts like a
     * {@link Queue} of {@link Action}, while actions act like queues of keypresses (commands). When
     * calling {@link ActionQueue#pollCommand()}, this will return the next set of keypresses from the current action,
     * while automatically advancing through actions when one's duration is complete.
     *
     * @author Matt
     *
     * @see Queue
     * @see Action
     * @see ActionSet
     * @class
     */
    class ActionQueue {
        constructor() {
            /**
             * Actions are the delays between keypresses.
             */
            /*private*/ this.actionQueue = ([]);
            /**
             * All actions done or queued since the last reset. Unlike the queue, things aren't removed until reset.
             */
            /*private*/ this.actionListFull = ([]);
            /**
             * Is there anything at all queued up to execute? Includes both the currentAction and the actionQueue.
             */
            /*private*/ this.__isEmpty = true;
            /**
             * Number of commands polled from the ActionQueue during its life.
             */
            /*private*/ this.commandsPolled = 0;
            if (this.currentAction === undefined)
                this.currentAction = null;
        }
        /**
         * See the action we are currently executing. Does not change the queue.
         *
         * @return {actions.Action} Action which is currently being executed (i.e. timings and keypresses).
         */
        peekThisAction() {
            return this.currentAction;
        }
        /**
         * See the next action we will execute. Does not change the queue.
         *
         * @return {actions.Action} Next full action that will run (i.e. timings and keys). Returns null if no future actions remain.
         */
        peekNextAction() {
            if (this.isEmpty())
                throw Object.defineProperty(new Error("No actions have been added to this queue. Cannot peek."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            return ((s) => { return s[s.length - 1]; })(this.actionQueue);
        }
        /**
         * See the next keypresses.
         *
         * @return {Array} Next QWOP keypresses as a boolean array. True is pressed, false is not pressed.
         */
        peekCommand() {
            if (this.currentAction == null)
                throw Object.defineProperty(new Error("No current action in the queue for us to peek at."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            if (this.currentAction.getTimestepsRemaining() === 0) {
                if ((this.actionQueue.length == 0)) {
                    return null;
                }
                else {
                    return ((s) => { return s[s.length - 1]; })(this.actionQueue).peek();
                }
            }
            else {
                return this.currentAction.peek();
            }
        }
        /**
         * Adds a new action to the end of the queue. If this is the first action to be added, it is loaded up as the
         * current action. All added actions are copied internally.
         *
         * @param {actions.Action} action Action to add to the end of the queue as a copy. Does not influence current polling of the queue
         * elements.
         */
        addAction(action) {
            if (action.getTimestepsTotal() === 0)
                return;
            let localCopy = action.getCopy();
            /* add */ (this.actionQueue.push(localCopy) > 0);
            /* add */ (this.actionListFull.push(localCopy) > 0);
            if (this.currentAction == null) {
                this.currentAction = (a => a.length == 0 ? null : a.shift())(this.actionQueue);
            }
            this.__isEmpty = false;
        }
        addSequence$actions_Action_A(actions) {
            if (actions.length === 0)
                throw Object.defineProperty(new Error("Tried to add an empty array of actions to a queue."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
            for (let index121 = 0; index121 < actions.length; index121++) {
                let action = actions[index121];
                {
                    this.addAction(action);
                }
            }
        }
        /**
         * Add a sequence of actions. All added actions are copied.
         *
         * @param {Array} actions Array of actions to add to the end of the queue. They are copied, and adding does not influence
         * polling of the existing queue.
         */
        addSequence(actions) {
            if (((actions != null && actions instanceof Array && (actions.length == 0 || actions[0] == null || (actions[0] != null && actions[0] instanceof actions.Action))) || actions === null)) {
                return this.addSequence$actions_Action_A(actions);
            }
            else if (((actions != null && (actions instanceof Array)) || actions === null)) {
                return this.addSequence$java_util_List(actions);
            }
            else
                throw new Error('invalid overload');
        }
        addSequence$java_util_List(actions) {
            if (actions.length === 0)
                throw Object.defineProperty(new Error("Tried to add an empty array of actions to a queue."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
            for (let index122 = 0; index122 < actions.length; index122++) {
                let action = actions[index122];
                {
                    this.addAction(action);
                }
            }
        }
        /**
         * Request the next QWOP keypress commands from the added sequence. Automatically advances between actions.
         *
         * @return {Array} Get the next command (QWOP true/false array) on the queue.
         */
        pollCommand() {
            if ((this.actionQueue.length == 0) && !this.currentAction.hasNext()) {
                throw Object.defineProperty(new Error("Tried to get a command off the queue when nothing is queued up."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            }
            if (!this.currentAction.hasNext()) {
                this.currentAction.reset();
                this.currentAction = (a => a.length == 0 ? null : a.shift())(this.actionQueue);
                /* requireNonNull */ if (this.currentAction == null) {
                    throw new Error('cannot be null');
                }
                ;
            }
            let nextCommand = this.currentAction.poll();
            if (!this.currentAction.hasNext() && (this.actionQueue.length == 0)) {
                this.__isEmpty = true;
            }
            this.commandsPolled++;
            return nextCommand;
        }
        /**
         * Remove everything from the queues and reset the sequence.
         */
        clearAll() {
            /* clear */ (this.actionQueue.length = 0);
            /* clear */ (this.actionListFull.length = 0);
            if (this.currentAction != null)
                this.currentAction.reset();
            this.currentAction = null;
            this.__isEmpty = true;
        }
        /**
         * Check if the queue has anything in it.
         *
         * @return {boolean} Whether this queue has more commands left to poll.
         */
        isEmpty() {
            return this.__isEmpty;
        }
        /**
         * Get all the actions in this queue.
         *
         * @return {Array} All actions in this queue, including ones which have already been executed.
         */
        getActionsInCurrentRun() {
            return this.actionListFull.slice(0);
        }
        /**
         * Index of the current action. 0 is the first {@link Action}.
         *
         * @return {number} Index of the current action.
         */
        getCurrentActionIdx() {
            let currIdx = this.actionListFull.length - this.actionQueue.length - 1;
            return currIdx;
        }
        /**
         * Resets all progress on the queue making it ready to execute the same actions again. Note that to actually
         * remove actions, you should use {@link ActionQueue#clearAll()}.
         */
        resetQueue() {
            let actions = this.getActionsInCurrentRun();
            this.clearAll();
            this.addSequence$actions_Action_A(actions);
        }
        /**
         * Get a copy of this ActionQueue, with none of the actions performed yet.
         *
         * @return {actions.ActionQueue} An ActionQueue with all the same actions, but no progress in them done yet.
         */
        getCopyOfUnexecutedQueue() {
            let actionQueueCopy = new ActionQueue();
            actionQueueCopy.addSequence$actions_Action_A(this.getActionsInCurrentRun());
            return actionQueueCopy;
        }
        /**
         * Get a copy of this ActionQueue, with the same actions, and the same progress made on those actions.
         *
         * @return {actions.ActionQueue} An ActionQueue which should behave identically to the original.
         */
        getCopyOfQueueAtExecutionPoint() {
            let actionQueueCopy = this.getCopyOfUnexecutedQueue();
            for (let i = 0; i < this.commandsPolled; i++) {
                {
                    actionQueueCopy.pollCommand();
                }
                ;
            }
            return actionQueueCopy;
        }
        /**
         * Gives the total duration of this action queue in timesteps. This does not depend on the number of timesteps
         * already executed on this queue.
         *
         * @return {number} Total duration of this queue in timesteps.
         */
        getTotalQueueLengthTimesteps() {
            let totalTS = 0;
            for (let index123 = 0; index123 < this.actionListFull.length; index123++) {
                let a = this.actionListFull[index123];
                {
                    totalTS += a.getTimestepsTotal();
                }
            }
            return totalTS;
        }
    }
    actions_1.ActionQueue = ActionQueue;
    ActionQueue["__class"] = "actions.ActionQueue";
})(actions || (actions = {}));
var game;
(function (game) {
    class GameConstants {
    }
    /**
     * Physics engine stepping parameters.
     */
    GameConstants.timestep = 0.04;
    /**
     * Number of Box2D solver iterations.
     */
    GameConstants.physIterations = 5;
    /**
     * AABB bounds.
     */
    GameConstants.aabbMinX = -100.0;
    /**
     * AABB bounds.
     */
    GameConstants.aabbMinY = -30.0;
    /**
     * AABB bounds.
     */
    GameConstants.aabbMaxX = 5000.0;
    /**
     * AABB bounds.
     */
    GameConstants.aabbMaxY = 80.0;
    /**
     * Gravity in downward direction.
     */
    GameConstants.gravityMagnitude = 10.0;
    /**
     * Track parameters.
     */
    GameConstants.trackPosX = -30.0;
    /**
     * Track parameters.
     */
    GameConstants.trackPosY = Math.fround(8.90813 + 20.0);
    /**
     * Track parameters.
     */
    GameConstants.trackFric = 1.0;
    /**
     * Track parameters.
     */
    GameConstants.trackRest = 0.2;
    /**
     * Track parameters.
     */
    GameConstants.trackXDim = 1000.0;
    /**
     * Track parameters.
     */
    GameConstants.trackYDim = 20.0;
    /**
     * Foot parameters.
     */
    GameConstants.rFootPosX = -0.9675;
    /**
     * Foot parameters.
     */
    GameConstants.rFootPosY = 7.772;
    /**
     * Foot parameters.
     */
    GameConstants.lFootPosX = 3.763;
    /**
     * Foot parameters.
     */
    GameConstants.lFootPosY = 8.101;
    GameConstants.rFootAng = 0.7498;
    GameConstants.rFootMass = 11.63;
    GameConstants.rFootInertia = 9.017;
    GameConstants.rFootL = 2.6875;
    GameConstants.rFootH = 1.44249;
    GameConstants.rFootFric = 1.5;
    GameConstants.rFootDensity = 3.0;
    GameConstants.lFootAng = 0.1429;
    GameConstants.lFootMass = 10.895;
    GameConstants.lFootInertia = 8.242;
    GameConstants.lFootL = 2.695;
    GameConstants.lFootH = 1.3475;
    GameConstants.lFootFric = 1.5;
    GameConstants.lFootDensity = 3.0;
    /**
     * Shank parameters.
     */
    GameConstants.rCalfPosX = 0.085;
    /**
     * Shank parameters.
     */
    GameConstants.rCalfPosY = 5.381;
    /**
     * Shank parameters.
     */
    GameConstants.lCalfPosX = 2.986;
    /**
     * Shank parameters.
     */
    GameConstants.lCalfPosY = 5.523;
    GameConstants.rCalfAng = -0.821;
    GameConstants.lCalfAng = -1.582;
    GameConstants.rCalfAngAdj = 1.6061888;
    GameConstants.lCalfAngAdj = 1.6071084;
    GameConstants.rCalfMass = 7.407;
    GameConstants.lCalfMass = 7.464;
    GameConstants.rCalfInertia = 16.644;
    GameConstants.lCalfInertia = 16.893;
    GameConstants.rCalfL = 4.21;
    GameConstants.lCalfL = 4.43;
    GameConstants.rCalfW = 0.4;
    GameConstants.lCalfW = 0.4;
    GameConstants.rCalfFric = 0.2;
    GameConstants.lCalfFric = 0.2;
    GameConstants.rCalfDensity = 1.0;
    GameConstants.lCalfDensity = 1.0;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighPosX = 1.659;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighPosY = 1.999;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighPosX = 2.52;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighPosY = 1.615;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighAng = 1.468;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighAng = -1.977;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighAngAdj = -1.5443826;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighAngAdj = 1.6192564;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighMass = 10.54;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighMass = 10.037;
    /**
     * Thigh parameters.
     */
    GameConstants.rThighInertia = 28.067;
    /**
     * Thigh parameters.
     */
    GameConstants.lThighInertia = 24.546;
    GameConstants.rThighL = 4.19;
    GameConstants.lThighL = 3.56;
    GameConstants.rThighW = 0.6;
    GameConstants.lThighW = 0.6;
    GameConstants.rThighFric = 0.2;
    GameConstants.lThighFric = 0.2;
    GameConstants.rThighDensity = 1.0;
    GameConstants.lThighDensity = 1.0;
    /**
     * Torso parameters.
     */
    GameConstants.torsoPosX = 2.525;
    /**
     * Torso parameters.
     */
    GameConstants.torsoPosY = -1.926;
    /**
     * Torso parameters.
     */
    GameConstants.torsoAng = -1.251;
    /**
     * Torso parameters.
     */
    GameConstants.torsoAngAdj = 1.6519021;
    /**
     * Torso parameters.
     */
    GameConstants.torsoMass = 18.668;
    /**
     * Torso parameters.
     */
    GameConstants.torsoInertia = 79.376;
    GameConstants.torsoL = 5.0;
    GameConstants.torsoW = 1.5;
    GameConstants.torsoFric = 0.2;
    GameConstants.torsoDensity = 1.0;
    /**
     * Head parameters.
     */
    GameConstants.headPosX = 3.896;
    /**
     * Head parameters.
     */
    GameConstants.headPosY = -5.679;
    /**
     * Head parameters.
     */
    GameConstants.headAng = 0.058;
    /**
     * Head parameters.
     */
    GameConstants.headAngAdj = 0.20192142;
    /**
     * Head parameters.
     */
    GameConstants.headMass = 5.674;
    /**
     * Head parameters.
     */
    GameConstants.headInertia = 5.483;
    GameConstants.headR = 1.1;
    GameConstants.headFric = 0.2;
    GameConstants.headDensity = 1.0;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmPosX = 1.165;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmPosY = -3.616;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmPosX = 4.475;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmPosY = -2.911;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmAng = -0.466;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmAng = 0.843;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmAngAdj = 1.5711966;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmAngAdj = -1.6907064;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmMass = 5.837;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmMass = 4.6065;
    /**
     * Upper arm parameters.
     */
    GameConstants.rUArmInertia = 8.479;
    /**
     * Upper arm parameters.
     */
    GameConstants.lUArmInertia = 5.85;
    GameConstants.rUArmL = 2.58;
    GameConstants.lUArmL = 2.68;
    GameConstants.rUArmW = 0.2;
    GameConstants.lUArmW = 0.15;
    GameConstants.rUArmFric = 0.2;
    GameConstants.lUArmFric = 0.2;
    GameConstants.rUArmDensity = 1.0;
    GameConstants.lUArmDensity = 1.0;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmPosX = 0.3662;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmPosY = -1.248;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmPosX = 5.899;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmPosY = -3.06;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmAng = -1.762;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmAng = -1.251;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmAngAdj = 1.5213192;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmAngAdj = 1.4470458;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmMass = 5.99;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmMass = 3.8445;
    /**
     * Lower arm parameters.
     */
    GameConstants.rLArmInertia = 10.768;
    /**
     * Lower arm parameters.
     */
    GameConstants.lLArmInertia = 4.301;
    GameConstants.rLArmL = 3.56;
    GameConstants.lLArmL = 2.54;
    GameConstants.rLArmW = 0.15;
    GameConstants.lLArmW = 0.12;
    GameConstants.rLArmFric = 0.2;
    GameConstants.lLArmFric = 0.2;
    GameConstants.rLArmDensity = 1.0;
    GameConstants.lLArmDensity = 1.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rAnkleSpeed1 = 2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rAnkleSpeed2 = -2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lAnkleSpeed1 = -2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lAnkleSpeed2 = 2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rKneeSpeed1 = -2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rKneeSpeed2 = 2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lKneeSpeed1 = 2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lKneeSpeed2 = -2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rHipSpeed1 = -2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rHipSpeed2 = 2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lHipSpeed1 = 2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lHipSpeed2 = -2.5;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rShoulderSpeed1 = 2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.rShoulderSpeed2 = -2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lShoulderSpeed1 = -2.0;
    /**
     * Joint speed setpoints.
     */
    GameConstants.lShoulderSpeed2 = 2.0;
    /**
     * Joint limits.
     */
    GameConstants.oRHipLimLo = -1.3;
    /**
     * Joint limits.
     */
    GameConstants.oRHipLimHi = 0.7;
    /**
     * Joint limits.
     */
    GameConstants.oLHipLimLo = -1.0;
    /**
     * Joint limits.
     */
    GameConstants.oLHipLimHi = 1.0;
    /**
     * Joint limits.
     */
    GameConstants.pRHipLimLo = -0.8;
    /**
     * Joint limits.
     */
    GameConstants.pRHipLimHi = 1.2;
    /**
     * Joint limits.
     */
    GameConstants.pLHipLimLo = -1.5;
    /**
     * Joint limits.
     */
    GameConstants.pLHipLimHi = 0.5;
    /**
     * Springs and things.
     */
    GameConstants.neckStiff = 15.0;
    /**
     * Springs and things.
     */
    GameConstants.neckDamp = 5.0;
    /**
     * Springs and things.
     */
    GameConstants.rElbowStiff = 1.0;
    /**
     * Springs and things.
     */
    GameConstants.lElbowStiff = 1.0;
    /**
     * Springs and things.
     */
    GameConstants.rElbowDamp = 0.0;
    /**
     * Springs and things.
     */
    GameConstants.lElbowDamp = 0.0;
    /**
     * Initial conditions.
     */
    GameConstants.rAnklePosX = -0.9675;
    /**
     * Initial conditions.
     */
    GameConstants.rAnklePosY = 7.772;
    /**
     * Initial conditions.
     */
    GameConstants.lAnklePosX = 3.763;
    /**
     * Initial conditions.
     */
    GameConstants.lAnklePosY = 8.101;
    /**
     * Initial conditions.
     */
    GameConstants.rKneePosX = 1.58;
    /**
     * Initial conditions.
     */
    GameConstants.rKneePosY = 4.11375;
    /**
     * Initial conditions.
     */
    GameConstants.lKneePosX = 3.2625;
    /**
     * Initial conditions.
     */
    GameConstants.lKneePosY = 3.51625;
    /**
     * Initial conditions.
     */
    GameConstants.rHipPosX = 1.26;
    /**
     * Initial conditions.
     */
    GameConstants.rHipPosY = -0.0675;
    /**
     * Initial conditions.
     */
    GameConstants.lHipPosX = 2.01625;
    /**
     * Initial conditions.
     */
    GameConstants.lHipPosY = 0.18125;
    /**
     * Initial conditions.
     */
    GameConstants.rShoulderPosX = 2.24375;
    /**
     * Initial conditions.
     */
    GameConstants.rShoulderPosY = -4.1425;
    /**
     * Initial conditions.
     */
    GameConstants.lShoulderPosX = 3.63875;
    /**
     * Initial conditions.
     */
    GameConstants.lShoulderPosY = -3.58875;
    /**
     * Initial conditions.
     */
    GameConstants.rElbowPosX = -0.06;
    /**
     * Initial conditions.
     */
    GameConstants.rElbowPosY = -2.985;
    /**
     * Initial conditions.
     */
    GameConstants.lElbowPosX = 5.65125;
    /**
     * Initial conditions.
     */
    GameConstants.lElbowPosY = -1.8125;
    /**
     * Initial conditions.
     */
    GameConstants.neckPosX = 3.604;
    /**
     * Initial conditions.
     */
    GameConstants.neckPosY = -4.581;
    /**
     * Angle failure limits. Fail if torso angle is too big or small to rule out stupid hopping that eventually falls.
     */
    GameConstants.torsoAngUpper = 1.57;
    /**
     * Angle failure limits. Fail if torso angle is too big or small to rule out stupid hopping that eventually falls.
     */
    GameConstants.torsoAngLower = -2.2;
    game.GameConstants = GameConstants;
    GameConstants["__class"] = "game.GameConstants";
})(game || (game = {}));
(function (game) {
    /**
     * Make new state from a list of StateVariables. This is now the default way that the GameThreadSafe does it. To make
     * a new State from an existing game, the best bet is to call {@link GameThreadSafe#getCurrentState()}.
     *
     * @param {game.StateVariable} bodyS    State of the torso.
     * @param {game.StateVariable} headS    State of the head.
     * @param {game.StateVariable} rthighS  State of the right thigh.
     * @param {game.StateVariable} lthighS  State of the left thigh.
     * @param {game.StateVariable} rcalfS   State of the right shank.
     * @param {game.StateVariable} lcalfS   State of the left shank.
     * @param {game.StateVariable} rfootS   State of the right foot.
     * @param {game.StateVariable} lfootS   State of the left foot.
     * @param {game.StateVariable} ruarmS   State of the right upper arm.
     * @param {game.StateVariable} luarmS   State of the left upper arm.
     * @param {game.StateVariable} rlarmS   State of the right lower arm.
     * @param {game.StateVariable} llarmS   State of the left lower arm.
     * @param {boolean} isFailed Whether this state represents a fallen runner.
     * @class
     * @author matt
     */
    class State {
        constructor(bodyS, headS, rthighS, lthighS, rcalfS, lcalfS, rfootS, lfootS, ruarmS, luarmS, rlarmS, llarmS, isFailed) {
            if (((bodyS != null && bodyS instanceof game.StateVariable) || bodyS === null) && ((headS != null && headS instanceof game.StateVariable) || headS === null) && ((rthighS != null && rthighS instanceof game.StateVariable) || rthighS === null) && ((lthighS != null && lthighS instanceof game.StateVariable) || lthighS === null) && ((rcalfS != null && rcalfS instanceof game.StateVariable) || rcalfS === null) && ((lcalfS != null && lcalfS instanceof game.StateVariable) || lcalfS === null) && ((rfootS != null && rfootS instanceof game.StateVariable) || rfootS === null) && ((lfootS != null && lfootS instanceof game.StateVariable) || lfootS === null) && ((ruarmS != null && ruarmS instanceof game.StateVariable) || ruarmS === null) && ((luarmS != null && luarmS instanceof game.StateVariable) || luarmS === null) && ((rlarmS != null && rlarmS instanceof game.StateVariable) || rlarmS === null) && ((llarmS != null && llarmS instanceof game.StateVariable) || llarmS === null) && ((typeof isFailed === 'boolean') || isFailed === null)) {
                let __args = arguments;
                if (this.failedState === undefined)
                    this.failedState = false;
                if (this.body === undefined)
                    this.body = null;
                if (this.rthigh === undefined)
                    this.rthigh = null;
                if (this.lthigh === undefined)
                    this.lthigh = null;
                if (this.rcalf === undefined)
                    this.rcalf = null;
                if (this.lcalf === undefined)
                    this.lcalf = null;
                if (this.rfoot === undefined)
                    this.rfoot = null;
                if (this.lfoot === undefined)
                    this.lfoot = null;
                if (this.ruarm === undefined)
                    this.ruarm = null;
                if (this.luarm === undefined)
                    this.luarm = null;
                if (this.rlarm === undefined)
                    this.rlarm = null;
                if (this.llarm === undefined)
                    this.llarm = null;
                if (this.head === undefined)
                    this.head = null;
                if (this.stateVariables === undefined)
                    this.stateVariables = null;
                if (this.failedState === undefined)
                    this.failedState = false;
                if (this.body === undefined)
                    this.body = null;
                if (this.rthigh === undefined)
                    this.rthigh = null;
                if (this.lthigh === undefined)
                    this.lthigh = null;
                if (this.rcalf === undefined)
                    this.rcalf = null;
                if (this.lcalf === undefined)
                    this.lcalf = null;
                if (this.rfoot === undefined)
                    this.rfoot = null;
                if (this.lfoot === undefined)
                    this.lfoot = null;
                if (this.ruarm === undefined)
                    this.ruarm = null;
                if (this.luarm === undefined)
                    this.luarm = null;
                if (this.rlarm === undefined)
                    this.rlarm = null;
                if (this.llarm === undefined)
                    this.llarm = null;
                if (this.head === undefined)
                    this.head = null;
                if (this.stateVariables === undefined)
                    this.stateVariables = null;
                (() => {
                    this.body = bodyS;
                    this.head = headS;
                    this.rthigh = rthighS;
                    this.lthigh = lthighS;
                    this.rcalf = rcalfS;
                    this.lcalf = lcalfS;
                    this.rfoot = rfootS;
                    this.lfoot = lfootS;
                    this.ruarm = ruarmS;
                    this.luarm = luarmS;
                    this.rlarm = rlarmS;
                    this.llarm = llarmS;
                    this.failedState = isFailed;
                    this.stateVariables = [this.body, this.rthigh, this.lthigh, this.rcalf, this.lcalf, this.rfoot, this.lfoot, this.ruarm, this.luarm, this.rlarm, this.llarm, this.head];
                })();
            }
            else if (((bodyS != null && bodyS instanceof Array && (bodyS.length == 0 || bodyS[0] == null || (typeof bodyS[0] === 'number'))) || bodyS === null) && ((typeof headS === 'boolean') || headS === null) && rthighS === undefined && lthighS === undefined && rcalfS === undefined && lcalfS === undefined && rfootS === undefined && lfootS === undefined && ruarmS === undefined && luarmS === undefined && rlarmS === undefined && llarmS === undefined && isFailed === undefined) {
                let __args = arguments;
                let stateVars = __args[0];
                let isFailed = __args[1];
                if (this.failedState === undefined)
                    this.failedState = false;
                if (this.body === undefined)
                    this.body = null;
                if (this.rthigh === undefined)
                    this.rthigh = null;
                if (this.lthigh === undefined)
                    this.lthigh = null;
                if (this.rcalf === undefined)
                    this.rcalf = null;
                if (this.lcalf === undefined)
                    this.lcalf = null;
                if (this.rfoot === undefined)
                    this.rfoot = null;
                if (this.lfoot === undefined)
                    this.lfoot = null;
                if (this.ruarm === undefined)
                    this.ruarm = null;
                if (this.luarm === undefined)
                    this.luarm = null;
                if (this.rlarm === undefined)
                    this.rlarm = null;
                if (this.llarm === undefined)
                    this.llarm = null;
                if (this.head === undefined)
                    this.head = null;
                if (this.stateVariables === undefined)
                    this.stateVariables = null;
                if (this.failedState === undefined)
                    this.failedState = false;
                if (this.body === undefined)
                    this.body = null;
                if (this.rthigh === undefined)
                    this.rthigh = null;
                if (this.lthigh === undefined)
                    this.lthigh = null;
                if (this.rcalf === undefined)
                    this.rcalf = null;
                if (this.lcalf === undefined)
                    this.lcalf = null;
                if (this.rfoot === undefined)
                    this.rfoot = null;
                if (this.lfoot === undefined)
                    this.lfoot = null;
                if (this.ruarm === undefined)
                    this.ruarm = null;
                if (this.luarm === undefined)
                    this.luarm = null;
                if (this.rlarm === undefined)
                    this.rlarm = null;
                if (this.llarm === undefined)
                    this.llarm = null;
                if (this.head === undefined)
                    this.head = null;
                if (this.stateVariables === undefined)
                    this.stateVariables = null;
                (() => {
                    this.body = new game.StateVariable(stateVars[0], stateVars[1], stateVars[2], stateVars[3], stateVars[4], stateVars[5]);
                    this.head = new game.StateVariable(stateVars[6], stateVars[7], stateVars[8], stateVars[9], stateVars[10], stateVars[11]);
                    this.rthigh = new game.StateVariable(stateVars[12], stateVars[13], stateVars[14], stateVars[15], stateVars[16], stateVars[17]);
                    this.lthigh = new game.StateVariable(stateVars[18], stateVars[19], stateVars[20], stateVars[21], stateVars[22], stateVars[23]);
                    this.rcalf = new game.StateVariable(stateVars[24], stateVars[25], stateVars[26], stateVars[27], stateVars[28], stateVars[29]);
                    this.lcalf = new game.StateVariable(stateVars[30], stateVars[31], stateVars[32], stateVars[33], stateVars[34], stateVars[35]);
                    this.rfoot = new game.StateVariable(stateVars[36], stateVars[37], stateVars[38], stateVars[39], stateVars[40], stateVars[41]);
                    this.lfoot = new game.StateVariable(stateVars[42], stateVars[43], stateVars[44], stateVars[45], stateVars[46], stateVars[47]);
                    this.ruarm = new game.StateVariable(stateVars[48], stateVars[49], stateVars[50], stateVars[51], stateVars[52], stateVars[53]);
                    this.luarm = new game.StateVariable(stateVars[54], stateVars[55], stateVars[56], stateVars[57], stateVars[58], stateVars[59]);
                    this.rlarm = new game.StateVariable(stateVars[60], stateVars[61], stateVars[62], stateVars[63], stateVars[64], stateVars[65]);
                    this.llarm = new game.StateVariable(stateVars[66], stateVars[67], stateVars[68], stateVars[69], stateVars[70], stateVars[71]);
                    this.stateVariables = [this.body, this.rthigh, this.lthigh, this.rcalf, this.lcalf, this.rfoot, this.lfoot, this.ruarm, this.luarm, this.rlarm, this.llarm, this.head];
                    this.failedState = isFailed;
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Get the whole array of state variables.
         *
         * @return {Array} Array containing a {@link StateVariable} for each runner link.
         */
        getStates() {
            return this.stateVariables;
        }
        /**
         * Get a specific state value by specifying the link and desired configuration/velocity.
         *
         * @param {game.State.ObjectName} obj   Runner body who we want to fetch a state value from.
         * @param {game.State.StateName} state Configuration/velocity we want to fetch for the specified runner link.
         * @return {number} Value of the requested state.
         */
        getStateVarFromName(obj, state) {
            let st;
            switch ((obj)) {
                case game.State.ObjectName.BODY:
                    st = this.body;
                    break;
                case game.State.ObjectName.HEAD:
                    st = this.head;
                    break;
                case game.State.ObjectName.LCALF:
                    st = this.lcalf;
                    break;
                case game.State.ObjectName.LFOOT:
                    st = this.lfoot;
                    break;
                case game.State.ObjectName.LLARM:
                    st = this.llarm;
                    break;
                case game.State.ObjectName.LTHIGH:
                    st = this.lthigh;
                    break;
                case game.State.ObjectName.LUARM:
                    st = this.luarm;
                    break;
                case game.State.ObjectName.RCALF:
                    st = this.rcalf;
                    break;
                case game.State.ObjectName.RFOOT:
                    st = this.rfoot;
                    break;
                case game.State.ObjectName.RLARM:
                    st = this.rlarm;
                    break;
                case game.State.ObjectName.RTHIGH:
                    st = this.rthigh;
                    break;
                case game.State.ObjectName.RUARM:
                    st = this.ruarm;
                    break;
                default:
                    throw Object.defineProperty(new Error("Unknown object state queried."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            }
            let stateValue;
            switch ((state)) {
                case game.State.StateName.DTH:
                    stateValue = st.getDth();
                    break;
                case game.State.StateName.DX:
                    stateValue = st.getDx();
                    break;
                case game.State.StateName.DY:
                    stateValue = st.getDy();
                    break;
                case game.State.StateName.TH:
                    stateValue = st.getTh();
                    break;
                case game.State.StateName.X:
                    stateValue = st.getX();
                    break;
                case game.State.StateName.Y:
                    stateValue = st.getY();
                    break;
                default:
                    throw Object.defineProperty(new Error("Unknown object state queried."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
            }
            return stateValue;
        }
        /**
         * Turn the state into an array of floats with body x subtracted from all x coordinates.
         * @return {Array}
         */
        flattenState() {
            let flatState = (s => { let a = []; while (s-- > 0)
                a.push(0); return a; })(72);
            let bodyX = this.body.getX();
            flatState[0] = 0;
            flatState[1] = this.body.getY();
            flatState[2] = this.body.getTh();
            flatState[3] = this.body.getDx();
            flatState[4] = this.body.getDy();
            flatState[5] = this.body.getDth();
            flatState[6] = Math.fround(this.head.getX() - bodyX);
            flatState[7] = this.head.getY();
            flatState[8] = this.head.getTh();
            flatState[9] = this.head.getDx();
            flatState[10] = this.head.getDy();
            flatState[11] = this.head.getDth();
            flatState[12] = Math.fround(this.rthigh.getX() - bodyX);
            flatState[13] = this.rthigh.getY();
            flatState[14] = this.rthigh.getTh();
            flatState[15] = this.rthigh.getDx();
            flatState[16] = this.rthigh.getDy();
            flatState[17] = this.rthigh.getDth();
            flatState[18] = Math.fround(this.lthigh.getX() - bodyX);
            flatState[19] = this.lthigh.getY();
            flatState[20] = this.lthigh.getTh();
            flatState[21] = this.lthigh.getDx();
            flatState[22] = this.lthigh.getDy();
            flatState[23] = this.lthigh.getDth();
            flatState[24] = Math.fround(this.rcalf.getX() - bodyX);
            flatState[25] = this.rcalf.getY();
            flatState[26] = this.rcalf.getTh();
            flatState[27] = this.rcalf.getDx();
            flatState[28] = this.rcalf.getDy();
            flatState[29] = this.rcalf.getDth();
            flatState[30] = Math.fround(this.lcalf.getX() - bodyX);
            flatState[31] = this.lcalf.getY();
            flatState[32] = this.lcalf.getTh();
            flatState[33] = this.lcalf.getDx();
            flatState[34] = this.lcalf.getDy();
            flatState[35] = this.lcalf.getDth();
            flatState[36] = Math.fround(this.rfoot.getX() - bodyX);
            flatState[37] = this.rfoot.getY();
            flatState[38] = this.rfoot.getTh();
            flatState[39] = this.rfoot.getDx();
            flatState[40] = this.rfoot.getDy();
            flatState[41] = this.rfoot.getDth();
            flatState[42] = Math.fround(this.lfoot.getX() - bodyX);
            flatState[43] = this.lfoot.getY();
            flatState[44] = this.lfoot.getTh();
            flatState[45] = this.lfoot.getDx();
            flatState[46] = this.lfoot.getDy();
            flatState[47] = this.lfoot.getDth();
            flatState[48] = Math.fround(this.ruarm.getX() - bodyX);
            flatState[49] = this.ruarm.getY();
            flatState[50] = this.ruarm.getTh();
            flatState[51] = this.ruarm.getDx();
            flatState[52] = this.ruarm.getDy();
            flatState[53] = this.ruarm.getDth();
            flatState[54] = Math.fround(this.luarm.getX() - bodyX);
            flatState[55] = this.luarm.getY();
            flatState[56] = this.luarm.getTh();
            flatState[57] = this.luarm.getDx();
            flatState[58] = this.luarm.getDy();
            flatState[59] = this.luarm.getDth();
            flatState[60] = Math.fround(this.rlarm.getX() - bodyX);
            flatState[61] = this.rlarm.getY();
            flatState[62] = this.rlarm.getTh();
            flatState[63] = this.rlarm.getDx();
            flatState[64] = this.rlarm.getDy();
            flatState[65] = this.rlarm.getDth();
            flatState[66] = Math.fround(this.llarm.getX() - bodyX);
            flatState[67] = this.llarm.getY();
            flatState[68] = this.llarm.getTh();
            flatState[69] = this.llarm.getDx();
            flatState[70] = this.llarm.getDy();
            flatState[71] = this.llarm.getDth();
            return flatState;
        }
        /**
         * Get whether this state represents a failed runner configuration.
         *
         * @return {boolean} Runner "fallen" status. True means failed. False means not failed.
         */
        isFailed() {
            return this.failedState;
        }
    }
    State.serialVersionUID = 2;
    game.State = State;
    State["__class"] = "game.State";
    State["__interfaces"] = ["java.io.Serializable"];
    (function (State) {
        /**
         * Name of each body part.
         * @enum
         * @property {game.State.ObjectName} BODY
         * @property {game.State.ObjectName} HEAD
         * @property {game.State.ObjectName} RTHIGH
         * @property {game.State.ObjectName} LTHIGH
         * @property {game.State.ObjectName} RCALF
         * @property {game.State.ObjectName} LCALF
         * @property {game.State.ObjectName} RFOOT
         * @property {game.State.ObjectName} LFOOT
         * @property {game.State.ObjectName} RUARM
         * @property {game.State.ObjectName} LUARM
         * @property {game.State.ObjectName} RLARM
         * @property {game.State.ObjectName} LLARM
         * @class
         */
        var ObjectName;
        (function (ObjectName) {
            ObjectName[ObjectName["BODY"] = 0] = "BODY";
            ObjectName[ObjectName["HEAD"] = 1] = "HEAD";
            ObjectName[ObjectName["RTHIGH"] = 2] = "RTHIGH";
            ObjectName[ObjectName["LTHIGH"] = 3] = "LTHIGH";
            ObjectName[ObjectName["RCALF"] = 4] = "RCALF";
            ObjectName[ObjectName["LCALF"] = 5] = "LCALF";
            ObjectName[ObjectName["RFOOT"] = 6] = "RFOOT";
            ObjectName[ObjectName["LFOOT"] = 7] = "LFOOT";
            ObjectName[ObjectName["RUARM"] = 8] = "RUARM";
            ObjectName[ObjectName["LUARM"] = 9] = "LUARM";
            ObjectName[ObjectName["RLARM"] = 10] = "RLARM";
            ObjectName[ObjectName["LLARM"] = 11] = "LLARM";
        })(ObjectName = State.ObjectName || (State.ObjectName = {}));
        /**
         * Name of each state value (configurations and velocities).
         * @enum
         * @property {game.State.StateName} X
         * @property {game.State.StateName} Y
         * @property {game.State.StateName} TH
         * @property {game.State.StateName} DX
         * @property {game.State.StateName} DY
         * @property {game.State.StateName} DTH
         * @class
         */
        var StateName;
        (function (StateName) {
            StateName[StateName["X"] = 0] = "X";
            StateName[StateName["Y"] = 1] = "Y";
            StateName[StateName["TH"] = 2] = "TH";
            StateName[StateName["DX"] = 3] = "DX";
            StateName[StateName["DY"] = 4] = "DY";
            StateName[StateName["DTH"] = 5] = "DTH";
        })(StateName = State.StateName || (State.StateName = {}));
    })(State = game.State || (game.State = {}));
})(game || (game = {}));
(function (game) {
    /**
     * Make a new StateVariables holding the configuration and velocity information for a single runner link.
     *
     * @param {number} x   Horizontal position of the body.
     * @param {number} y   Vertical position of the body.
     * @param {number} th  Counterclockwise angle of the body.
     * @param {number} dx  Horizontal velocity of the body.
     * @param {number} dy  Vertical velocity of the body.
     * @param {number} dth Counterclockwise angular rate of the body.
     * @class
     * @author matt
     */
    class StateVariable {
        constructor(x, y, th, dx, dy, dth) {
            if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof th === 'number') || th === null) && ((typeof dx === 'number') || dx === null) && ((typeof dy === 'number') || dy === null) && ((typeof dth === 'number') || dth === null)) {
                let __args = arguments;
                if (this.x === undefined)
                    this.x = 0;
                if (this.y === undefined)
                    this.y = 0;
                if (this.th === undefined)
                    this.th = 0;
                if (this.dx === undefined)
                    this.dx = 0;
                if (this.dy === undefined)
                    this.dy = 0;
                if (this.dth === undefined)
                    this.dth = 0;
                if (this.x === undefined)
                    this.x = 0;
                if (this.y === undefined)
                    this.y = 0;
                if (this.th === undefined)
                    this.th = 0;
                if (this.dx === undefined)
                    this.dx = 0;
                if (this.dy === undefined)
                    this.dy = 0;
                if (this.dth === undefined)
                    this.dth = 0;
                (() => {
                    this.x = x;
                    this.y = y;
                    this.th = th;
                    this.dx = dx;
                    this.dy = dy;
                    this.dth = dth;
                })();
            }
            else if (((x != null && (x instanceof Array)) || x === null) && y === undefined && th === undefined && dx === undefined && dy === undefined && dth === undefined) {
                let __args = arguments;
                let stateVals = __args[0];
                if (this.x === undefined)
                    this.x = 0;
                if (this.y === undefined)
                    this.y = 0;
                if (this.th === undefined)
                    this.th = 0;
                if (this.dx === undefined)
                    this.dx = 0;
                if (this.dy === undefined)
                    this.dy = 0;
                if (this.dth === undefined)
                    this.dth = 0;
                if (this.x === undefined)
                    this.x = 0;
                if (this.y === undefined)
                    this.y = 0;
                if (this.th === undefined)
                    this.th = 0;
                if (this.dx === undefined)
                    this.dx = 0;
                if (this.dy === undefined)
                    this.dy = 0;
                if (this.dth === undefined)
                    this.dth = 0;
                (() => {
                    if (stateVals.length !== 6)
                        throw Object.defineProperty(new Error("Tried to make a StateVariable with the wrong number of values."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                    this.x = stateVals[0];
                    this.y = stateVals[1];
                    this.th = stateVals[2];
                    this.dx = stateVals[3];
                    this.dy = stateVals[4];
                    this.dth = stateVals[5];
                })();
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Get the horizontal position of the body.
         *
         * @return {number} Horizontal position of the body.
         */
        getX() {
            return this.x;
        }
        /**
         * Get the vertical position of the body.
         *
         * @return {number} Vertical position of the body.
         */
        getY() {
            return this.y;
        }
        /**
         * Get the counterclockwise angle of the body.
         *
         * @return {number} Counterclockwise angle of the body.
         */
        getTh() {
            return this.th;
        }
        /**
         * Get the horizontal velocity of the body.
         *
         * @return {number} Horizontal velocity of the body.
         */
        getDx() {
            return this.dx;
        }
        /**
         * Get the vertical velocity of the body.
         *
         * @return {number} Vertical velocity of the body.
         */
        getDy() {
            return this.dy;
        }
        /**
         * Get the counterclockwise angular rate of the body.
         *
         * @return {number} Counterclockwise angular rate of the body.
         */
        getDth() {
            return this.dth;
        }
    }
    StateVariable.serialVersionUID = 1;
    game.StateVariable = StateVariable;
    StateVariable["__class"] = "game.StateVariable";
    StateVariable["__interfaces"] = ["java.io.Serializable"];
})(game || (game = {}));
var org;
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Creates an AABB object using the given bounding
             * vertices.
             * @param {org.jbox2d.common.Vec2} lowerVertex the bottom left vertex of the bounding box
             * @param maxVertex the top right vertex of the bounding box
             * @param {org.jbox2d.common.Vec2} upperVertex
             * @class
             */
            class AABB {
                constructor(lowerVertex, upperVertex) {
                    if (((lowerVertex != null && lowerVertex instanceof org.jbox2d.common.Vec2) || lowerVertex === null) && ((upperVertex != null && upperVertex instanceof org.jbox2d.common.Vec2) || upperVertex === null)) {
                        let __args = arguments;
                        if (this.lowerBound === undefined)
                            this.lowerBound = null;
                        if (this.upperBound === undefined)
                            this.upperBound = null;
                        if (this.lowerBound === undefined)
                            this.lowerBound = null;
                        if (this.upperBound === undefined)
                            this.upperBound = null;
                        (() => {
                            this.lowerBound = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(lowerVertex);
                            this.upperBound = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(upperVertex);
                        })();
                    }
                    else if (((lowerVertex != null && lowerVertex instanceof org.jbox2d.collision.AABB) || lowerVertex === null) && upperVertex === undefined) {
                        let __args = arguments;
                        let copy = __args[0];
                        {
                            let __args = arguments;
                            let lowerVertex = copy.lowerBound;
                            let upperVertex = copy.upperBound;
                            if (this.lowerBound === undefined)
                                this.lowerBound = null;
                            if (this.upperBound === undefined)
                                this.upperBound = null;
                            if (this.lowerBound === undefined)
                                this.lowerBound = null;
                            if (this.upperBound === undefined)
                                this.upperBound = null;
                            (() => {
                                this.lowerBound = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(lowerVertex);
                                this.upperBound = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(upperVertex);
                            })();
                        }
                    }
                    else if (lowerVertex === undefined && upperVertex === undefined) {
                        let __args = arguments;
                        if (this.lowerBound === undefined)
                            this.lowerBound = null;
                        if (this.upperBound === undefined)
                            this.upperBound = null;
                        if (this.lowerBound === undefined)
                            this.lowerBound = null;
                        if (this.upperBound === undefined)
                            this.upperBound = null;
                        (() => {
                            this.lowerBound = new org.jbox2d.common.Vec2();
                            this.upperBound = new org.jbox2d.common.Vec2();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Sets this object from the given object
                 * @param {org.jbox2d.collision.AABB} aabb the object to copy from
                 * @return {org.jbox2d.collision.AABB}
                 */
                set(aabb) {
                    this.lowerBound.set$org_jbox2d_common_Vec2(aabb.lowerBound);
                    this.upperBound.set$org_jbox2d_common_Vec2(aabb.upperBound);
                    return this;
                }
                /**
                 * Verify that the bounds are sorted
                 * @return {boolean}
                 */
                isValid() {
                    let dx = Math.fround(this.upperBound.x - this.lowerBound.x);
                    let dy = Math.fround(this.upperBound.y - this.lowerBound.y);
                    if (!(dx >= 0.0 && dy >= 0)) {
                        return false;
                    }
                    return this.lowerBound.isValid() && this.upperBound.isValid();
                }
                /**
                 * Check if AABBs overlap. djm optimized
                 * @param {org.jbox2d.collision.AABB} box
                 * @return {boolean}
                 */
                testOverlap(box) {
                    let d1x = Math.fround(box.lowerBound.x - this.upperBound.x);
                    let d1y = Math.fround(box.lowerBound.y - this.upperBound.y);
                    let d2x = Math.fround(this.lowerBound.x - box.upperBound.x);
                    let d2y = Math.fround(this.lowerBound.y - box.upperBound.y);
                    if (d1x > 0.0 || d1y > 0.0 || d2x > 0.0 || d2y > 0.0) {
                        return false;
                    }
                    return true;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    let s = "" + this.lowerBound + " -> " + this.upperBound;
                    return s;
                }
            }
            collision.AABB = AABB;
            AABB["__class"] = "org.jbox2d.collision.AABB";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Used in BroadPhase
             * @param {org.jbox2d.collision.Bound} b
             * @class
             */
            class Bound {
                constructor(b) {
                    if (((b != null && b instanceof org.jbox2d.collision.Bound) || b === null)) {
                        let __args = arguments;
                        if (this.value === undefined)
                            this.value = 0;
                        if (this.proxyId === undefined)
                            this.proxyId = 0;
                        if (this.stabbingCount === undefined)
                            this.stabbingCount = 0;
                        if (this.value === undefined)
                            this.value = 0;
                        if (this.proxyId === undefined)
                            this.proxyId = 0;
                        if (this.stabbingCount === undefined)
                            this.stabbingCount = 0;
                        (() => {
                            this.value = b.value;
                            this.proxyId = b.proxyId;
                            this.stabbingCount = b.stabbingCount;
                        })();
                    }
                    else if (b === undefined) {
                        let __args = arguments;
                        if (this.value === undefined)
                            this.value = 0;
                        if (this.proxyId === undefined)
                            this.proxyId = 0;
                        if (this.stabbingCount === undefined)
                            this.stabbingCount = 0;
                        if (this.value === undefined)
                            this.value = 0;
                        if (this.proxyId === undefined)
                            this.proxyId = 0;
                        if (this.stabbingCount === undefined)
                            this.stabbingCount = 0;
                        (() => {
                            this.value = 0;
                            this.proxyId = 0;
                            this.stabbingCount = 0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                set(b) {
                    this.value = b.value;
                    this.proxyId = b.proxyId;
                    this.stabbingCount = b.stabbingCount;
                }
                isLower() {
                    return (this.value & 1) === 0;
                }
                isUpper() {
                    return (this.value & 1) === 1;
                }
                /**
                 * swaps the values of this bound with the other bound
                 * @param {org.jbox2d.collision.Bound} other bound to swap values with
                 */
                swap(other) {
                    let value = this.value;
                    let proxyId = this.proxyId;
                    let stabbingCount = this.stabbingCount;
                    this.value = other.value;
                    this.proxyId = other.proxyId;
                    this.stabbingCount = other.stabbingCount;
                    other.value = value;
                    other.proxyId = proxyId;
                    other.stabbingCount = stabbingCount;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    let ret = "Bound variable:\n";
                    ret += "value: " + this.value + "\n";
                    ret += "proxyId: " + this.proxyId + "\n";
                    ret += "stabbing count: " + this.stabbingCount + "\n";
                    return ret;
                }
            }
            collision.Bound = Bound;
            Bound["__class"] = "org.jbox2d.collision.Bound";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            class BoundValues {
                constructor() {
                    if (this.lowerValues === undefined)
                        this.lowerValues = null;
                    if (this.upperValues === undefined)
                        this.upperValues = null;
                    this.lowerValues = [null, null];
                    this.upperValues = [null, null];
                }
            }
            collision.BoundValues = BoundValues;
            BoundValues["__class"] = "org.jbox2d.collision.BoundValues";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Used in pair manager.
             * @class
             */
            class BufferedPair {
                constructor() {
                    if (this.proxyId1 === undefined)
                        this.proxyId1 = 0;
                    if (this.proxyId2 === undefined)
                        this.proxyId2 = 0;
                }
                /*private*/ equals(other) {
                    return this.proxyId1 === other.proxyId1 && this.proxyId2 === other.proxyId2;
                }
                /*private*/ minor(other) {
                    if (this.proxyId1 < other.proxyId1)
                        return true;
                    if (this.proxyId1 === other.proxyId1) {
                        return this.proxyId2 < other.proxyId2;
                    }
                    return false;
                }
                compareTo(p) {
                    if (this.minor(p)) {
                        return -1;
                    }
                    else if (this.equals(p)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
            }
            collision.BufferedPair = BufferedPair;
            BufferedPair["__class"] = "org.jbox2d.collision.BufferedPair";
            BufferedPair["__interfaces"] = ["java.lang.Comparable"];
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * A few static final variables that don't fit anywhere else (globals in C++ code).
             * @class
             */
            class Collision {
                static NULL_FEATURE_$LI$() { if (Collision.NULL_FEATURE == null)
                    Collision.NULL_FEATURE = 2147483647; return Collision.NULL_FEATURE; }
                ;
            }
            collision.Collision = Collision;
            Collision["__class"] = "org.jbox2d.collision.Collision";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Contact ids to facilitate warm starting.
             * @param {org.jbox2d.collision.ContactID} c
             * @class
             */
            class ContactID {
                constructor(c) {
                    if (((c != null && c instanceof org.jbox2d.collision.ContactID) || c === null)) {
                        let __args = arguments;
                        if (this.key === undefined)
                            this.key = 0;
                        if (this.features === undefined)
                            this.features = null;
                        if (this.key === undefined)
                            this.key = 0;
                        if (this.features === undefined)
                            this.features = null;
                        (() => {
                            this.key = c.key;
                            this.features = new ContactID.Features(this, c.features);
                        })();
                    }
                    else if (c === undefined) {
                        let __args = arguments;
                        if (this.key === undefined)
                            this.key = 0;
                        if (this.features === undefined)
                            this.features = null;
                        if (this.key === undefined)
                            this.key = 0;
                        if (this.features === undefined)
                            this.features = null;
                        (() => {
                            this.key = 0;
                            this.features = new ContactID.Features(this);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                isEqual(cid) {
                    return cid.features.isEqual(this.features);
                }
                /**
                 * zeros out the data
                 */
                zero() {
                    this.key = 0;
                    this.features.flip = 0;
                    this.features.incidentEdge = 0;
                    this.features.incidentVertex = 0;
                    this.features.referenceEdge = 0;
                }
                set(c) {
                    this.key = c.key;
                    this.features.set(c.features);
                }
            }
            collision.ContactID = ContactID;
            ContactID["__class"] = "org.jbox2d.collision.ContactID";
            (function (ContactID) {
                /**
                 * The features that intersect to form the contact point
                 * @param {org.jbox2d.collision.ContactID.Features} f
                 * @class
                 */
                class Features {
                    constructor(__parent, f) {
                        if (((f != null && f instanceof org.jbox2d.collision.ContactID.Features) || f === null)) {
                            let __args = Array.prototype.slice.call(arguments, [1]);
                            if (this.referenceEdge === undefined)
                                this.referenceEdge = 0;
                            if (this.incidentEdge === undefined)
                                this.incidentEdge = 0;
                            if (this.incidentVertex === undefined)
                                this.incidentVertex = 0;
                            if (this.flip === undefined)
                                this.flip = 0;
                            this.__parent = __parent;
                            if (this.referenceEdge === undefined)
                                this.referenceEdge = 0;
                            if (this.incidentEdge === undefined)
                                this.incidentEdge = 0;
                            if (this.incidentVertex === undefined)
                                this.incidentVertex = 0;
                            if (this.flip === undefined)
                                this.flip = 0;
                            (() => {
                                this.referenceEdge = f.referenceEdge;
                                this.incidentEdge = f.incidentEdge;
                                this.incidentVertex = f.incidentVertex;
                                this.flip = f.flip;
                            })();
                        }
                        else if (f === undefined) {
                            let __args = Array.prototype.slice.call(arguments, [1]);
                            if (this.referenceEdge === undefined)
                                this.referenceEdge = 0;
                            if (this.incidentEdge === undefined)
                                this.incidentEdge = 0;
                            if (this.incidentVertex === undefined)
                                this.incidentVertex = 0;
                            if (this.flip === undefined)
                                this.flip = 0;
                            this.__parent = __parent;
                            if (this.referenceEdge === undefined)
                                this.referenceEdge = 0;
                            if (this.incidentEdge === undefined)
                                this.incidentEdge = 0;
                            if (this.incidentVertex === undefined)
                                this.incidentVertex = 0;
                            if (this.flip === undefined)
                                this.flip = 0;
                            (() => {
                                this.referenceEdge = this.incidentEdge = this.incidentVertex = this.flip = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    set(f) {
                        this.referenceEdge = f.referenceEdge;
                        this.incidentEdge = f.incidentEdge;
                        this.incidentVertex = f.incidentVertex;
                        this.flip = f.flip;
                    }
                    isEqual(f) {
                        return (this.referenceEdge === f.referenceEdge && this.incidentEdge === f.incidentEdge && this.incidentVertex === f.incidentVertex && this.flip === f.flip);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        let s = "Features: (" + this.flip + " ," + this.incidentEdge + " ," + this.incidentVertex + " ," + this.referenceEdge + ")";
                        return s;
                    }
                }
                ContactID.Features = Features;
                Features["__class"] = "org.jbox2d.collision.ContactID.Features";
            })(ContactID = collision.ContactID || (collision.ContactID = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Implements the GJK algorithm for computing distance between shapes.
             * @class
             */
            class Distance {
                constructor() {
                    this.g_GJK_Iterations = 0;
                    /*private*/ this.p1s = [null, null, null];
                    /*private*/ this.p2s = [null, null, null];
                    /*private*/ this.points = [null, null, null];
                    /*private*/ this.v = new org.jbox2d.common.Vec2();
                    /*private*/ this.vNeg = new org.jbox2d.common.Vec2();
                    /*private*/ this.w = new org.jbox2d.common.Vec2();
                    /*private*/ this.w1 = new org.jbox2d.common.Vec2();
                    /*private*/ this.w2 = new org.jbox2d.common.Vec2();
                    /*private*/ this.p2r = new org.jbox2d.common.Vec2();
                    /*private*/ this.p2d = new org.jbox2d.common.Vec2();
                    /*private*/ this.distCCp1 = new org.jbox2d.common.Vec2();
                    /*private*/ this.distCCp2 = new org.jbox2d.common.Vec2();
                    /*private*/ this.distCCd = new org.jbox2d.common.Vec2();
                    /*private*/ this.cWorld = new org.jbox2d.common.Vec2();
                    /*private*/ this.ECcLocal = new org.jbox2d.common.Vec2();
                    /*private*/ this.ECvWorld = new org.jbox2d.common.Vec2();
                    /*private*/ this.ECd = new org.jbox2d.common.Vec2();
                    /*private*/ this.ECtemp = new org.jbox2d.common.Vec2();
                    /*private*/ this.point = new org.jbox2d.collision.Point();
                    /*private*/ this.CPp1 = new org.jbox2d.common.Vec2();
                    /*private*/ this.CPp2 = new org.jbox2d.common.Vec2();
                    /*private*/ this.CPd = new org.jbox2d.common.Vec2();
                    for (let i = 0; i < 3; ++i) {
                        {
                            this.p1s[i] = new org.jbox2d.common.Vec2();
                            this.p2s[i] = new org.jbox2d.common.Vec2();
                            this.points[i] = new org.jbox2d.common.Vec2();
                        }
                        ;
                    }
                }
                ProcessTwo(x1, x2, p1s, p2s, points) {
                    this.p2r.x = -points[1].x;
                    this.p2r.y = -points[1].y;
                    this.p2d.x = Math.fround(points[0].x - points[1].x);
                    this.p2d.y = Math.fround(points[0].y - points[1].y);
                    let length = this.p2d.normalize();
                    let lambda = org.jbox2d.common.Vec2.dot(this.p2r, this.p2d);
                    if (lambda <= 0.0 || length < org.jbox2d.common.Settings.EPSILON) {
                        x1.set$org_jbox2d_common_Vec2(p1s[1]);
                        x2.set$org_jbox2d_common_Vec2(p2s[1]);
                        p1s[0].set$org_jbox2d_common_Vec2(p1s[1]);
                        p2s[0].set$org_jbox2d_common_Vec2(p2s[1]);
                        points[0].set$org_jbox2d_common_Vec2(points[1]);
                        return 1;
                    }
                    lambda /= length;
                    x1.set$float$float(Math.fround(p1s[1].x + Math.fround(lambda * (Math.fround(p1s[0].x - p1s[1].x)))), Math.fround(p1s[1].y + Math.fround(lambda * (Math.fround(p1s[0].y - p1s[1].y)))));
                    x2.set$float$float(Math.fround(p2s[1].x + Math.fround(lambda * (Math.fround(p2s[0].x - p2s[1].x)))), Math.fround(p2s[1].y + Math.fround(lambda * (Math.fround(p2s[0].y - p2s[1].y)))));
                    return 2;
                }
                ProcessThree(x1, x2, p1s, p2s, points) {
                    let a = points[0];
                    let b = points[1];
                    let c = points[2];
                    let abx = Math.fround(b.x - a.x);
                    let aby = Math.fround(b.y - a.y);
                    let acx = Math.fround(c.x - a.x);
                    let acy = Math.fround(c.y - a.y);
                    let bcx = Math.fround(c.x - b.x);
                    let bcy = Math.fround(c.y - b.y);
                    let sn = -(Math.fround(Math.fround(a.x * abx) + Math.fround(a.y * aby)));
                    let sd = Math.fround(Math.fround(b.x * abx) + Math.fround(b.y * aby));
                    let tn = -(Math.fround(Math.fround(a.x * acx) + Math.fround(a.y * acy)));
                    let td = Math.fround(Math.fround(c.x * acx) + Math.fround(c.y * acy));
                    let un = -(Math.fround(Math.fround(b.x * bcx) + Math.fround(b.y * bcy)));
                    let ud = Math.fround(Math.fround(c.x * bcx) + Math.fround(c.y * bcy));
                    if (td <= 0.0 && ud <= 0.0) {
                        x1.set$org_jbox2d_common_Vec2(p1s[2]);
                        x2.set$org_jbox2d_common_Vec2(p2s[2]);
                        p1s[0].set$org_jbox2d_common_Vec2(p1s[2]);
                        p2s[0].set$org_jbox2d_common_Vec2(p2s[2]);
                        points[0].set$org_jbox2d_common_Vec2(points[2]);
                        return 1;
                    }
                    let n = Math.fround(Math.fround(abx * acy) - Math.fround(aby * acx));
                    let vc = Math.fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b));
                    let va = Math.fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b, c));
                    if (va <= 0.0 && un >= 0.0 && ud >= 0.0 && Math.fround(un + ud) > 0.0) {
                        let lambda = Math.fround(un / (Math.fround(un + ud)));
                        x1.set$float$float(Math.fround(p1s[1].x + Math.fround(lambda * (Math.fround(p1s[2].x - p1s[1].x)))), Math.fround(p1s[1].y + Math.fround(lambda * (Math.fround(p1s[2].y - p1s[1].y)))));
                        x2.set$float$float(Math.fround(p2s[1].x + Math.fround(lambda * (Math.fround(p2s[2].x - p2s[1].x)))), Math.fround(p2s[1].y + Math.fround(lambda * (Math.fround(p2s[2].y - p2s[1].y)))));
                        p1s[0].set$org_jbox2d_common_Vec2(p1s[2]);
                        p2s[0].set$org_jbox2d_common_Vec2(p2s[2]);
                        points[0].set$org_jbox2d_common_Vec2(points[2]);
                        return 2;
                    }
                    let vb = Math.fround(n * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(c, a));
                    if (vb <= 0.0 && tn >= 0.0 && td >= 0.0 && Math.fround(tn + td) > 0.0) {
                        let lambda = Math.fround(tn / (Math.fround(tn + td)));
                        x1.set$float$float(Math.fround(p1s[0].x + Math.fround(lambda * (Math.fround(p1s[2].x - p1s[0].x)))), Math.fround(p1s[0].y + Math.fround(lambda * (Math.fround(p1s[2].y - p1s[0].y)))));
                        x2.set$float$float(Math.fround(p2s[0].x + Math.fround(lambda * (Math.fround(p2s[2].x - p2s[0].x)))), Math.fround(p2s[0].y + Math.fround(lambda * (Math.fround(p2s[2].y - p2s[0].y)))));
                        p1s[1].set$org_jbox2d_common_Vec2(p1s[2]);
                        p2s[1].set$org_jbox2d_common_Vec2(p2s[2]);
                        points[1].set$org_jbox2d_common_Vec2(points[2]);
                        return 2;
                    }
                    let denom = Math.fround(Math.fround(va + vb) + vc);
                    denom = Math.fround(1.0 / denom);
                    let u = Math.fround(va * denom);
                    let v = Math.fround(vb * denom);
                    let w = Math.fround(Math.fround(1.0 - u) - v);
                    x1.set$float$float(Math.fround(Math.fround(Math.fround(u * p1s[0].x) + Math.fround(v * p1s[1].x)) + Math.fround(w * p1s[2].x)), Math.fround(Math.fround(Math.fround(u * p1s[0].y) + Math.fround(v * p1s[1].y)) + Math.fround(w * p1s[2].y)));
                    x2.set$float$float(Math.fround(Math.fround(Math.fround(u * p2s[0].x) + Math.fround(v * p2s[1].x)) + Math.fround(w * p2s[2].x)), Math.fround(Math.fround(Math.fround(u * p2s[0].y) + Math.fround(v * p2s[1].y)) + Math.fround(w * p2s[2].y)));
                    return 3;
                }
                InPoints(w, points, pointCount) {
                    let k_tolerance = Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON);
                    for (let i = 0; i < pointCount; ++i) {
                        {
                            let v = points[i];
                            let dx = org.jbox2d.common.MathUtils.abs(Math.fround(w.x - v.x));
                            let dy = org.jbox2d.common.MathUtils.abs(Math.fround(w.y - v.y));
                            let mx = org.jbox2d.common.MathUtils.max$float$float(org.jbox2d.common.MathUtils.abs(w.x), org.jbox2d.common.MathUtils.abs(points[i].x));
                            let my = org.jbox2d.common.MathUtils.max$float$float(org.jbox2d.common.MathUtils.abs(w.y), org.jbox2d.common.MathUtils.abs(points[i].y));
                            if (dx < Math.fround(k_tolerance * (Math.fround(mx + 1.0))) && dy < Math.fround(k_tolerance * (Math.fround(my + 1.0)))) {
                                return true;
                            }
                        }
                        ;
                    }
                    return false;
                }
                /**
                 * Distance between any two objects that implement SupportsGeneric Note that
                 * x1 and x2 are passed so that they may store results - they must be
                 * instantiated before being passed, and the contents will be lost.
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Set to closest point on shape1 (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Set to closest point on shape2 (result parameter)
                 * @param {*} shape1
                 * Shape to test
                 * @param {org.jbox2d.common.XForm} xf1
                 * Transform of shape1
                 * @param {*} shape2
                 * Shape to test
                 * @param {org.jbox2d.common.XForm} xf2
                 * Transform of shape2
                 * @return {number} the distance
                 */
                DistanceGeneric(x1, x2, shape1, xf1, shape2, xf2) {
                    let pointCount = 0;
                    shape1.getFirstVertexToOut(xf1, x1);
                    shape2.getFirstVertexToOut(xf2, x2);
                    let vSqr = 0.0;
                    let maxIterations = 20;
                    for (let iter = 0; iter < maxIterations; ++iter) {
                        {
                            this.v.set$float$float(Math.fround(x2.x - x1.x), Math.fround(x2.y - x1.y));
                            shape1.support(this.w1, xf1, this.v);
                            this.vNeg.set$float$float(-this.v.x, -this.v.y);
                            shape2.support(this.w2, xf2, this.vNeg);
                            vSqr = org.jbox2d.common.Vec2.dot(this.v, this.v);
                            this.w.set$float$float(Math.fround(this.w2.x - this.w1.x), Math.fround(this.w2.y - this.w1.y));
                            let vw = org.jbox2d.common.Vec2.dot(this.v, this.w);
                            if (Math.fround(vSqr - vw) <= Math.fround(0.01 * vSqr) || this.InPoints(this.w, this.points, pointCount)) {
                                if (pointCount === 0) {
                                    x1.set$org_jbox2d_common_Vec2(this.w1);
                                    x2.set$org_jbox2d_common_Vec2(this.w2);
                                }
                                this.g_GJK_Iterations = iter;
                                return org.jbox2d.common.MathUtils.sqrt(vSqr);
                            }
                            switch ((pointCount)) {
                                case 0:
                                    this.p1s[0].set$org_jbox2d_common_Vec2(this.w1);
                                    this.p2s[0].set$org_jbox2d_common_Vec2(this.w2);
                                    this.points[0].set$org_jbox2d_common_Vec2(this.w);
                                    x1.set$org_jbox2d_common_Vec2(this.p1s[0]);
                                    x2.set$org_jbox2d_common_Vec2(this.p2s[0]);
                                    ++pointCount;
                                    break;
                                case 1:
                                    this.p1s[1].set$org_jbox2d_common_Vec2(this.w1);
                                    this.p2s[1].set$org_jbox2d_common_Vec2(this.w2);
                                    this.points[1].set$org_jbox2d_common_Vec2(this.w);
                                    pointCount = this.ProcessTwo(x1, x2, this.p1s, this.p2s, this.points);
                                    break;
                                case 2:
                                    this.p1s[2].set$org_jbox2d_common_Vec2(this.w1);
                                    this.p2s[2].set$org_jbox2d_common_Vec2(this.w2);
                                    this.points[2].set$org_jbox2d_common_Vec2(this.w);
                                    pointCount = this.ProcessThree(x1, x2, this.p1s, this.p2s, this.points);
                                    break;
                            }
                            if (pointCount === 3) {
                                this.g_GJK_Iterations = iter;
                                return 0.0;
                            }
                            let maxSqr = -3.4028235E38;
                            for (let i = 0; i < pointCount; ++i) {
                                {
                                    maxSqr = org.jbox2d.common.MathUtils.max$float$float(maxSqr, org.jbox2d.common.Vec2.dot(this.points[i], this.points[i]));
                                }
                                ;
                            }
                            if (pointCount === 3 || vSqr <= Math.fround(Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON) * maxSqr)) {
                                this.g_GJK_Iterations = iter;
                                let vx = Math.fround(x2.x - x1.x);
                                let vy = Math.fround(x2.y - x1.y);
                                vSqr = Math.fround(Math.fround(vx * vx) + Math.fround(vy * vy));
                                return org.jbox2d.common.MathUtils.sqrt(vSqr);
                            }
                        }
                        ;
                    }
                    this.g_GJK_Iterations = maxIterations;
                    return org.jbox2d.common.MathUtils.sqrt(vSqr);
                }
                /**
                 * distance between two circle shapes
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.CircleShape} circle1
                 * @param {org.jbox2d.common.XForm} xf1
                 * Transform of first shape
                 * @param {org.jbox2d.collision.shapes.CircleShape} circle2
                 * @param {org.jbox2d.common.XForm} xf2
                 * Transform of second shape
                 * @return {number} the distance
                 */
                DistanceCC(x1, x2, circle1, xf1, circle2, xf2) {
                    org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.distCCp1);
                    org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.distCCp2);
                    this.distCCd.x = Math.fround(this.distCCp2.x - this.distCCp1.x);
                    this.distCCd.y = Math.fround(this.distCCp2.y - this.distCCp1.y);
                    let dSqr = org.jbox2d.common.Vec2.dot(this.distCCd, this.distCCd);
                    let r1 = Math.fround(circle1.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
                    let r2 = Math.fround(circle2.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
                    let r = Math.fround(r1 + r2);
                    if (dSqr > Math.fround(r * r)) {
                        let dLen = this.distCCd.normalize();
                        let distance = Math.fround(dLen - r);
                        x1.set$float$float(Math.fround(this.distCCp1.x + Math.fround(r1 * this.distCCd.x)), Math.fround(this.distCCp1.y + Math.fround(r1 * this.distCCd.y)));
                        x2.set$float$float(Math.fround(this.distCCp2.x - Math.fround(r2 * this.distCCd.x)), Math.fround(this.distCCp2.y - Math.fround(r2 * this.distCCd.y)));
                        return distance;
                    }
                    else if (dSqr > Math.fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                        this.distCCd.normalize();
                        x1.set$float$float(Math.fround(this.distCCp1.x + Math.fround(r1 * this.distCCd.x)), Math.fround(this.distCCp1.y + Math.fround(r1 * this.distCCd.y)));
                        x2.set$org_jbox2d_common_Vec2(x1);
                        return 0.0;
                    }
                    x1.set$org_jbox2d_common_Vec2(this.distCCp1);
                    x2.set$org_jbox2d_common_Vec2(x1);
                    return 0.0;
                }
                /**
                 * Distance bewteen an edge and a circle
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.EdgeShape} edge
                 * @param {org.jbox2d.common.XForm} xf1
                 * xform of edge
                 * @param {org.jbox2d.collision.shapes.CircleShape} circle
                 * @param {org.jbox2d.common.XForm} xf2
                 * xform of circle
                 * @return {number} the distance
                 */
                DistanceEdgeCircle(x1, x2, edge, xf1, circle, xf2) {
                    let dSqr;
                    let dLen;
                    let r = Math.fround(circle.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
                    org.jbox2d.common.XForm.mulToOut(xf2, circle.getMemberLocalPosition(), this.cWorld);
                    org.jbox2d.common.XForm.mulTransToOut(xf1, this.cWorld, this.ECcLocal);
                    let dirDist = org.jbox2d.common.Vec2.dot(this.ECcLocal.sub(edge.getCoreVertex1()), edge.getDirectionVector());
                    if (dirDist <= 0.0) {
                        org.jbox2d.common.XForm.mulToOut(xf1, edge.getCoreVertex1(), this.ECvWorld);
                    }
                    else if (dirDist >= edge.getLength()) {
                        org.jbox2d.common.XForm.mulToOut(xf1, edge.getCoreVertex2(), this.ECvWorld);
                    }
                    else {
                        x1.set$org_jbox2d_common_Vec2(edge.getDirectionVector());
                        x1.mulLocal(dirDist).addLocal$org_jbox2d_common_Vec2(edge.getCoreVertex1());
                        org.jbox2d.common.XForm.mulToOut(xf1, x1, x1);
                        this.ECtemp.set$org_jbox2d_common_Vec2(this.ECcLocal);
                        this.ECtemp.subLocal(edge.getCoreVertex1());
                        dLen = org.jbox2d.common.Vec2.dot(this.ECtemp, edge.getNormalVector());
                        if (dLen < 0.0) {
                            if (dLen < -r) {
                                x2.set$org_jbox2d_common_Vec2(edge.getNormalVector());
                                x2.mulLocal(r).addLocal$org_jbox2d_common_Vec2(this.ECcLocal);
                                org.jbox2d.common.XForm.mulToOut(xf1, x2, x2);
                                return Math.fround(-dLen - r);
                            }
                            else {
                                x2.set$org_jbox2d_common_Vec2(x1);
                                return 0.0;
                            }
                        }
                        else {
                            if (dLen > r) {
                                x2.set$org_jbox2d_common_Vec2(edge.getNormalVector());
                                x2.mulLocal(r).subLocal(this.ECcLocal).negateLocal();
                                org.jbox2d.common.XForm.mulToOut(xf1, x2, x2);
                                return Math.fround(dLen - r);
                            }
                            else {
                                x2.set$org_jbox2d_common_Vec2(x1);
                                return 0.0;
                            }
                        }
                    }
                    x1.set$org_jbox2d_common_Vec2(this.ECvWorld);
                    this.ECd.set$org_jbox2d_common_Vec2(this.cWorld);
                    this.ECd.subLocal(this.ECvWorld);
                    dSqr = org.jbox2d.common.Vec2.dot(this.ECd, this.ECd);
                    if (dSqr > Math.fround(r * r)) {
                        dLen = this.ECd.normalize();
                        x2.set$org_jbox2d_common_Vec2(this.ECd);
                        x2.mulLocal(r).subLocal(this.cWorld).negateLocal();
                        return Math.fround(dLen - r);
                    }
                    else {
                        x2.set$org_jbox2d_common_Vec2(this.ECvWorld);
                        return 0.0;
                    }
                }
                /**
                 * Distance between a polygon and a circle
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
                 * @param {org.jbox2d.common.XForm} xf1
                 * xform of polygon
                 * @param {org.jbox2d.collision.shapes.CircleShape} circle
                 * @param {org.jbox2d.common.XForm} xf2
                 * xform of circle
                 * @return {number} the distance
                 */
                DistancePC(x1, x2, polygon, xf1, circle, xf2) {
                    this.point.p.set$float$float(Math.fround(Math.fround(xf2.position.x + Math.fround(xf2.R.col1.x * circle.m_localPosition.x)) + Math.fround(xf2.R.col2.x * circle.m_localPosition.y)), Math.fround(Math.fround(xf2.position.y + Math.fround(xf2.R.col1.y * circle.m_localPosition.x)) + Math.fround(xf2.R.col2.y * circle.m_localPosition.y)));
                    let distance = this.DistanceGeneric(x1, x2, polygon, xf1, this.point, org.jbox2d.common.XForm.identity_$LI$());
                    let r = Math.fround(circle.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
                    if (distance > r) {
                        distance -= r;
                        let dx = Math.fround(x2.x - x1.x);
                        let dy = Math.fround(x2.y - x1.y);
                        let length = org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy)));
                        if (length >= org.jbox2d.common.Settings.EPSILON) {
                            let invLength = Math.fround(1.0 / length);
                            dx *= invLength;
                            dy *= invLength;
                        }
                        x2.x -= Math.fround(r * dx);
                        x2.y -= Math.fround(r * dy);
                    }
                    else {
                        distance = 0.0;
                        x2.set$org_jbox2d_common_Vec2(x1);
                    }
                    return distance;
                }
                /**
                 * Distance between a polygon and a point
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
                 * @param {org.jbox2d.common.XForm} xf1
                 * xform of polygon
                 * @param {org.jbox2d.collision.shapes.PointShape} pt
                 * @param {org.jbox2d.common.XForm} xf2
                 * xform of point
                 * @return {number} the distance
                 */
                DistancePolygonPoint(x1, x2, polygon, xf1, pt, xf2) {
                    this.point.p.set$float$float(Math.fround(Math.fround(xf2.position.x + Math.fround(xf2.R.col1.x * pt.m_localPosition.x)) + Math.fround(xf2.R.col2.x * pt.m_localPosition.y)), Math.fround(Math.fround(xf2.position.y + Math.fround(xf2.R.col1.y * pt.m_localPosition.x)) + Math.fround(xf2.R.col2.y * pt.m_localPosition.y)));
                    let distance = this.DistanceGeneric(x1, x2, polygon, xf1, this.point, org.jbox2d.common.XForm.identity_$LI$());
                    let r = -org.jbox2d.common.Settings.toiSlop_$LI$();
                    if (distance > r) {
                        distance -= r;
                        let dx = Math.fround(x2.x - x1.x);
                        let dy = Math.fround(x2.y - x1.y);
                        let length = org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy)));
                        if (length >= org.jbox2d.common.Settings.EPSILON) {
                            let invLength = Math.fround(1.0 / length);
                            dx *= invLength;
                            dy *= invLength;
                        }
                        x2.x -= Math.fround(r * dx);
                        x2.y -= Math.fround(r * dy);
                    }
                    else {
                        distance = 0.0;
                        x2.set$org_jbox2d_common_Vec2(x1);
                    }
                    return distance;
                }
                /**
                 * Distance between a circle and a point
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.CircleShape} circle1
                 * @param {org.jbox2d.common.XForm} xf1
                 * xform of circle
                 * @param {org.jbox2d.collision.shapes.PointShape} pt2
                 * @param {org.jbox2d.common.XForm} xf2
                 * xform of point
                 * @return {number} the distance
                 */
                DistanceCirclePoint(x1, x2, circle1, xf1, pt2, xf2) {
                    org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.CPp1);
                    org.jbox2d.common.XForm.mulToOut(xf2, pt2.getMemberLocalPosition(), this.CPp2);
                    this.CPd.x = Math.fround(this.CPp2.x - this.CPp1.x);
                    this.CPd.y = Math.fround(this.CPp2.y - this.CPp1.y);
                    let dSqr = org.jbox2d.common.Vec2.dot(this.CPd, this.CPd);
                    let r1 = Math.fround(circle1.getRadius() - org.jbox2d.common.Settings.toiSlop_$LI$());
                    let r2 = -org.jbox2d.common.Settings.toiSlop_$LI$();
                    let r = Math.fround(r1 + r2);
                    if (dSqr > Math.fround(r * r)) {
                        let dLen = this.CPd.normalize();
                        let distance = Math.fround(dLen - r);
                        x1.set$float$float(Math.fround(this.CPp1.x + Math.fround(r1 * this.CPd.x)), Math.fround(this.CPp1.y + Math.fround(r1 * this.CPd.y)));
                        x2.set$float$float(Math.fround(this.CPp2.x - Math.fround(r2 * this.CPd.x)), Math.fround(this.CPp2.y - Math.fround(r2 * this.CPd.y)));
                        return distance;
                    }
                    else if (dSqr > Math.fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                        this.CPd.normalize();
                        x1.set$float$float(Math.fround(this.CPp1.x + Math.fround(r1 * this.CPd.x)), Math.fround(this.CPp1.y + Math.fround(r1 * this.CPd.y)));
                        x2.set$org_jbox2d_common_Vec2(x1);
                        return 0.0;
                    }
                    x1.set$org_jbox2d_common_Vec2(this.CPp1);
                    x2.set$org_jbox2d_common_Vec2(x1);
                    return 0.0;
                }
                /**
                 * Find the closest distance between shapes shape1 and shape2, and load the
                 * closest points into x1 and x2. Note that x1 and x2 are passed so that
                 * they may store results - they must be instantiated before being passed,
                 * and the contents will be lost.
                 *
                 * @param {org.jbox2d.common.Vec2} x1
                 * Closest point on shape1 is put here (result parameter)
                 * @param {org.jbox2d.common.Vec2} x2
                 * Closest point on shape2 is put here (result parameter)
                 * @param {org.jbox2d.collision.shapes.Shape} shape1
                 * First shape to test
                 * @param {org.jbox2d.common.XForm} xf1
                 * Transform of first shape
                 * @param {org.jbox2d.collision.shapes.Shape} shape2
                 * Second shape to test
                 * @param {org.jbox2d.common.XForm} xf2
                 * Transform of second shape
                 * @return {number} the distance
                 */
                distance(x1, x2, shape1, xf1, shape2, xf2) {
                    let type1 = shape1.getType();
                    let type2 = shape2.getType();
                    if (type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                        return this.DistanceCC(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                        return this.DistancePC(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                        return this.DistancePC(x2, x1, shape2, xf2, shape1, xf1);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                        return this.DistanceGeneric(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                        return this.DistanceEdgeCircle(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                        return this.DistanceEdgeCircle(x2, x1, shape2, xf2, shape1, xf1);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                        return this.DistanceGeneric(x2, x1, shape2, xf2, shape1, xf1);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                        return this.DistanceGeneric(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                        return 3.4028235E38;
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                        return this.DistanceCirclePoint(x2, x1, shape2, xf2, shape1, xf1);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                        return this.DistanceCirclePoint(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                        return this.DistancePolygonPoint(x2, x1, shape2, xf2, shape1, xf1);
                    }
                    else if (type1 === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE && type2 === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                        return this.DistancePolygonPoint(x1, x2, shape1, xf1, shape2, xf2);
                    }
                    return 0.0;
                }
            }
            collision.Distance = Distance;
            Distance["__class"] = "org.jbox2d.collision.Distance";
            class Point {
                constructor(_p) {
                    if (((_p != null && _p instanceof org.jbox2d.common.Vec2) || _p === null)) {
                        let __args = arguments;
                        if (this.p === undefined)
                            this.p = null;
                        if (this.p === undefined)
                            this.p = null;
                        (() => {
                            this.p = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_p);
                        })();
                    }
                    else if (_p === undefined) {
                        let __args = arguments;
                        if (this.p === undefined)
                            this.p = null;
                        if (this.p === undefined)
                            this.p = null;
                        (() => {
                            this.p = new org.jbox2d.common.Vec2();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                support(dest, xf, v) {
                    dest.set$org_jbox2d_common_Vec2(this.p);
                }
                getFirstVertexToOut(xf, out) {
                    out.set$org_jbox2d_common_Vec2(this.p);
                }
            }
            collision.Point = Point;
            Point["__class"] = "org.jbox2d.collision.Point";
            Point["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * This holds contact filtering data.
             * @class
             */
            class FilterData {
                constructor() {
                    if (this.categoryBits === undefined)
                        this.categoryBits = 0;
                    if (this.maskBits === undefined)
                        this.maskBits = 0;
                    if (this.groupIndex === undefined)
                        this.groupIndex = 0;
                }
                set(fd) {
                    this.categoryBits = fd.categoryBits;
                    this.maskBits = fd.maskBits;
                    this.groupIndex = fd.groupIndex;
                }
            }
            collision.FilterData = FilterData;
            FilterData["__class"] = "org.jbox2d.collision.FilterData";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Creates this manifold as a copy of the other
             * @param {org.jbox2d.collision.Manifold} other
             * @class
             */
            class Manifold {
                constructor(other) {
                    if (((other != null && other instanceof org.jbox2d.collision.Manifold) || other === null)) {
                        let __args = arguments;
                        if (this.points === undefined)
                            this.points = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.pointCount === undefined)
                            this.pointCount = 0;
                        if (this.points === undefined)
                            this.points = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.pointCount === undefined)
                            this.pointCount = 0;
                        (() => {
                            this.points = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                            this.normal = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(other.normal);
                            this.pointCount = other.pointCount;
                            for (let i = 0; i < other.points.length; i++) {
                                {
                                    this.points[i] = new org.jbox2d.collision.ManifoldPoint(other.points[i]);
                                }
                                ;
                            }
                        })();
                    }
                    else if (other === undefined) {
                        let __args = arguments;
                        if (this.points === undefined)
                            this.points = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.pointCount === undefined)
                            this.pointCount = 0;
                        if (this.points === undefined)
                            this.points = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.pointCount === undefined)
                            this.pointCount = 0;
                        (() => {
                            this.points = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                            for (let i = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                                {
                                    this.points[i] = new org.jbox2d.collision.ManifoldPoint();
                                }
                                ;
                            }
                            this.normal = new org.jbox2d.common.Vec2();
                            this.pointCount = 0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * copies this manifold from the given one
                 * @param {org.jbox2d.collision.Manifold} cp manifold to copy from
                 * @return {org.jbox2d.collision.Manifold}
                 */
                set(cp) {
                    for (let i = 0; i < cp.pointCount; i++) {
                        {
                            this.points[i].set(cp.points[i]);
                        }
                        ;
                    }
                    this.normal.set$org_jbox2d_common_Vec2(cp.normal);
                    this.pointCount = cp.pointCount;
                    return this;
                }
            }
            collision.Manifold = Manifold;
            Manifold["__class"] = "org.jbox2d.collision.Manifold";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Creates a manifold point as a copy of the given point
             * @param {org.jbox2d.collision.ManifoldPoint} cp point to copy from
             * @class
             */
            class ManifoldPoint {
                constructor(cp) {
                    if (((cp != null && cp instanceof org.jbox2d.collision.ManifoldPoint) || cp === null)) {
                        let __args = arguments;
                        if (this.localPoint1 === undefined)
                            this.localPoint1 = null;
                        if (this.localPoint2 === undefined)
                            this.localPoint2 = null;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.id === undefined)
                            this.id = null;
                        if (this.localPoint1 === undefined)
                            this.localPoint1 = null;
                        if (this.localPoint2 === undefined)
                            this.localPoint2 = null;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.id === undefined)
                            this.id = null;
                        (() => {
                            this.localPoint1 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(cp.localPoint1);
                            this.localPoint2 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(cp.localPoint2);
                            this.separation = cp.separation;
                            this.normalImpulse = cp.normalImpulse;
                            this.tangentImpulse = cp.tangentImpulse;
                            this.id = new org.jbox2d.collision.ContactID(cp.id);
                        })();
                    }
                    else if (cp === undefined) {
                        let __args = arguments;
                        if (this.localPoint1 === undefined)
                            this.localPoint1 = null;
                        if (this.localPoint2 === undefined)
                            this.localPoint2 = null;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.id === undefined)
                            this.id = null;
                        if (this.localPoint1 === undefined)
                            this.localPoint1 = null;
                        if (this.localPoint2 === undefined)
                            this.localPoint2 = null;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.id === undefined)
                            this.id = null;
                        (() => {
                            this.localPoint1 = new org.jbox2d.common.Vec2();
                            this.localPoint2 = new org.jbox2d.common.Vec2();
                            this.separation = this.normalImpulse = this.tangentImpulse = 0.0;
                            this.id = new org.jbox2d.collision.ContactID();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Sets this manifold point form the given one
                 * @param {org.jbox2d.collision.ManifoldPoint} cp the point to copy from
                 */
                set(cp) {
                    this.localPoint1.set$org_jbox2d_common_Vec2(cp.localPoint1);
                    this.localPoint2.set$org_jbox2d_common_Vec2(cp.localPoint2);
                    this.separation = cp.separation;
                    this.normalImpulse = cp.normalImpulse;
                    this.tangentImpulse = cp.tangentImpulse;
                    this.id.set(cp.id);
                }
            }
            collision.ManifoldPoint = ManifoldPoint;
            ManifoldPoint["__class"] = "org.jbox2d.collision.ManifoldPoint";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Copies from the given mass data
             * @param {org.jbox2d.collision.MassData} md mass data to copy from
             * @class
             */
            class MassData {
                constructor(md) {
                    if (((md != null && md instanceof org.jbox2d.collision.MassData) || md === null)) {
                        let __args = arguments;
                        if (this.mass === undefined)
                            this.mass = 0;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.I === undefined)
                            this.I = 0;
                        if (this.mass === undefined)
                            this.mass = 0;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.I === undefined)
                            this.I = 0;
                        (() => {
                            this.mass = md.mass;
                            this.I = md.I;
                            this.center = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(md.center);
                        })();
                    }
                    else if (md === undefined) {
                        let __args = arguments;
                        if (this.mass === undefined)
                            this.mass = 0;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.I === undefined)
                            this.I = 0;
                        if (this.mass === undefined)
                            this.mass = 0;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.I === undefined)
                            this.I = 0;
                        (() => {
                            this.mass = this.I = 0.0;
                            this.center = new org.jbox2d.common.Vec2();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                set(argOther) {
                    this.mass = argOther.mass;
                    this.center.set$org_jbox2d_common_Vec2(argOther.center);
                    this.I = argOther.I;
                    return this;
                }
                /**
                 * Return a copy of this object.
                 * @return {org.jbox2d.collision.MassData}
                 */
                clone() {
                    return new MassData(this);
                }
            }
            collision.MassData = MassData;
            MassData["__class"] = "org.jbox2d.collision.MassData";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * creates OBB with the given data.  The arguments are cloned
             * before being placed in the object
             * @param {org.jbox2d.common.Mat22} _R
             * @param {org.jbox2d.common.Vec2} _center
             * @param {org.jbox2d.common.Vec2} _extents
             * @class
             */
            class OBB {
                constructor(_R, _center, _extents) {
                    if (((_R != null && _R instanceof org.jbox2d.common.Mat22) || _R === null) && ((_center != null && _center instanceof org.jbox2d.common.Vec2) || _center === null) && ((_extents != null && _extents instanceof org.jbox2d.common.Vec2) || _extents === null)) {
                        let __args = arguments;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.extents === undefined)
                            this.extents = null;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.extents === undefined)
                            this.extents = null;
                        (() => {
                            this.R = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_R);
                            this.center = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_center);
                            this.extents = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_extents);
                        })();
                    }
                    else if (((_R != null && _R instanceof org.jbox2d.collision.OBB) || _R === null) && _center === undefined && _extents === undefined) {
                        let __args = arguments;
                        let copy = __args[0];
                        {
                            let __args = arguments;
                            let _R = copy.R;
                            let _center = copy.center;
                            let _extents = copy.extents;
                            if (this.R === undefined)
                                this.R = null;
                            if (this.center === undefined)
                                this.center = null;
                            if (this.extents === undefined)
                                this.extents = null;
                            if (this.R === undefined)
                                this.R = null;
                            if (this.center === undefined)
                                this.center = null;
                            if (this.extents === undefined)
                                this.extents = null;
                            (() => {
                                this.R = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(_R);
                                this.center = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(_center);
                                this.extents = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(_extents);
                            })();
                        }
                    }
                    else if (_R === undefined && _center === undefined && _extents === undefined) {
                        let __args = arguments;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.extents === undefined)
                            this.extents = null;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.extents === undefined)
                            this.extents = null;
                        (() => {
                            this.R = new org.jbox2d.common.Mat22();
                            this.center = new org.jbox2d.common.Vec2();
                            this.extents = new org.jbox2d.common.Vec2();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * @return {org.jbox2d.collision.OBB} a copy
                 */
                clone() {
                    return new OBB(this);
                }
            }
            collision.OBB = OBB;
            OBB["__class"] = "org.jbox2d.collision.OBB";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Copy constructor
             * @param {org.jbox2d.collision.Pair} other
             * @class
             */
            class Pair {
                constructor(other) {
                    if (((other != null && other instanceof org.jbox2d.collision.Pair) || other === null)) {
                        let __args = arguments;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.proxyId1 === undefined)
                            this.proxyId1 = 0;
                        if (this.proxyId2 === undefined)
                            this.proxyId2 = 0;
                        if (this.status === undefined)
                            this.status = 0;
                        if (this.next === undefined)
                            this.next = 0;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.proxyId1 === undefined)
                            this.proxyId1 = 0;
                        if (this.proxyId2 === undefined)
                            this.proxyId2 = 0;
                        if (this.status === undefined)
                            this.status = 0;
                        if (this.next === undefined)
                            this.next = 0;
                        (() => {
                            this.userData = other.userData;
                            this.proxyId1 = other.proxyId1;
                            this.proxyId2 = other.proxyId2;
                            this.status = other.status;
                        })();
                    }
                    else if (other === undefined) {
                        let __args = arguments;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.proxyId1 === undefined)
                            this.proxyId1 = 0;
                        if (this.proxyId2 === undefined)
                            this.proxyId2 = 0;
                        if (this.status === undefined)
                            this.status = 0;
                        if (this.next === undefined)
                            this.next = 0;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.proxyId1 === undefined)
                            this.proxyId1 = 0;
                        if (this.proxyId2 === undefined)
                            this.proxyId2 = 0;
                        if (this.status === undefined)
                            this.status = 0;
                        if (this.next === undefined)
                            this.next = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                setBuffered() {
                    this.status |= Pair.PAIR_BUFFERED;
                }
                clearBuffered() {
                    this.status &= ~Pair.PAIR_BUFFERED;
                }
                isBuffered() {
                    return (this.status & Pair.PAIR_BUFFERED) === Pair.PAIR_BUFFERED;
                }
                clearRemoved() {
                    this.status &= ~Pair.PAIR_REMOVED;
                }
                setRemoved() {
                    this.status |= Pair.PAIR_REMOVED;
                }
                isRemoved() {
                    return (this.status & Pair.PAIR_REMOVED) === Pair.PAIR_REMOVED;
                }
                setFinal() {
                    this.status |= Pair.PAIR_FINAL;
                }
                isFinal() {
                    return (this.status & Pair.PAIR_FINAL) === Pair.PAIR_FINAL;
                }
                compareTo(p) {
                    return this.proxyId1 - p.proxyId1;
                }
            }
            Pair.PAIR_BUFFERED = 1;
            Pair.PAIR_REMOVED = 2;
            Pair.PAIR_FINAL = 4;
            collision.Pair = Pair;
            Pair["__class"] = "org.jbox2d.collision.Pair";
            Pair["__interfaces"] = ["java.lang.Comparable"];
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            class Proxy {
                constructor() {
                    if (this.lowerBounds === undefined)
                        this.lowerBounds = null;
                    if (this.upperBounds === undefined)
                        this.upperBounds = null;
                    if (this.overlapCount === undefined)
                        this.overlapCount = 0;
                    if (this.timeStamp === undefined)
                        this.timeStamp = 0;
                    if (this.categoryBits === undefined)
                        this.categoryBits = 0;
                    if (this.maskBits === undefined)
                        this.maskBits = 0;
                    if (this.groupIndex === undefined)
                        this.groupIndex = 0;
                    if (this.userData === undefined)
                        this.userData = null;
                    this.lowerBounds = [0, 0];
                    this.upperBounds = [0, 0];
                    this.lowerBounds[0] = this.lowerBounds[1] = 0;
                    this.upperBounds[0] = this.upperBounds[1] = 0;
                    this.overlapCount = org.jbox2d.collision.BroadPhase.INVALID_$LI$();
                    this.timeStamp = 0;
                }
                getNext() {
                    return this.lowerBounds[0];
                }
                setNext(next) {
                    this.lowerBounds[0] = next;
                }
                isValid() {
                    return this.overlapCount !== org.jbox2d.collision.BroadPhase.INVALID_$LI$();
                }
            }
            collision.Proxy = Proxy;
            Proxy["__class"] = "org.jbox2d.collision.Proxy";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var SegmentCollide;
            (function (SegmentCollide) {
                SegmentCollide[SegmentCollide["STARTS_INSIDE_COLLIDE"] = 0] = "STARTS_INSIDE_COLLIDE";
                SegmentCollide[SegmentCollide["MISS_COLLIDE"] = 1] = "MISS_COLLIDE";
                SegmentCollide[SegmentCollide["HIT_COLLIDE"] = 2] = "HIT_COLLIDE";
            })(SegmentCollide = collision.SegmentCollide || (collision.SegmentCollide = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Circle/circle and circle/polygon overlap solver -
                 * for internal use only.
                 * @class
                 */
                class CollideCircle {
                    constructor() {
                        /*private*/ this.colCCP1 = new org.jbox2d.common.Vec2();
                        /*private*/ this.colCCP2 = new org.jbox2d.common.Vec2();
                        /*private*/ this.colCCD = new org.jbox2d.common.Vec2();
                        /*private*/ this.colCCP = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPCP1 = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPCP2 = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPCD = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPCP = new org.jbox2d.common.Vec2();
                        /*private*/ this.ECd = new org.jbox2d.common.Vec2();
                        /*private*/ this.ECc = new org.jbox2d.common.Vec2();
                        /*private*/ this.ECcLocal = new org.jbox2d.common.Vec2();
                    }
                    /**
                     * puts collision information of the two circles in the manifold
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.CircleShape} circle1
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.CircleShape} circle2
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collideCircles(manifold, circle1, xf1, circle2, xf2) {
                        manifold.pointCount = 0;
                        org.jbox2d.common.XForm.mulToOut(xf1, circle1.getMemberLocalPosition(), this.colCCP1);
                        org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.colCCP2);
                        this.colCCD.x = Math.fround(this.colCCP2.x - this.colCCP1.x);
                        this.colCCD.y = Math.fround(this.colCCP2.y - this.colCCP1.y);
                        let distSqr = org.jbox2d.common.Vec2.dot(this.colCCD, this.colCCD);
                        let r1 = circle1.getRadius();
                        let r2 = circle2.getRadius();
                        let radiusSum = Math.fround(r1 + r2);
                        if (distSqr > Math.fround(radiusSum * radiusSum)) {
                            return;
                        }
                        let separation;
                        if (distSqr < org.jbox2d.common.Settings.EPSILON) {
                            separation = -radiusSum;
                            manifold.normal.set$float$float(0.0, 1.0);
                        }
                        else {
                            let dist = org.jbox2d.common.MathUtils.sqrt(distSqr);
                            separation = Math.fround(dist - radiusSum);
                            let a = Math.fround(1.0 / dist);
                            manifold.normal.x = Math.fround(a * this.colCCD.x);
                            manifold.normal.y = Math.fround(a * this.colCCD.y);
                        }
                        manifold.pointCount = 1;
                        manifold.points[0].id.zero();
                        manifold.points[0].separation = separation;
                        this.colCCP1.addLocal$org_jbox2d_common_Vec2(manifold.normal.mul(r1));
                        this.colCCP2.subLocal(manifold.normal.mul(r2));
                        this.colCCP.x = Math.fround(0.5 * (Math.fround(this.colCCP1.x + this.colCCP2.x)));
                        this.colCCP.y = Math.fround(0.5 * (Math.fround(this.colCCP1.y + this.colCCP2.y)));
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.colCCP, manifold.points[0].localPoint1);
                        org.jbox2d.common.XForm.mulTransToOut(xf2, this.colCCP, manifold.points[0].localPoint2);
                    }
                    /**
                     * Puts collision information in the manifold about a collision between a point and a circle
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.PointShape} point1
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.CircleShape} circle2
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collidePointAndCircle(manifold, point1, xf1, circle2, xf2) {
                        manifold.pointCount = 0;
                        org.jbox2d.common.XForm.mulToOut(xf1, point1.getMemberLocalPosition(), this.colPCP1);
                        org.jbox2d.common.XForm.mulToOut(xf2, circle2.getMemberLocalPosition(), this.colPCP2);
                        this.colPCD.x = Math.fround(this.colPCP2.x - this.colPCP1.x);
                        this.colPCD.y = Math.fround(this.colPCP2.y - this.colPCP1.y);
                        let distSqr = org.jbox2d.common.Vec2.dot(this.colPCD, this.colPCD);
                        let r2 = circle2.getRadius();
                        if (distSqr > Math.fround(r2 * r2)) {
                            return;
                        }
                        let separation;
                        if (distSqr < org.jbox2d.common.Settings.EPSILON) {
                            separation = -r2;
                            manifold.normal.set$float$float(0.0, 1.0);
                        }
                        else {
                            let dist = org.jbox2d.common.MathUtils.sqrt(distSqr);
                            separation = Math.fround(dist - r2);
                            let a = Math.fround(1.0 / dist);
                            manifold.normal.x = Math.fround(a * this.colPCD.x);
                            manifold.normal.y = Math.fround(a * this.colPCD.y);
                        }
                        manifold.pointCount = 1;
                        manifold.points[0].id.zero();
                        manifold.points[0].separation = separation;
                        this.colPCP2.subLocal(manifold.normal.mul(r2));
                        this.colPCP.x = Math.fround(0.5 * (Math.fround(this.colPCP1.x + this.colPCP2.x)));
                        this.colPCP.y = Math.fround(0.5 * (Math.fround(this.colPCP1.y + this.colPCP2.y)));
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.colPCP, manifold.points[0].localPoint1);
                        org.jbox2d.common.XForm.mulTransToOut(xf2, this.colPCP, manifold.points[0].localPoint2);
                    }
                    /**
                     * puts collision information about the collision of a polygon and a circle
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.CircleShape} circle
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collidePolygonAndCircle(manifold, polygon, xf1, circle, xf2) {
                        manifold.pointCount = 0;
                        let cx = Math.fround(Math.fround(xf2.position.x + Math.fround(xf2.R.col1.x * circle.m_localPosition.x)) + Math.fround(xf2.R.col2.x * circle.m_localPosition.y));
                        let cy = Math.fround(Math.fround(xf2.position.y + Math.fround(xf2.R.col1.y * circle.m_localPosition.x)) + Math.fround(xf2.R.col2.y * circle.m_localPosition.y));
                        let v1x = Math.fround(cx - xf1.position.x);
                        let v1y = Math.fround(cy - xf1.position.y);
                        let cLocalx = Math.fround(Math.fround(v1x * xf1.R.col1.x) + Math.fround(v1y * xf1.R.col1.y));
                        let cLocaly = Math.fround(Math.fround(v1x * xf1.R.col2.x) + Math.fround(v1y * xf1.R.col2.y));
                        let normalIndex = 0;
                        let separation = -3.4028235E38;
                        let radius = circle.getRadius();
                        let vertexCount = polygon.getVertexCount();
                        let vertices = polygon.getVertices();
                        let normals = polygon.getNormals();
                        for (let i = 0; i < vertexCount; ++i) {
                            {
                                let s = Math.fround(Math.fround(normals[i].x * (Math.fround(cLocalx - vertices[i].x))) + Math.fround(normals[i].y * (Math.fround(cLocaly - vertices[i].y))));
                                if (s > circle.m_radius) {
                                    return;
                                }
                                if (s > separation) {
                                    normalIndex = i;
                                    separation = s;
                                }
                            }
                            ;
                        }
                        if (separation < org.jbox2d.common.Settings.EPSILON) {
                            manifold.pointCount = 1;
                            manifold.normal.x = Math.fround(Math.fround(xf1.R.col1.x * normals[normalIndex].x) + Math.fround(xf1.R.col2.x * normals[normalIndex].y));
                            manifold.normal.y = Math.fround(Math.fround(xf1.R.col1.y * normals[normalIndex].x) + Math.fround(xf1.R.col2.y * normals[normalIndex].y));
                            manifold.points[0].id.features.incidentEdge = normalIndex;
                            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.referenceEdge = 0;
                            manifold.points[0].id.features.flip = 0;
                            let positionx = Math.fround(cx - Math.fround(manifold.normal.x * radius));
                            let positiony = Math.fround(cy - Math.fround(manifold.normal.y * radius));
                            let v1x1 = Math.fround(positionx - xf1.position.x);
                            let v1y1 = Math.fround(positiony - xf1.position.y);
                            manifold.points[0].localPoint1.x = (Math.fround(Math.fround(v1x1 * xf1.R.col1.x) + Math.fround(v1y1 * xf1.R.col1.y)));
                            manifold.points[0].localPoint1.y = (Math.fround(Math.fround(v1x1 * xf1.R.col2.x) + Math.fround(v1y1 * xf1.R.col2.y)));
                            let v1x2 = Math.fround(positionx - xf2.position.x);
                            let v1y2 = Math.fround(positiony - xf2.position.y);
                            manifold.points[0].localPoint2.x = (Math.fround(Math.fround(v1x2 * xf2.R.col1.x) + Math.fround(v1y2 * xf2.R.col1.y)));
                            manifold.points[0].localPoint2.y = (Math.fround(Math.fround(v1x2 * xf2.R.col2.x) + Math.fround(v1y2 * xf2.R.col2.y)));
                            manifold.points[0].separation = Math.fround(separation - radius);
                            return;
                        }
                        let vertIndex1 = normalIndex;
                        let vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
                        let ex = Math.fround(vertices[vertIndex2].x - vertices[vertIndex1].x);
                        let ey = Math.fround(vertices[vertIndex2].y - vertices[vertIndex1].y);
                        let length = org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(ex * ex) + Math.fround(ey * ey)));
                        let invLength = Math.fround(1.0 / length);
                        ex *= invLength;
                        ey *= invLength;
                        let u = Math.fround(Math.fround((Math.fround(cLocalx - vertices[vertIndex1].x)) * ex) + Math.fround((Math.fround(cLocaly - vertices[vertIndex1].y)) * ey));
                        let px;
                        let py;
                        if (u <= 0.0) {
                            px = vertices[vertIndex1].x;
                            py = vertices[vertIndex1].y;
                            manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.incidentVertex = vertIndex1;
                        }
                        else if (u >= length) {
                            px = vertices[vertIndex2].x;
                            py = vertices[vertIndex2].y;
                            manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.incidentVertex = vertIndex2;
                        }
                        else {
                            px = vertices[vertIndex1].x;
                            py = vertices[vertIndex1].y;
                            px += Math.fround(u * ex);
                            py += Math.fround(u * ey);
                            manifold.points[0].id.features.incidentEdge = normalIndex;
                            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                        }
                        let dx = Math.fround(cLocalx - px);
                        let dy = Math.fround(cLocaly - py);
                        let dist = org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy)));
                        if (dist > radius) {
                            return;
                        }
                        if (dist >= org.jbox2d.common.Settings.EPSILON) {
                            let invDist = Math.fround(1.0 / dist);
                            dx *= invDist;
                            dy *= invDist;
                        }
                        manifold.pointCount = 1;
                        manifold.normal.x = Math.fround(Math.fround(xf1.R.col1.x * dx) + Math.fround(xf1.R.col2.x * dy));
                        manifold.normal.y = Math.fround(Math.fround(xf1.R.col1.y * dx) + Math.fround(xf1.R.col2.y * dy));
                        let positionx = Math.fround(cx - Math.fround(manifold.normal.x * radius));
                        let positiony = Math.fround(cy - Math.fround(manifold.normal.y * radius));
                        let v1x1 = Math.fround(positionx - xf1.position.x);
                        let v1y1 = Math.fround(positiony - xf1.position.y);
                        manifold.points[0].localPoint1.x = (Math.fround(Math.fround(v1x1 * xf1.R.col1.x) + Math.fround(v1y1 * xf1.R.col1.y)));
                        manifold.points[0].localPoint1.y = (Math.fround(Math.fround(v1x1 * xf1.R.col2.x) + Math.fround(v1y1 * xf1.R.col2.y)));
                        let v1x2 = Math.fround(positionx - xf2.position.x);
                        let v1y2 = Math.fround(positiony - xf2.position.y);
                        manifold.points[0].localPoint2.x = (Math.fround(Math.fround(v1x2 * xf2.R.col1.x) + Math.fround(v1y2 * xf2.R.col1.y)));
                        manifold.points[0].localPoint2.y = (Math.fround(Math.fround(v1x2 * xf2.R.col2.x) + Math.fround(v1y2 * xf2.R.col2.y)));
                        manifold.points[0].separation = Math.fround(dist - radius);
                        manifold.points[0].id.features.referenceEdge = 0;
                        manifold.points[0].id.features.flip = 0;
                    }
                    /**
                     * puts collision information into the manifold from a circle and edge collision
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.EdgeShape} edge
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.CircleShape} circle
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collideEdgeAndCircle(manifold, edge, xf1, circle, xf2) {
                        manifold.pointCount = 0;
                        org.jbox2d.common.XForm.mulToOut(xf2, circle.getMemberLocalPosition(), this.ECc);
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, this.ECcLocal);
                        let n = edge.getNormalVector();
                        let v1 = edge.getVertex1();
                        let v2 = edge.getVertex2();
                        let radius = circle.getRadius();
                        let separation;
                        this.ECd.set$org_jbox2d_common_Vec2(this.ECcLocal);
                        this.ECd.subLocal(v1);
                        let dirDist = org.jbox2d.common.Vec2.dot(this.ECd, edge.getDirectionVector());
                        if (dirDist <= 0) {
                            if (org.jbox2d.common.Vec2.dot(this.ECd, edge.getCorner1Vector()) < 0) {
                                return;
                            }
                            org.jbox2d.common.XForm.mulToOut(xf1, v1, this.ECd);
                            this.ECd.subLocal(this.ECc);
                            this.ECd.negateLocal();
                        }
                        else if (dirDist >= edge.getLength()) {
                            this.ECd.set$org_jbox2d_common_Vec2(this.ECcLocal);
                            this.ECd.subLocal(v2);
                            if (org.jbox2d.common.Vec2.dot(this.ECd, edge.getCorner2Vector()) > 0) {
                                return;
                            }
                            org.jbox2d.common.XForm.mulToOut(xf1, v2, this.ECd);
                            this.ECd.subLocal(this.ECc);
                            this.ECd.negateLocal();
                        }
                        else {
                            separation = org.jbox2d.common.Vec2.dot(this.ECd, n);
                            if (separation > radius || separation < -radius) {
                                return;
                            }
                            separation -= radius;
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, n, manifold.normal);
                            manifold.pointCount = 1;
                            manifold.points[0].id.zero();
                            manifold.points[0].separation = separation;
                            this.ECd.set$org_jbox2d_common_Vec2(manifold.normal);
                            this.ECd.mulLocal(radius);
                            this.ECc.subLocal(this.ECd);
                            org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, manifold.points[0].localPoint1);
                            org.jbox2d.common.XForm.mulTransToOut(xf2, this.ECc, manifold.points[0].localPoint2);
                            return;
                        }
                        let distSqr = org.jbox2d.common.Vec2.dot(this.ECd, this.ECd);
                        if (distSqr > Math.fround(radius * radius)) {
                            return;
                        }
                        if (distSqr < org.jbox2d.common.Settings.EPSILON) {
                            separation = -radius;
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, n, manifold.normal);
                        }
                        else {
                            separation = Math.fround(this.ECd.normalize() - radius);
                            manifold.normal.set$org_jbox2d_common_Vec2(this.ECd);
                        }
                        manifold.pointCount = 1;
                        manifold.points[0].id.zero();
                        manifold.points[0].separation = separation;
                        this.ECd.set$org_jbox2d_common_Vec2(manifold.normal);
                        this.ECd.mulLocal(radius);
                        this.ECc.subLocal(this.ECd);
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.ECc, manifold.points[0].localPoint1);
                        org.jbox2d.common.XForm.mulTransToOut(xf2, this.ECc, manifold.points[0].localPoint2);
                    }
                }
                shapes.CollideCircle = CollideCircle;
                CollideCircle["__class"] = "org.jbox2d.collision.shapes.CollideCircle";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Polygon overlap solver - for internal use.
                 * @class
                 */
                class CollidePoly {
                    constructor() {
                        /*private*/ this.normal1World = new org.jbox2d.common.Vec2();
                        /*private*/ this.dLocal1 = new org.jbox2d.common.Vec2();
                        /*private*/ this.mulTemp = new org.jbox2d.common.Vec2();
                        /*private*/ this.normal1 = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPc = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPcLocal = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPsub = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPe = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPp = new org.jbox2d.common.Vec2();
                        /*private*/ this.colPPd = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEv1 = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEv2 = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEn = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEv1Local = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEv2Local = new org.jbox2d.common.Vec2();
                        /*private*/ this.PEnLocal = new org.jbox2d.common.Vec2();
                        /*private*/ this.temp = new org.jbox2d.common.Vec2();
                        /*private*/ this.temp2 = new org.jbox2d.common.Vec2();
                        /*private*/ this.sideNormal = new org.jbox2d.common.Vec2();
                        /*private*/ this.frontNormal = new org.jbox2d.common.Vec2();
                        /*private*/ this.p_xf1 = new org.jbox2d.common.XForm();
                        /*private*/ this.p_xf2 = new org.jbox2d.common.XForm();
                    }
                    clipSegmentToLine(vOut, vIn, normal, offset) {
                        let numOut = 0;
                        let distance0 = Math.fround(org.jbox2d.common.Vec2.dot(normal, vIn[0].v) - offset);
                        let distance1 = Math.fround(org.jbox2d.common.Vec2.dot(normal, vIn[1].v) - offset);
                        if (distance0 <= 0.0) {
                            vOut[numOut] = new CollidePoly.ClipVertex();
                            vOut[numOut].id.set(vIn[0].id);
                            vOut[numOut++].v.set$org_jbox2d_common_Vec2(vIn[0].v);
                        }
                        if (distance1 <= 0.0) {
                            vOut[numOut] = new CollidePoly.ClipVertex();
                            vOut[numOut].id.set(vIn[1].id);
                            vOut[numOut++].v.set$org_jbox2d_common_Vec2(vIn[1].v);
                        }
                        if (Math.fround(distance0 * distance1) < 0.0) {
                            let interp = Math.fround(distance0 / (Math.fround(distance0 - distance1)));
                            vOut[numOut] = new CollidePoly.ClipVertex();
                            vOut[numOut].v.x = Math.fround(vIn[0].v.x + Math.fround(interp * (Math.fround(vIn[1].v.x - vIn[0].v.x))));
                            vOut[numOut].v.y = Math.fround(vIn[0].v.y + Math.fround(interp * (Math.fround(vIn[1].v.y - vIn[0].v.y))));
                            if (distance0 > 0.0) {
                                vOut[numOut].id.set(vIn[0].id);
                            }
                            else {
                                vOut[numOut].id.set(vIn[1].id);
                            }
                            ++numOut;
                        }
                        return numOut;
                    }
                    edgeSeparation(poly1, xf1, edge1, poly2, xf2) {
                        let count1 = poly1.getVertexCount();
                        let vertices1 = poly1.getVertices();
                        let normals1 = poly1.getNormals();
                        let count2 = poly2.getVertexCount();
                        let vertices2 = poly2.getVertices();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals1[edge1], this.normal1World);
                        let normal1x = org.jbox2d.common.Vec2.dot(this.normal1World, xf2.R.col1);
                        let normal1y = org.jbox2d.common.Vec2.dot(this.normal1World, xf2.R.col2);
                        let index = 0;
                        let minDot = 3.4028235E38;
                        for (let i = 0; i < count2; ++i) {
                            {
                                let dot = Math.fround(Math.fround(vertices2[i].x * normal1x) + Math.fround(vertices2[i].y * normal1y));
                                if (dot < minDot) {
                                    minDot = dot;
                                    index = i;
                                }
                            }
                            ;
                        }
                        let v = vertices1[edge1];
                        let v1x = Math.fround(Math.fround(xf1.position.x + Math.fround(xf1.R.col1.x * v.x)) + Math.fround(xf1.R.col2.x * v.y));
                        let v1y = Math.fround(Math.fround(xf1.position.y + Math.fround(xf1.R.col1.y * v.x)) + Math.fround(xf1.R.col2.y * v.y));
                        let v3 = vertices2[index];
                        let v2x = Math.fround(Math.fround(xf2.position.x + Math.fround(xf2.R.col1.x * v3.x)) + Math.fround(xf2.R.col2.x * v3.y));
                        let v2y = Math.fround(Math.fround(xf2.position.y + Math.fround(xf2.R.col1.y * v3.x)) + Math.fround(xf2.R.col2.y * v3.y));
                        let separation = Math.fround(Math.fround((Math.fround(v2x - v1x)) * this.normal1World.x) + Math.fround((Math.fround(v2y - v1y)) * this.normal1World.y));
                        return separation;
                    }
                    /**
                     * Find the max separation between poly1 and poly2 using face normals
                     * from poly1.
                     * @param {org.jbox2d.collision.shapes.PolygonShape} poly1
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.PolygonShape} poly2
                     * @param {org.jbox2d.common.XForm} xf2
                     * @return
                     * @return {org.jbox2d.collision.shapes.MaxSeparation}
                     */
                    findMaxSeparation(poly1, xf1, poly2, xf2) {
                        let separation = new org.jbox2d.collision.shapes.MaxSeparation();
                        let count1 = poly1.getVertexCount();
                        let normals1 = poly1.getNormals();
                        let v = poly1.getCentroid();
                        let v1 = poly2.getCentroid();
                        let dx = Math.fround(Math.fround(Math.fround(xf2.position.x + Math.fround(xf2.R.col1.x * v1.x)) + Math.fround(xf2.R.col2.x * v1.y)) - (Math.fround(Math.fround(xf1.position.x + Math.fround(xf1.R.col1.x * v.x)) + Math.fround(xf1.R.col2.x * v.y))));
                        let dy = Math.fround(Math.fround(Math.fround(xf2.position.y + Math.fround(xf2.R.col1.y * v1.x)) + Math.fround(xf2.R.col2.y * v1.y)) - (Math.fround(Math.fround(xf1.position.y + Math.fround(xf1.R.col1.y * v.x)) + Math.fround(xf1.R.col2.y * v.y))));
                        let b = xf1.R.col1;
                        let b1 = xf1.R.col2;
                        this.dLocal1.x = (Math.fround(Math.fround(dx * b.x) + Math.fround(dy * b.y)));
                        this.dLocal1.y = (Math.fround(Math.fround(dx * b1.x) + Math.fround(dy * b1.y)));
                        let edge = 0;
                        let maxDot = -3.4028235E38;
                        for (let i = 0; i < count1; ++i) {
                            {
                                let dot = org.jbox2d.common.Vec2.dot(normals1[i], this.dLocal1);
                                if (dot > maxDot) {
                                    maxDot = dot;
                                    edge = i;
                                }
                            }
                            ;
                        }
                        let s = this.edgeSeparation(poly1, xf1, edge, poly2, xf2);
                        if (s > 0.0) {
                            separation.bestSeparation = s;
                            return separation;
                        }
                        let prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
                        let sPrev = this.edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
                        if (sPrev > 0.0) {
                            separation.bestSeparation = sPrev;
                            return separation;
                        }
                        let nextEdge = edge + 1 < count1 ? edge + 1 : 0;
                        let sNext = this.edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
                        if (sNext > 0.0) {
                            separation.bestSeparation = sNext;
                            return separation;
                        }
                        let bestEdge;
                        let bestSeparation;
                        let increment;
                        if (sPrev > s && sPrev > sNext) {
                            increment = -1;
                            bestEdge = prevEdge;
                            bestSeparation = sPrev;
                        }
                        else if (sNext > s) {
                            increment = 1;
                            bestEdge = nextEdge;
                            bestSeparation = sNext;
                        }
                        else {
                            separation.bestFaceIndex = edge;
                            separation.bestSeparation = s;
                            return separation;
                        }
                        while ((true)) {
                            {
                                if (increment === -1) {
                                    edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
                                }
                                else {
                                    edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;
                                }
                                s = this.edgeSeparation(poly1, xf1, edge, poly2, xf2);
                                if (s > 0.0) {
                                    separation.bestSeparation = s;
                                    return separation;
                                }
                                if (s > bestSeparation) {
                                    bestEdge = edge;
                                    bestSeparation = s;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                        ;
                        separation.bestFaceIndex = bestEdge;
                        separation.bestSeparation = bestSeparation;
                        return separation;
                    }
                    findIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
                        let count1 = poly1.getVertexCount();
                        let normals1 = poly1.getNormals();
                        let count2 = poly2.getVertexCount();
                        let vertices2 = poly2.getVertices();
                        let normals2 = poly2.getNormals();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals1[edge1], this.mulTemp);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, this.mulTemp, this.normal1);
                        let index = 0;
                        let minDot = 3.4028235E38;
                        for (let i = 0; i < count2; ++i) {
                            {
                                let dot = org.jbox2d.common.Vec2.dot(this.normal1, normals2[i]);
                                if (dot < minDot) {
                                    minDot = dot;
                                    index = i;
                                }
                            }
                            ;
                        }
                        let i1 = index;
                        let i2 = i1 + 1 < count2 ? i1 + 1 : 0;
                        c[0] = new CollidePoly.ClipVertex();
                        c[1] = new CollidePoly.ClipVertex();
                        org.jbox2d.common.XForm.mulToOut(xf2, vertices2[i1], c[0].v);
                        c[0].id.features.referenceEdge = edge1;
                        c[0].id.features.incidentEdge = i1;
                        c[0].id.features.incidentVertex = 0;
                        org.jbox2d.common.XForm.mulToOut(xf2, vertices2[i2], c[1].v);
                        c[1].id.features.referenceEdge = edge1;
                        c[1].id.features.incidentEdge = i2;
                        c[1].id.features.incidentVertex = 1;
                    }
                    collidePolygons(manif, polyA, xfA, polyB, xfB) {
                        manif.pointCount = 0;
                        let sepA = this.findMaxSeparation(polyA, xfA, polyB, xfB);
                        if (sepA.bestSeparation > 0.0) {
                            return;
                        }
                        let sepB = this.findMaxSeparation(polyB, xfB, polyA, xfA);
                        if (sepB.bestSeparation > 0.0) {
                            return;
                        }
                        let poly1;
                        let poly2;
                        let xf1 = this.p_xf1;
                        let xf2 = this.p_xf2;
                        let edge1;
                        let flip;
                        let k_relativeTol = 0.98;
                        let k_absoluteTol = 0.001;
                        if (sepB.bestSeparation > Math.fround(Math.fround(k_relativeTol * sepA.bestSeparation) + k_absoluteTol)) {
                            poly1 = polyB;
                            poly2 = polyA;
                            xf1.set(xfB);
                            xf2.set(xfA);
                            edge1 = sepB.bestFaceIndex;
                            flip = 1;
                        }
                        else {
                            poly1 = polyA;
                            poly2 = polyB;
                            xf1.set(xfA);
                            xf2.set(xfB);
                            edge1 = sepA.bestFaceIndex;
                            flip = 0;
                        }
                        let incidentEdge = [null, null];
                        this.findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
                        let count1 = poly1.getVertexCount();
                        let vertices1 = poly1.getVertices();
                        let v11 = vertices1[edge1];
                        let v12 = edge1 + 1 < count1 ? vertices1[edge1 + 1] : vertices1[0];
                        let v1x = Math.fround(v12.x - v11.x);
                        let v1y = Math.fround(v12.y - v11.y);
                        this.sideNormal.set$float$float(Math.fround(Math.fround(xf1.R.col1.x * v1x) + Math.fround(xf1.R.col2.x * v1y)), Math.fround(Math.fround(xf1.R.col1.y * v1x) + Math.fround(xf1.R.col2.y * v1y)));
                        this.sideNormal.normalize();
                        this.frontNormal.set$float$float(this.sideNormal.y, -this.sideNormal.x);
                        let v11x = Math.fround(Math.fround(xf1.position.x + Math.fround(xf1.R.col1.x * v11.x)) + Math.fround(xf1.R.col2.x * v11.y));
                        let v11y = Math.fround(Math.fround(xf1.position.y + Math.fround(xf1.R.col1.y * v11.x)) + Math.fround(xf1.R.col2.y * v11.y));
                        let v12x = Math.fround(Math.fround(xf1.position.x + Math.fround(xf1.R.col1.x * v12.x)) + Math.fround(xf1.R.col2.x * v12.y));
                        let v12y = Math.fround(Math.fround(xf1.position.y + Math.fround(xf1.R.col1.y * v12.x)) + Math.fround(xf1.R.col2.y * v12.y));
                        let frontOffset = Math.fround(Math.fround(this.frontNormal.x * v11x) + Math.fround(this.frontNormal.y * v11y));
                        let sideOffset1 = -(Math.fround(Math.fround(this.sideNormal.x * v11x) + Math.fround(this.sideNormal.y * v11y)));
                        let sideOffset2 = Math.fround(Math.fround(this.sideNormal.x * v12x) + Math.fround(this.sideNormal.y * v12y));
                        let clipPoints1 = [null, null];
                        let clipPoints2 = [null, null];
                        let np;
                        np = this.clipSegmentToLine(clipPoints1, incidentEdge, this.sideNormal.negate(), sideOffset1);
                        if (np < 2) {
                            return;
                        }
                        np = this.clipSegmentToLine(clipPoints2, clipPoints1, this.sideNormal, sideOffset2);
                        if (np < 2) {
                            return;
                        }
                        manif.normal.set$org_jbox2d_common_Vec2(this.frontNormal);
                        if (flip !== 0) {
                            manif.normal.negateLocal();
                        }
                        let pointCount = 0;
                        for (let i = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; ++i) {
                            {
                                let separation = Math.fround(org.jbox2d.common.Vec2.dot(this.frontNormal, clipPoints2[i].v) - frontOffset);
                                if (separation <= 0.0) {
                                    let cp = manif.points[pointCount];
                                    cp.separation = separation;
                                    let vec = clipPoints2[i].v;
                                    let u1x = Math.fround(vec.x - xfA.position.x);
                                    let u1y = Math.fround(vec.y - xfA.position.y);
                                    cp.localPoint1.x = (Math.fround(Math.fround(u1x * xfA.R.col1.x) + Math.fround(u1y * xfA.R.col1.y)));
                                    cp.localPoint1.y = (Math.fround(Math.fround(u1x * xfA.R.col2.x) + Math.fround(u1y * xfA.R.col2.y)));
                                    u1x = Math.fround(vec.x - xfB.position.x);
                                    u1y = Math.fround(vec.y - xfB.position.y);
                                    cp.localPoint2.x = (Math.fround(Math.fround(u1x * xfB.R.col1.x) + Math.fround(u1y * xfB.R.col1.y)));
                                    cp.localPoint2.y = (Math.fround(Math.fround(u1x * xfB.R.col2.x) + Math.fround(u1y * xfB.R.col2.y)));
                                    cp.id.set(clipPoints2[i].id);
                                    cp.id.features.flip = flip;
                                    ++pointCount;
                                }
                            }
                            ;
                        }
                        manif.pointCount = pointCount;
                        return;
                    }
                    /**
                     * puts collision information into the manifold about the collision between a polygon and a point
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.PointShape} point
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collidePolygonAndPoint(manifold, polygon, xf1, point, xf2) {
                        manifold.pointCount = 0;
                        org.jbox2d.common.XForm.mulToOut(xf2, point.getMemberLocalPosition(), this.colPPc);
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.colPPc, this.colPPcLocal);
                        let normalIndex = 0;
                        let separation = -3.4028235E38;
                        let vertexCount = polygon.getVertexCount();
                        let vertices = polygon.getVertices();
                        let normals = polygon.getNormals();
                        for (let i = 0; i < vertexCount; ++i) {
                            {
                                this.colPPsub.set$org_jbox2d_common_Vec2(this.colPPcLocal);
                                this.colPPsub.subLocal(vertices[i]);
                                let s = org.jbox2d.common.Vec2.dot(normals[i], this.colPPsub);
                                if (s > 0) {
                                    return;
                                }
                                if (s > separation) {
                                    normalIndex = i;
                                    separation = s;
                                }
                            }
                            ;
                        }
                        if (separation < org.jbox2d.common.Settings.EPSILON) {
                            manifold.pointCount = 1;
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals[normalIndex], manifold.normal);
                            manifold.points[0].id.features.incidentEdge = normalIndex;
                            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.referenceEdge = 0;
                            manifold.points[0].id.features.flip = 0;
                            let position = this.colPPc;
                            org.jbox2d.common.XForm.mulTransToOut(xf1, position, manifold.points[0].localPoint1);
                            org.jbox2d.common.XForm.mulTransToOut(xf2, position, manifold.points[0].localPoint2);
                            manifold.points[0].separation = separation;
                            return;
                        }
                        let vertIndex1 = normalIndex;
                        let vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
                        this.colPPe.set$org_jbox2d_common_Vec2(vertices[vertIndex2]);
                        this.colPPe.subLocal(vertices[vertIndex1]);
                        let length = this.colPPe.normalize();
                        this.colPPsub.set$org_jbox2d_common_Vec2(this.colPPcLocal);
                        this.colPPsub.subLocal(vertices[vertIndex1]);
                        let u = org.jbox2d.common.Vec2.dot(this.colPPsub, this.colPPe);
                        this.colPPp.setZero();
                        if (u <= 0.0) {
                            this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex1]);
                            manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.incidentVertex = vertIndex1;
                        }
                        else if (u >= length) {
                            this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex2]);
                            manifold.points[0].id.features.incidentEdge = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.incidentVertex = vertIndex2;
                        }
                        else {
                            this.colPPp.set$org_jbox2d_common_Vec2(vertices[vertIndex1]);
                            this.colPPp.x += Math.fround(u * this.colPPe.x);
                            this.colPPp.y += Math.fround(u * this.colPPe.y);
                            manifold.points[0].id.features.incidentEdge = normalIndex;
                            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                        }
                        this.colPPd.set$org_jbox2d_common_Vec2(this.colPPcLocal);
                        this.colPPd.subLocal(this.colPPp);
                        let dist = this.colPPd.normalize();
                        if (dist > 0) {
                            return;
                        }
                        manifold.pointCount = 1;
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.colPPd, manifold.normal);
                        let position = this.colPPc;
                        org.jbox2d.common.XForm.mulTransToOut(xf1, position, manifold.points[0].localPoint1);
                        org.jbox2d.common.XForm.mulTransToOut(xf2, position, manifold.points[0].localPoint2);
                        manifold.points[0].separation = dist;
                        manifold.points[0].id.features.referenceEdge = 0;
                        manifold.points[0].id.features.flip = 0;
                    }
                    /**
                     * puts collision information into the manifold about a collision between
                     * a polygon and an edge
                     * @param {org.jbox2d.collision.Manifold} manifold
                     * @param {org.jbox2d.collision.shapes.PolygonShape} polygon
                     * @param {org.jbox2d.common.XForm} xf1
                     * @param {org.jbox2d.collision.shapes.EdgeShape} edge
                     * @param {org.jbox2d.common.XForm} xf2
                     */
                    collidePolyAndEdge(manifold, polygon, xf1, edge, xf2) {
                        manifold.pointCount = 0;
                        org.jbox2d.common.XForm.mulToOut(xf2, edge.getVertex1(), this.PEv1);
                        org.jbox2d.common.XForm.mulToOut(xf2, edge.getVertex2(), this.PEv2);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getNormalVector(), this.PEn);
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.PEv1, this.PEv1Local);
                        org.jbox2d.common.XForm.mulTransToOut(xf1, this.PEv2, this.PEv2Local);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.PEn, this.PEnLocal);
                        let separation1;
                        let separationIndex1 = -1;
                        let separationMax1 = -3.4028235E38;
                        let separation2;
                        let separationIndex2 = -1;
                        let separationMax2 = -3.4028235E38;
                        let separationMax = -3.4028235E38;
                        let separationV1 = false;
                        let separationIndex = -1;
                        let vertexCount = polygon.getVertexCount();
                        let vertices = polygon.getVertices();
                        let normals = polygon.getNormals();
                        let enterStartIndex = -1;
                        let enterEndIndex = -1;
                        let exitStartIndex = -1;
                        let exitEndIndex = -1;
                        let prevSepN = 0.0;
                        let nextSepN = 0.0;
                        let enterSepN = 0.0;
                        let exitSepN = 0.0;
                        let deepestSepN = 3.4028235E38;
                        this.temp.set$org_jbox2d_common_Vec2(vertices[vertexCount - 1]);
                        this.temp.subLocal(this.PEv1Local);
                        prevSepN = org.jbox2d.common.Vec2.dot(this.temp, this.PEnLocal);
                        for (let i = 0; i < vertexCount; i++) {
                            {
                                this.temp.set$org_jbox2d_common_Vec2(this.PEv1Local);
                                this.temp.subLocal(vertices[i]);
                                separation1 = org.jbox2d.common.Vec2.dot(this.temp, normals[i]);
                                this.temp.set$org_jbox2d_common_Vec2(this.PEv2Local);
                                this.temp.subLocal(vertices[i]);
                                separation2 = org.jbox2d.common.Vec2.dot(this.temp, normals[i]);
                                if (separation2 < separation1) {
                                    if (separation2 > separationMax) {
                                        separationMax = separation2;
                                        separationV1 = false;
                                        separationIndex = i;
                                    }
                                }
                                else {
                                    if (separation1 > separationMax) {
                                        separationMax = separation1;
                                        separationV1 = true;
                                        separationIndex = i;
                                    }
                                }
                                if (separation1 > separationMax1) {
                                    separationMax1 = separation1;
                                    separationIndex1 = i;
                                }
                                if (separation2 > separationMax2) {
                                    separationMax2 = separation2;
                                    separationIndex2 = i;
                                }
                                this.temp.set$org_jbox2d_common_Vec2(vertices[i]);
                                this.temp.subLocal(this.PEv1Local);
                                nextSepN = org.jbox2d.common.Vec2.dot(this.temp, this.PEnLocal);
                                if (nextSepN >= 0.0 && prevSepN < 0.0) {
                                    exitStartIndex = (i === 0) ? vertexCount - 1 : i - 1;
                                    exitEndIndex = i;
                                    exitSepN = prevSepN;
                                }
                                else if (nextSepN < 0.0 && prevSepN >= 0.0) {
                                    enterStartIndex = (i === 0) ? vertexCount - 1 : i - 1;
                                    enterEndIndex = i;
                                    enterSepN = nextSepN;
                                }
                                if (nextSepN < deepestSepN) {
                                    deepestSepN = nextSepN;
                                }
                                prevSepN = nextSepN;
                            }
                            ;
                        }
                        if (enterStartIndex === -1) {
                            return;
                        }
                        if (separationMax > 0.0) {
                            return;
                        }
                        if ((separationV1 && edge.corner1IsConvex()) || (!separationV1 && edge.corner2IsConvex())) {
                            if (separationMax > Math.fround(deepestSepN + org.jbox2d.common.Settings.linearSlop_$LI$())) {
                                if (separationV1) {
                                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getCorner1Vector(), this.temp);
                                    org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.temp, this.temp);
                                    if (org.jbox2d.common.Vec2.dot(normals[separationIndex1], this.temp) >= 0.0) {
                                        return;
                                    }
                                }
                                else {
                                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf2.R, edge.getCorner2Vector(), this.temp);
                                    org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, this.temp, this.temp);
                                    if (org.jbox2d.common.Vec2.dot(normals[separationIndex2], this.temp) <= 0.0) {
                                        return;
                                    }
                                }
                                manifold.pointCount = 1;
                                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf1.R, normals[separationIndex], manifold.normal);
                                manifold.points[0].separation = separationMax;
                                manifold.points[0].id.features.incidentEdge = separationIndex;
                                manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                                manifold.points[0].id.features.referenceEdge = 0;
                                manifold.points[0].id.features.flip = 0;
                                if (separationV1) {
                                    manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv1Local);
                                    manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex1());
                                }
                                else {
                                    manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv2Local);
                                    manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex2());
                                }
                                return;
                            }
                        }
                        this.temp.set$org_jbox2d_common_Vec2(this.PEn);
                        this.temp.mulLocal(-1.0);
                        manifold.normal.set$org_jbox2d_common_Vec2(this.temp);
                        if (enterEndIndex === exitStartIndex) {
                            manifold.pointCount = 1;
                            manifold.points[0].id.features.incidentEdge = enterEndIndex;
                            manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                            manifold.points[0].id.features.referenceEdge = 0;
                            manifold.points[0].id.features.flip = 0;
                            manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
                            org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[enterEndIndex]), manifold.points[0].localPoint2);
                            manifold.points[0].separation = enterSepN;
                            return;
                        }
                        manifold.pointCount = 2;
                        org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.PEnLocal, -1.0, this.temp);
                        this.temp2.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
                        this.temp2.subLocal(this.PEv1Local);
                        let dirProj1 = org.jbox2d.common.Vec2.dot(this.temp, this.temp2);
                        let dirProj2 = 0.0;
                        this.temp2.set$org_jbox2d_common_Vec2(vertices[exitStartIndex]);
                        this.temp2.subLocal(this.PEv1Local);
                        exitEndIndex = (enterEndIndex === vertexCount - 1) ? 0 : enterEndIndex + 1;
                        if (exitEndIndex !== exitStartIndex) {
                            exitStartIndex = exitEndIndex;
                            exitSepN = org.jbox2d.common.Vec2.dot(this.PEnLocal, this.temp2);
                        }
                        dirProj2 = org.jbox2d.common.Vec2.dot(this.temp, this.temp2);
                        manifold.points[0].id.features.incidentEdge = enterEndIndex;
                        manifold.points[0].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                        manifold.points[0].id.features.referenceEdge = 0;
                        manifold.points[0].id.features.flip = 0;
                        if (dirProj1 > edge.getLength()) {
                            manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(this.PEv2Local);
                            manifold.points[0].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex2());
                            let ratio = Math.fround((Math.fround(edge.getLength() - dirProj2)) / (Math.fround(dirProj1 - dirProj2)));
                            if (ratio > Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON) && ratio < 1.0) {
                                manifold.points[0].separation = Math.fround(Math.fround(exitSepN * (Math.fround(1.0 - ratio))) + Math.fround(enterSepN * ratio));
                            }
                            else {
                                manifold.points[0].separation = enterSepN;
                            }
                        }
                        else {
                            manifold.points[0].localPoint1.set$org_jbox2d_common_Vec2(vertices[enterEndIndex]);
                            org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[enterEndIndex]), manifold.points[0].localPoint2);
                            manifold.points[0].separation = enterSepN;
                        }
                        manifold.points[1].id.features.incidentEdge = exitStartIndex;
                        manifold.points[1].id.features.incidentVertex = org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
                        manifold.points[1].id.features.referenceEdge = 0;
                        manifold.points[1].id.features.flip = 0;
                        if (dirProj2 < 0.0) {
                            manifold.points[1].localPoint1.set$org_jbox2d_common_Vec2(this.PEv1Local);
                            manifold.points[1].localPoint2.set$org_jbox2d_common_Vec2(edge.getVertex1());
                            let ratio = Math.fround((-dirProj1) / (Math.fround(dirProj2 - dirProj1)));
                            if (ratio > Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON) && ratio < 1.0) {
                                manifold.points[1].separation = Math.fround(Math.fround(enterSepN * (Math.fround(1.0 - ratio))) + Math.fround(exitSepN * ratio));
                            }
                            else {
                                manifold.points[1].separation = exitSepN;
                            }
                        }
                        else {
                            manifold.points[1].localPoint1.set$org_jbox2d_common_Vec2(vertices[exitStartIndex]);
                            org.jbox2d.common.XForm.mulTransToOut(xf2, org.jbox2d.common.XForm.mul(xf1, vertices[exitStartIndex]), manifold.points[1].localPoint2);
                            manifold.points[1].separation = exitSepN;
                        }
                    }
                }
                shapes.CollidePoly = CollidePoly;
                CollidePoly["__class"] = "org.jbox2d.collision.shapes.CollidePoly";
                (function (CollidePoly) {
                    class ClipVertex {
                        constructor() {
                            if (this.v === undefined)
                                this.v = null;
                            if (this.id === undefined)
                                this.id = null;
                            this.v = new org.jbox2d.common.Vec2();
                            this.id = new org.jbox2d.collision.ContactID();
                        }
                    }
                    CollidePoly.ClipVertex = ClipVertex;
                    ClipVertex["__class"] = "org.jbox2d.collision.shapes.CollidePoly.ClipVertex";
                })(CollidePoly = shapes.CollidePoly || (shapes.CollidePoly = {}));
                /**
                 * Holder class used internally in CollidePoly
                 * @class
                 */
                class MaxSeparation {
                    constructor() {
                        if (this.bestFaceIndex === undefined)
                            this.bestFaceIndex = 0;
                        if (this.bestSeparation === undefined)
                            this.bestSeparation = 0;
                    }
                }
                shapes.MaxSeparation = MaxSeparation;
                MaxSeparation["__class"] = "org.jbox2d.collision.shapes.MaxSeparation";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Superclass for shape definitions.
                 * You should usually use CircleDef or
                 * PolygonDef to define concrete shapes.
                 * @class
                 */
                class ShapeDef {
                    constructor() {
                        if (this.type === undefined)
                            this.type = null;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.friction === undefined)
                            this.friction = 0;
                        if (this.restitution === undefined)
                            this.restitution = 0;
                        if (this.density === undefined)
                            this.density = 0;
                        if (this.filter === undefined)
                            this.filter = null;
                        if (this.isSensor === undefined)
                            this.isSensor = false;
                        this.type = org.jbox2d.collision.shapes.ShapeType.UNKNOWN_SHAPE;
                        this.userData = null;
                        this.friction = 0.2;
                        this.restitution = 0.0;
                        this.density = 0.0;
                        this.filter = new org.jbox2d.collision.FilterData();
                        this.filter.categoryBits = 1;
                        this.filter.maskBits = 65535;
                        this.filter.groupIndex = 0;
                        this.isSensor = false;
                    }
                }
                shapes.ShapeDef = ShapeDef;
                ShapeDef["__class"] = "org.jbox2d.collision.shapes.ShapeDef";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                var ShapeType;
                (function (ShapeType) {
                    ShapeType[ShapeType["UNKNOWN_SHAPE"] = 0] = "UNKNOWN_SHAPE";
                    ShapeType[ShapeType["CIRCLE_SHAPE"] = 1] = "CIRCLE_SHAPE";
                    ShapeType[ShapeType["POLYGON_SHAPE"] = 2] = "POLYGON_SHAPE";
                    ShapeType[ShapeType["POINT_SHAPE"] = 3] = "POINT_SHAPE";
                    ShapeType[ShapeType["EDGE_SHAPE"] = 4] = "EDGE_SHAPE";
                    ShapeType[ShapeType["SHAPE_TYPE_COUNT"] = 5] = "SHAPE_TYPE_COUNT";
                })(ShapeType = shapes.ShapeType || (shapes.ShapeType = {}));
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * Similar to javax.vecmath.Color3f holder
             * @author ewjordan
             * @param {number} r
             * @param {number} g
             * @param {number} b
             * @class
             */
            class Color3f {
                constructor(r, g, b) {
                    if (this.x === undefined)
                        this.x = 0;
                    if (this.y === undefined)
                        this.y = 0;
                    if (this.z === undefined)
                        this.z = 0;
                    this.x = r;
                    this.y = g;
                    this.z = b;
                }
                static WHITE_$LI$() { if (Color3f.WHITE == null)
                    Color3f.WHITE = new Color3f(255, 255, 255); return Color3f.WHITE; }
                ;
                static BLACK_$LI$() { if (Color3f.BLACK == null)
                    Color3f.BLACK = new Color3f(0, 0, 0); return Color3f.BLACK; }
                ;
                static BLUE_$LI$() { if (Color3f.BLUE == null)
                    Color3f.BLUE = new Color3f(0, 0, 255); return Color3f.BLUE; }
                ;
                static GREEN_$LI$() { if (Color3f.GREEN == null)
                    Color3f.GREEN = new Color3f(0, 255, 0); return Color3f.GREEN; }
                ;
                static RED_$LI$() { if (Color3f.RED == null)
                    Color3f.RED = new Color3f(255, 0, 0); return Color3f.RED; }
                ;
            }
            common.Color3f = Color3f;
            Color3f["__class"] = "org.jbox2d.common.Color3f";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * Create a matrix from four floats.
             * @param {number} col1x
             * @param {number} col2x
             * @param {number} col1y
             * @param {number} col2y
             * @class
             * @author ewjordan
             */
            class Mat22 {
                constructor(col1x, col2x, col1y, col2y) {
                    if (((typeof col1x === 'number') || col1x === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof col1y === 'number') || col1y === null) && ((typeof col2y === 'number') || col2y === null)) {
                        let __args = arguments;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        (() => {
                            this.col1 = new org.jbox2d.common.Vec2(col1x, col1y);
                            this.col2 = new org.jbox2d.common.Vec2(col2x, col2y);
                        })();
                    }
                    else if (((col1x != null && col1x instanceof org.jbox2d.common.Vec2) || col1x === null) && ((col2x != null && col2x instanceof org.jbox2d.common.Vec2) || col2x === null) && col1y === undefined && col2y === undefined) {
                        let __args = arguments;
                        let c1 = __args[0];
                        let c2 = __args[1];
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        (() => {
                            this.col1 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(c1);
                            this.col2 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(c2);
                        })();
                    }
                    else if (col1x === undefined && col2x === undefined && col1y === undefined && col2y === undefined) {
                        let __args = arguments;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        (() => {
                            this.col1 = new org.jbox2d.common.Vec2();
                            this.col2 = new org.jbox2d.common.Vec2();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Convert the matrix to printable format.
                 * @return {string}
                 */
                toString() {
                    let s = "";
                    s += "[" + this.col1.x + "," + this.col2.x + "]\n";
                    s += "[" + this.col1.y + "," + this.col2.y + "]";
                    return s;
                }
                set$org_jbox2d_common_Mat22(m) {
                    this.col1.x = m.col1.x;
                    this.col1.y = m.col1.y;
                    this.col2.x = m.col2.x;
                    this.col2.y = m.col2.y;
                    return this;
                }
                set$float$float$float$float(col1x, col2x, col1y, col2y) {
                    this.col1.x = col1x;
                    this.col1.y = col1y;
                    this.col2.x = col2x;
                    this.col2.y = col2y;
                    return this;
                }
                set(col1x, col2x, col1y, col2y) {
                    if (((typeof col1x === 'number') || col1x === null) && ((typeof col2x === 'number') || col2x === null) && ((typeof col1y === 'number') || col1y === null) && ((typeof col2y === 'number') || col2y === null)) {
                        return this.set$float$float$float$float(col1x, col2x, col1y, col2y);
                    }
                    else if (((col1x != null && col1x instanceof org.jbox2d.common.Vec2) || col1x === null) && ((col2x != null && col2x instanceof org.jbox2d.common.Vec2) || col2x === null) && col1y === undefined && col2y === undefined) {
                        return this.set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(col1x, col2x);
                    }
                    else if (((col1x != null && col1x instanceof org.jbox2d.common.Mat22) || col1x === null) && col2x === undefined && col1y === undefined && col2y === undefined) {
                        return this.set$org_jbox2d_common_Mat22(col1x);
                    }
                    else if (((typeof col1x === 'number') || col1x === null) && col2x === undefined && col1y === undefined && col2y === undefined) {
                        return this.set$float(col1x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Return a clone of this matrix.
                 * djm fixed double allocation
                 * @return {org.jbox2d.common.Mat22}
                 */
                clone() {
                    return new Mat22(this.col1, this.col2);
                }
                set$float(angle) {
                    let c = org.jbox2d.common.MathUtils.cos(angle);
                    let s = org.jbox2d.common.MathUtils.sin(angle);
                    this.col1.x = c;
                    this.col2.x = -s;
                    this.col1.y = s;
                    this.col2.y = c;
                }
                /**
                 * Set as the identity matrix.
                 */
                setIdentity() {
                    this.col1.x = 1.0;
                    this.col2.x = 0.0;
                    this.col1.y = 0.0;
                    this.col2.y = 1.0;
                }
                /**
                 * Set as the zero matrix.
                 */
                setZero() {
                    this.col1.x = 0.0;
                    this.col2.x = 0.0;
                    this.col1.y = 0.0;
                    this.col2.y = 0.0;
                }
                set$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(c1, c2) {
                    this.col1.x = c1.x;
                    this.col2.x = c2.x;
                    this.col1.y = c1.y;
                    this.col2.y = c2.y;
                }
                /**
                 * Returns the inverted Mat22 - does NOT invert the matrix locally!
                 * @return {org.jbox2d.common.Mat22}
                 */
                invert() {
                    let a = this.col1.x;
                    let b = this.col2.x;
                    let c = this.col1.y;
                    let d = this.col2.y;
                    let B = new Mat22();
                    let det = Math.fround(Math.fround(a * d) - Math.fround(b * c));
                    det = Math.fround(1.0 / det);
                    B.col1.x = Math.fround(det * d);
                    B.col2.x = Math.fround(-det * b);
                    B.col1.y = Math.fround(-det * c);
                    B.col2.y = Math.fround(det * a);
                    return B;
                }
                invertLocal() {
                    let a = this.col1.x;
                    let b = this.col2.x;
                    let c = this.col1.y;
                    let d = this.col2.y;
                    let det = Math.fround(Math.fround(a * d) - Math.fround(b * c));
                    det = Math.fround(1.0 / det);
                    this.col1.x = Math.fround(det * d);
                    this.col2.x = Math.fround(-det * b);
                    this.col1.y = Math.fround(-det * c);
                    this.col2.y = Math.fround(det * a);
                    return this;
                }
                invertToOut(out) {
                    let a = this.col1.x;
                    let b = this.col2.x;
                    let c = this.col1.y;
                    let d = this.col2.y;
                    let det = Math.fround(Math.fround(a * d) - Math.fround(b * c));
                    det = Math.fround(1.0 / det);
                    out.col1.x = Math.fround(det * d);
                    out.col2.x = Math.fround(-det * b);
                    out.col1.y = Math.fround(-det * c);
                    out.col2.y = Math.fround(det * a);
                }
                /**
                 * Return the matrix composed of the absolute values of all elements.
                 * djm: fixed double allocation
                 * @return {org.jbox2d.common.Mat22} Absolute value matrix
                 */
                abs() {
                    return new Mat22(org.jbox2d.common.MathUtils.abs(this.col1.x), org.jbox2d.common.MathUtils.abs(this.col2.x), org.jbox2d.common.MathUtils.abs(this.col1.y), org.jbox2d.common.MathUtils.abs(this.col2.y));
                }
                absLocal() {
                    this.col1.absLocal();
                    this.col2.absLocal();
                }
                /**
                 * Return the matrix composed of the absolute values of all elements.
                 * @return {org.jbox2d.common.Mat22} Absolute value matrix
                 * @param {org.jbox2d.common.Mat22} R
                 */
                static abs(R) {
                    return R.abs();
                }
                static absToOut(R, out) {
                    out.col1.x = org.jbox2d.common.MathUtils.abs(R.col1.x);
                    out.col1.y = org.jbox2d.common.MathUtils.abs(R.col1.y);
                    out.col2.x = org.jbox2d.common.MathUtils.abs(R.col2.x);
                    out.col2.y = org.jbox2d.common.MathUtils.abs(R.col2.y);
                }
                mul$org_jbox2d_common_Vec2(v) {
                    return new org.jbox2d.common.Vec2(Math.fround(Math.fround(this.col1.x * v.x) + Math.fround(this.col2.x * v.y)), Math.fround(Math.fround(this.col1.y * v.x) + Math.fround(this.col2.y * v.y)));
                }
                /**
                 * Multiply a vector by this matrix.
                 * @param {org.jbox2d.common.Vec2} v Vector to multiply by matrix.
                 * @return {org.jbox2d.common.Vec2} Resulting vector
                 */
                mul(v) {
                    if (((v != null && v instanceof org.jbox2d.common.Vec2) || v === null)) {
                        return this.mul$org_jbox2d_common_Vec2(v);
                    }
                    else if (((v != null && v instanceof org.jbox2d.common.Mat22) || v === null)) {
                        return this.mul$org_jbox2d_common_Mat22(v);
                    }
                    else
                        throw new Error('invalid overload');
                }
                mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out) {
                    let tempy = Math.fround(Math.fround(this.col1.y * v.x) + Math.fround(this.col2.y * v.y));
                    out.x = Math.fround(Math.fround(this.col1.x * v.x) + Math.fround(this.col2.x * v.y));
                    out.y = tempy;
                }
                mulToOut(v, out) {
                    if (((v != null && v instanceof org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return this.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out);
                    }
                    else if (((v != null && v instanceof org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(v, out);
                    }
                    else
                        throw new Error('invalid overload');
                }
                mul$org_jbox2d_common_Mat22(R) {
                    let C = new Mat22();
                    C.col1.x = Math.fround(Math.fround(this.col1.x * R.col1.x) + Math.fround(this.col2.x * R.col1.y));
                    C.col1.y = Math.fround(Math.fround(this.col1.y * R.col1.x) + Math.fround(this.col2.y * R.col1.y));
                    C.col2.x = Math.fround(Math.fround(this.col1.x * R.col2.x) + Math.fround(this.col2.x * R.col2.y));
                    C.col2.y = Math.fround(Math.fround(this.col1.y * R.col2.x) + Math.fround(this.col2.y * R.col2.y));
                    return C;
                }
                mulLocal(R) {
                    this.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, this);
                    return this;
                }
                mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, out) {
                    let tempy1 = Math.fround(Math.fround(this.col1.y * R.col1.x) + Math.fround(this.col2.y * R.col1.y));
                    let tempx1 = Math.fround(Math.fround(this.col1.x * R.col1.x) + Math.fround(this.col2.x * R.col1.y));
                    out.col1.x = tempx1;
                    out.col1.y = tempy1;
                    let tempy2 = Math.fround(Math.fround(this.col1.y * R.col2.x) + Math.fround(this.col2.y * R.col2.y));
                    let tempx2 = Math.fround(Math.fround(this.col1.x * R.col2.x) + Math.fround(this.col2.x * R.col2.y));
                    out.col2.x = tempx2;
                    out.col2.y = tempy2;
                }
                mulTrans$org_jbox2d_common_Mat22(B) {
                    let C = new Mat22();
                    C.col1.x = org.jbox2d.common.Vec2.dot(this.col1, B.col1);
                    C.col1.y = org.jbox2d.common.Vec2.dot(this.col2, B.col1);
                    C.col2.x = org.jbox2d.common.Vec2.dot(this.col1, B.col2);
                    C.col2.y = org.jbox2d.common.Vec2.dot(this.col2, B.col2);
                    return C;
                }
                /**
                 * Multiply another matrix by the transpose of this one (transpose of this one on left).
                 * djm: optimized
                 * @param {org.jbox2d.common.Mat22} B
                 * @return
                 * @return {org.jbox2d.common.Mat22}
                 */
                mulTrans(B) {
                    if (((B != null && B instanceof org.jbox2d.common.Mat22) || B === null)) {
                        return this.mulTrans$org_jbox2d_common_Mat22(B);
                    }
                    else if (((B != null && B instanceof org.jbox2d.common.Vec2) || B === null)) {
                        return this.mulTrans$org_jbox2d_common_Vec2(B);
                    }
                    else
                        throw new Error('invalid overload');
                }
                mulTransLocal(B) {
                    this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, this);
                    return this;
                }
                mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, out) {
                    let x1 = Math.fround(Math.fround(this.col1.x * B.col1.x) + Math.fround(this.col1.y * B.col1.y));
                    let y1 = Math.fround(Math.fround(this.col2.x * B.col1.x) + Math.fround(this.col2.y * B.col1.y));
                    let x2 = Math.fround(Math.fround(this.col1.x * B.col2.x) + Math.fround(this.col1.y * B.col2.y));
                    let y2 = Math.fround(Math.fround(this.col2.x * B.col2.x) + Math.fround(this.col2.y * B.col2.y));
                    out.col1.x = x1;
                    out.col2.x = x2;
                    out.col1.y = y1;
                    out.col2.y = y2;
                }
                mulTransToOut(B, out) {
                    if (((B != null && B instanceof org.jbox2d.common.Mat22) || B === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return this.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(B, out);
                    }
                    else if (((B != null && B instanceof org.jbox2d.common.Vec2) || B === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return this.mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(B, out);
                    }
                    else
                        throw new Error('invalid overload');
                }
                mulTrans$org_jbox2d_common_Vec2(v) {
                    return new org.jbox2d.common.Vec2((Math.fround(Math.fround(v.x * this.col1.x) + Math.fround(v.y * this.col1.y))), (Math.fround(Math.fround(v.x * this.col2.x) + Math.fround(v.y * this.col2.y))));
                }
                mulTransToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(v, out) {
                    out.x = Math.fround(Math.fround(v.x * this.col1.x) + Math.fround(v.y * this.col1.y));
                    out.y = org.jbox2d.common.Vec2.dot(v, this.col2);
                }
                /**
                 * Add this matrix to B, return the result.
                 * @param {org.jbox2d.common.Mat22} B
                 * @return
                 * @return {org.jbox2d.common.Mat22}
                 */
                add(B) {
                    let m = new Mat22();
                    m.col1.x = Math.fround(this.col1.x + B.col1.x);
                    m.col1.y = Math.fround(this.col1.y + B.col1.y);
                    m.col2.x = Math.fround(this.col2.x + B.col2.x);
                    m.col2.y = Math.fround(this.col2.y + B.col2.y);
                    return m;
                }
                /**
                 * Add B to this matrix locally.
                 * @param {org.jbox2d.common.Mat22} B
                 * @return
                 * @return {org.jbox2d.common.Mat22}
                 */
                addLocal(B) {
                    this.col1.x += B.col1.x;
                    this.col1.y += B.col1.y;
                    this.col2.x += B.col2.x;
                    this.col2.y += B.col2.y;
                    return this;
                }
                /**
                 * Solve A * x = b where A = this matrix.
                 * @return {org.jbox2d.common.Vec2} The vector x that solves the above equation.
                 * @param {org.jbox2d.common.Vec2} b
                 */
                solve(b) {
                    let a11 = this.col1.x;
                    let a12 = this.col2.x;
                    let a21 = this.col1.y;
                    let a22 = this.col2.y;
                    let det = Math.fround(Math.fround(a11 * a22) - Math.fround(a12 * a21));
                    det = Math.fround(1.0 / det);
                    let x = new org.jbox2d.common.Vec2(Math.fround(det * (Math.fround(Math.fround(a22 * b.x) - Math.fround(a12 * b.y)))), Math.fround(det * (Math.fround(Math.fround(a11 * b.y) - Math.fround(a21 * b.x)))));
                    return x;
                }
                solveToOut(b, out) {
                    let a11 = this.col1.x;
                    let a12 = this.col2.x;
                    let a21 = this.col1.y;
                    let a22 = this.col2.y;
                    let det = Math.fround(Math.fround(a11 * a22) - Math.fround(a12 * a21));
                    det = Math.fround(1.0 / det);
                    let tempy = Math.fround(det * (Math.fround(Math.fround(a11 * b.y) - Math.fround(a21 * b.x))));
                    out.x = Math.fround(det * (Math.fround(Math.fround(a22 * b.x) - Math.fround(a12 * b.y))));
                    out.y = tempy;
                }
                static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v) {
                    return new org.jbox2d.common.Vec2(Math.fround(Math.fround(R.col1.x * v.x) + Math.fround(R.col2.x * v.y)), Math.fround(Math.fround(R.col1.y * v.x) + Math.fround(R.col2.y * v.y)));
                }
                static mul(R, v) {
                    if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Vec2) || v === null)) {
                        return org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
                    }
                    else if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Mat22) || v === null)) {
                        return org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out) {
                    let tempy = Math.fround(Math.fround(R.col1.y * v.x) + Math.fround(R.col2.y * v.y));
                    out.x = Math.fround(Math.fround(R.col1.x * v.x) + Math.fround(R.col2.x * v.y));
                    out.y = tempy;
                }
                static mulToOut(R, v, out) {
                    if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
                    }
                    else if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static mul$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A, B) {
                    let C = new Mat22();
                    C.col1.x = Math.fround(Math.fround(A.col1.x * B.col1.x) + Math.fround(A.col2.x * B.col1.y));
                    C.col1.y = Math.fround(Math.fround(A.col1.y * B.col1.x) + Math.fround(A.col2.y * B.col1.y));
                    C.col2.x = Math.fround(Math.fround(A.col1.x * B.col2.x) + Math.fround(A.col2.x * B.col2.y));
                    C.col2.y = Math.fround(Math.fround(A.col1.y * B.col2.x) + Math.fround(A.col2.y * B.col2.y));
                    return C;
                }
                static mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A, B, out) {
                    let tempy1 = Math.fround(Math.fround(A.col1.y * B.col1.x) + Math.fround(A.col2.y * B.col1.y));
                    let tempx1 = Math.fround(Math.fround(A.col1.x * B.col1.x) + Math.fround(A.col2.x * B.col1.y));
                    let tempy2 = Math.fround(Math.fround(A.col1.y * B.col2.x) + Math.fround(A.col2.y * B.col2.y));
                    let tempx2 = Math.fround(Math.fround(A.col1.x * B.col2.x) + Math.fround(A.col2.x * B.col2.y));
                    out.col1.x = tempx1;
                    out.col1.y = tempy1;
                    out.col2.x = tempx2;
                    out.col2.y = tempy2;
                }
                static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v) {
                    return new org.jbox2d.common.Vec2((Math.fround(Math.fround(v.x * R.col1.x) + Math.fround(v.y * R.col1.y))), (Math.fround(Math.fround(v.x * R.col2.x) + Math.fround(v.y * R.col2.y))));
                }
                static mulTrans(R, v) {
                    if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Vec2) || v === null)) {
                        return org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(R, v);
                    }
                    else if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Mat22) || v === null)) {
                        return org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out) {
                    let outx = Math.fround(Math.fround(v.x * R.col1.x) + Math.fround(v.y * R.col1.y));
                    out.y = Math.fround(Math.fround(v.x * R.col2.x) + Math.fround(v.y * R.col2.y));
                    out.x = outx;
                }
                static mulTransToOut(R, v, out) {
                    if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Vec2) || v === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(R, v, out);
                    }
                    else if (((R != null && R instanceof org.jbox2d.common.Mat22) || R === null) && ((v != null && v instanceof org.jbox2d.common.Mat22) || v === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(R, v, out);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A, B) {
                    let C = new Mat22();
                    C.col1.x = Math.fround(Math.fround(A.col1.x * B.col1.x) + Math.fround(A.col1.y * B.col1.y));
                    C.col1.y = Math.fround(Math.fround(A.col2.x * B.col1.x) + Math.fround(A.col2.y * B.col1.y));
                    C.col2.x = Math.fround(Math.fround(A.col1.x * B.col2.x) + Math.fround(A.col1.y * B.col2.y));
                    C.col2.y = Math.fround(Math.fround(A.col2.x * B.col2.x) + Math.fround(A.col2.y * B.col2.y));
                    return C;
                }
                static mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(A, B, out) {
                    let x1 = Math.fround(Math.fround(A.col1.x * B.col1.x) + Math.fround(A.col1.y * B.col1.y));
                    let y1 = Math.fround(Math.fround(A.col2.x * B.col1.x) + Math.fround(A.col2.y * B.col1.y));
                    let x2 = Math.fround(Math.fround(A.col1.x * B.col2.x) + Math.fround(A.col1.y * B.col2.y));
                    let y2 = Math.fround(Math.fround(A.col2.x * B.col2.x) + Math.fround(A.col2.y * B.col2.y));
                    out.col1.x = x1;
                    out.col1.y = y1;
                    out.col2.x = x2;
                    out.col2.y = y2;
                }
                static createRotationalTransform$float(angle) {
                    let mat = new Mat22();
                    let c = org.jbox2d.common.MathUtils.cos(angle);
                    let s = org.jbox2d.common.MathUtils.sin(angle);
                    mat.col1.x = c;
                    mat.col2.x = -s;
                    mat.col1.y = s;
                    mat.col2.y = c;
                    return mat;
                }
                static createRotationalTransform$float$org_jbox2d_common_Mat22(angle, out) {
                    let c = org.jbox2d.common.MathUtils.cos(angle);
                    let s = org.jbox2d.common.MathUtils.sin(angle);
                    out.col1.x = c;
                    out.col2.x = -s;
                    out.col1.y = s;
                    out.col2.y = c;
                }
                static createRotationalTransform(angle, out) {
                    if (((typeof angle === 'number') || angle === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return org.jbox2d.common.Mat22.createRotationalTransform$float$org_jbox2d_common_Mat22(angle, out);
                    }
                    else if (((typeof angle === 'number') || angle === null) && out === undefined) {
                        return org.jbox2d.common.Mat22.createRotationalTransform$float(angle);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static createScaleTransform$float(scale) {
                    let mat = new Mat22();
                    mat.col1.x = scale;
                    mat.col2.y = scale;
                    return mat;
                }
                static createScaleTransform$float$float(scaleX, scaleY) {
                    let mat = new Mat22();
                    mat.col1.x = scaleX;
                    mat.col2.y = scaleY;
                    return mat;
                }
                static createScaleTransform$float$org_jbox2d_common_Mat22(scale, out) {
                    out.col1.x = scale;
                    out.col1.y = 0;
                    out.col2.x = 0;
                    out.col2.y = scale;
                }
                static createScaleTransform$float$float$org_jbox2d_common_Mat22(scaleX, scaleY, out) {
                    out.col1.x = scaleX;
                    out.col1.y = 0;
                    out.col2.x = 0;
                    out.col2.y = scaleY;
                }
                static createScaleTransform(scaleX, scaleY, out) {
                    if (((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && ((out != null && out instanceof org.jbox2d.common.Mat22) || out === null)) {
                        return org.jbox2d.common.Mat22.createScaleTransform$float$float$org_jbox2d_common_Mat22(scaleX, scaleY, out);
                    }
                    else if (((typeof scaleX === 'number') || scaleX === null) && ((scaleY != null && scaleY instanceof org.jbox2d.common.Mat22) || scaleY === null) && out === undefined) {
                        return org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scaleX, scaleY);
                    }
                    else if (((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && out === undefined) {
                        return org.jbox2d.common.Mat22.createScaleTransform$float$float(scaleX, scaleY);
                    }
                    else if (((typeof scaleX === 'number') || scaleX === null) && scaleY === undefined && out === undefined) {
                        return org.jbox2d.common.Mat22.createScaleTransform$float(scaleX);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            common.Mat22 = Mat22;
            Mat22["__class"] = "org.jbox2d.common.Mat22";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            class Mat33 {
                constructor(argCol1, argCol2, argCol3) {
                    /*private*/ this.temp = new org.jbox2d.common.Vec3();
                    if (((argCol1 != null && argCol1 instanceof org.jbox2d.common.Vec3) || argCol1 === null) && ((argCol2 != null && argCol2 instanceof org.jbox2d.common.Vec3) || argCol2 === null) && ((argCol3 != null && argCol3 instanceof org.jbox2d.common.Vec3) || argCol3 === null)) {
                        let __args = arguments;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col3 === undefined)
                            this.col3 = null;
                        this.temp = new org.jbox2d.common.Vec3();
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col3 === undefined)
                            this.col3 = null;
                        (() => {
                            this.col1 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(argCol1);
                            this.col2 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(argCol2);
                            this.col3 = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(argCol3);
                        })();
                    }
                    else if (argCol1 === undefined && argCol2 === undefined && argCol3 === undefined) {
                        let __args = arguments;
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col3 === undefined)
                            this.col3 = null;
                        this.temp = new org.jbox2d.common.Vec3();
                        if (this.col1 === undefined)
                            this.col1 = null;
                        if (this.col2 === undefined)
                            this.col2 = null;
                        if (this.col3 === undefined)
                            this.col3 = null;
                        (() => {
                            this.col1 = new org.jbox2d.common.Vec3();
                            this.col2 = new org.jbox2d.common.Vec3();
                            this.col3 = new org.jbox2d.common.Vec3();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                setZero() {
                    this.col1.setZero();
                    this.col2.setZero();
                    this.col3.setZero();
                }
                static mul(A, v) {
                    return new org.jbox2d.common.Vec3(Math.fround(Math.fround(Math.fround(Math.fround(v.x * A.col1.x) + Math.fround(v.y * A.col2.x)) + v.z) + A.col3.x), Math.fround(Math.fround(Math.fround(v.x * A.col1.y) + Math.fround(v.y * A.col2.y)) + Math.fround(v.z * A.col3.y)), Math.fround(Math.fround(Math.fround(v.x * A.col1.z) + Math.fround(v.y * A.col2.z)) + Math.fround(v.z * A.col3.z)));
                }
                static mulToOut(A, v, out) {
                    let tempy = Math.fround(Math.fround(Math.fround(v.x * A.col1.y) + Math.fround(v.y * A.col2.y)) + Math.fround(v.z * A.col3.y));
                    let tempz = Math.fround(Math.fround(Math.fround(v.x * A.col1.z) + Math.fround(v.y * A.col2.z)) + Math.fround(v.z * A.col3.z));
                    out.x = Math.fround(Math.fround(Math.fround(Math.fround(v.x * A.col1.x) + Math.fround(v.y * A.col2.x)) + v.z) + A.col3.x);
                    out.y = tempy;
                    out.z = tempz;
                }
                solve(b) {
                    org.jbox2d.common.Vec3.crossToOut(this.col1, this.col2, this.temp);
                    let det = org.jbox2d.common.Vec3.dot(this.col1, this.temp);
                    det = Math.fround(1.0 / det);
                    let x = new org.jbox2d.common.Vec3();
                    org.jbox2d.common.Vec3.crossToOut(this.col2, this.col3, this.temp);
                    x.x = Math.fround(det * org.jbox2d.common.Vec3.dot(b, this.temp));
                    org.jbox2d.common.Vec3.crossToOut(b, this.col3, this.temp);
                    x.y = Math.fround(det * org.jbox2d.common.Vec3.dot(this.col1, this.temp));
                    org.jbox2d.common.Vec3.crossToOut(this.col2, b, this.temp);
                    x.z = Math.fround(det * org.jbox2d.common.Vec3.dot(this.col1, this.temp));
                    return x;
                }
                solveToOut(b, out) {
                    org.jbox2d.common.Vec3.crossToOut(this.col1, this.col2, out);
                    let det = org.jbox2d.common.Vec3.dot(this.col1, out);
                    det = Math.fround(1.0 / det);
                    org.jbox2d.common.Vec3.crossToOut(this.col2, this.col3, out);
                    let tempx = Math.fround(det * org.jbox2d.common.Vec3.dot(b, out));
                    org.jbox2d.common.Vec3.crossToOut(b, this.col3, out);
                    let tempy = Math.fround(det * org.jbox2d.common.Vec3.dot(this.col1, out));
                    org.jbox2d.common.Vec3.crossToOut(this.col2, b, out);
                    let tempz = Math.fround(det * org.jbox2d.common.Vec3.dot(this.col1, out));
                    out.x = tempx;
                    out.y = tempy;
                    out.z = tempz;
                }
            }
            common.Mat33 = Mat33;
            Mat33["__class"] = "org.jbox2d.common.Mat33";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            class RaycastResult {
                constructor() {
                    this.lambda = 0.0;
                    this.normal = new org.jbox2d.common.Vec2();
                }
                set(argOther) {
                    this.lambda = argOther.lambda;
                    this.normal.set$org_jbox2d_common_Vec2(argOther.normal);
                    return this;
                }
            }
            common.RaycastResult = RaycastResult;
            RaycastResult["__class"] = "org.jbox2d.common.RaycastResult";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * Global tuning constants based on MKS units and various integer maximums (vertices per shape, pairs, etc.).
             * @class
             */
            class Settings {
                static pi_$LI$() { if (Settings.pi == null)
                    Settings.pi = Math.fround(Math.PI); return Settings.pi; }
                ;
                static SINCOS_LUT_LENGTH_$LI$() { if (Settings.SINCOS_LUT_LENGTH == null)
                    Settings.SINCOS_LUT_LENGTH = (Math.ceil(Math.PI * 2 / Settings.SINCOS_LUT_PRECISION) | 0); return Settings.SINCOS_LUT_LENGTH; }
                ;
                static maxPairs_$LI$() { if (Settings.maxPairs == null)
                    Settings.maxPairs = 8 * Settings.maxProxies; return Settings.maxPairs; }
                ;
                static linearSlop_$LI$() { if (Settings.linearSlop == null)
                    Settings.linearSlop = Math.fround(0.005 * Settings.lengthUnitsPerMeter); return Settings.linearSlop; }
                ;
                static angularSlop_$LI$() { if (Settings.angularSlop == null)
                    Settings.angularSlop = Math.fround(Math.fround(2.0 / 180.0) * Settings.pi_$LI$()); return Settings.angularSlop; }
                ;
                static velocityThreshold_$LI$() { if (Settings.velocityThreshold == null)
                    Settings.velocityThreshold = Math.fround(Math.fround(1.0 * Settings.lengthUnitsPerMeter) / Settings.timeUnitsPerSecond); return Settings.velocityThreshold; }
                ;
                static maxLinearCorrection_$LI$() { if (Settings.maxLinearCorrection == null)
                    Settings.maxLinearCorrection = Math.fround(0.2 * Settings.lengthUnitsPerMeter); return Settings.maxLinearCorrection; }
                ;
                static maxAngularCorrection_$LI$() { if (Settings.maxAngularCorrection == null)
                    Settings.maxAngularCorrection = Math.fround(Math.fround(8.0 / 180.0) * Settings.pi_$LI$()); return Settings.maxAngularCorrection; }
                ;
                static timeToSleep_$LI$() { if (Settings.timeToSleep == null)
                    Settings.timeToSleep = Math.fround(0.5 * Settings.timeUnitsPerSecond); return Settings.timeToSleep; }
                ;
                static linearSleepTolerance_$LI$() { if (Settings.linearSleepTolerance == null)
                    Settings.linearSleepTolerance = Math.fround(Math.fround(0.01 * Settings.lengthUnitsPerMeter) / Settings.timeUnitsPerSecond); return Settings.linearSleepTolerance; }
                ;
                static angularSleepTolerance_$LI$() { if (Settings.angularSleepTolerance == null)
                    Settings.angularSleepTolerance = Math.fround(Math.fround(2.0 / 180.0) / Settings.timeUnitsPerSecond); return Settings.angularSleepTolerance; }
                ;
                static toiSlop_$LI$() { if (Settings.toiSlop == null)
                    Settings.toiSlop = Math.fround(8.0 * Settings.linearSlop_$LI$()); return Settings.toiSlop; }
                ;
                static maxLinearVelocitySquared_$LI$() { if (Settings.maxLinearVelocitySquared == null)
                    Settings.maxLinearVelocitySquared = Math.fround(Settings.maxLinearVelocity * Settings.maxLinearVelocity); return Settings.maxLinearVelocitySquared; }
                ;
                static maxAngularVelocitySquared_$LI$() { if (Settings.maxAngularVelocitySquared == null)
                    Settings.maxAngularVelocitySquared = Math.fround(Settings.maxAngularVelocity * Settings.maxAngularVelocity); return Settings.maxAngularVelocitySquared; }
                ;
            }
            /**
             * A "close to zero" float epsilon value for use
             */
            Settings.EPSILON = 1.1920929E-7;
            /**
             * needs to be final, or will slow down math methods
             */
            Settings.FAST_MATH = true;
            Settings.SINCOS_LUT_ENABLED = true;
            /**
             * smaller the precision, the larger the table.  If
             * a small table is used (eg, precision is .006 or greater),
             * make sure you set the table to lerp it's results.  Accuracy chart
             * is in the MathUtils source.  Or, run the tests
             * yourself in {@link org.jbox2d.testbed.mathtests.SinCosTest}.</br>
             * </br>
             * Good lerp precision values:
             * <ul><li>.0092</li>
             * <li>.008201</li>
             * <li>.005904</li>
             * <li>.005204</li>
             * <li>.004305</li>
             * <li>.002807</li>
             * <li>.001508</li>
             * <li>9.32500E-4</li>
             * <li>7.48000E-4</li>
             * <li>8.47000E-4</li>
             * <li>.0005095</li>
             * <li>.0001098</li>
             * <li>9.50499E-5</li>
             * <li>6.08500E-5</li>
             * <li>3.07000E-5</li>
             * <li>1.53999E-5</li></ul>
             *
             */
            Settings.SINCOS_LUT_PRECISION = 0.00131;
            /**
             * Use if the table's precision is large (eg .006 or greater).
             * Although it is more expensive, it greatly increases
             * accuracy.  Look in the MathUtils source for some test results
             * on the accuracy and speed of lerp vs non lerp.  Or, run the tests
             * yourself in {@link org.jbox2d.testbed.mathtests.SinCosTest}.
             */
            Settings.SINCOS_LUT_LERP = false;
            Settings.lengthUnitsPerMeter = 1.0;
            Settings.massUnitsPerKilogram = 1.0;
            Settings.timeUnitsPerSecond = 1.0;
            Settings.maxManifoldPoints = 2;
            Settings.maxShapesPerBody = 64;
            Settings.maxPolygonVertices = 8;
            /**
             * Must be a power of two.
             */
            Settings.maxProxies = 2048;
            /**
             * This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
             * that overlap is removed in one time step. However using values close to 1 often lead
             * to overshoot.
             */
            Settings.contactBaumgarte = 0.2;
            /**
             * The maximum linear velocity of a body. This limit is very large and is used
             * to prevent numerical problems. You shouldn't need to adjust this.
             */
            Settings.maxLinearVelocity = 200.0;
            /**
             * The maximum angular velocity of a body. This limit is very large and is used
             * to prevent numerical problems. You shouldn't need to adjust this.
             */
            Settings.maxAngularVelocity = 250.0;
            /**
             * Maximum number of contacts to be handled to solve a TOI island.
             */
            Settings.maxTOIContactsPerIsland = 32;
            /**
             * Maximum number of joints to be handled to solve a TOI island.
             */
            Settings.maxTOIJointsPerIsland = 0;
            common.Settings = Settings;
            Settings["__class"] = "org.jbox2d.common.Settings";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * Primarily for internal use.
             * <BR><BR>
             * Describes the motion of a body/shape for TOI computation.
             * Shapes are defined with respect to the body origin, which may
             * not coincide with the center of mass. However, to support dynamics
             * we must interpolate the center of mass position.
             *
             * @class
             */
            class Sweep {
                constructor() {
                    if (this.localCenter === undefined)
                        this.localCenter = null;
                    if (this.c0 === undefined)
                        this.c0 = null;
                    if (this.c === undefined)
                        this.c = null;
                    if (this.a0 === undefined)
                        this.a0 = 0;
                    if (this.a === undefined)
                        this.a = 0;
                    if (this.t0 === undefined)
                        this.t0 = 0;
                    this.localCenter = new org.jbox2d.common.Vec2();
                    this.c0 = new org.jbox2d.common.Vec2();
                    this.c = new org.jbox2d.common.Vec2();
                }
                toString() {
                    let s = "Sweep:\nlocalCenter: " + this.localCenter + "\n";
                    s += "c0: " + this.c0 + ", c: " + this.c + "\n";
                    s += "a0: " + this.a0 + ", a: " + this.a + "\n";
                    s += "t0: " + this.t0 + "\n";
                    return s;
                }
                set(argCloneFrom) {
                    this.localCenter.set$org_jbox2d_common_Vec2(argCloneFrom.localCenter);
                    this.c0.set$org_jbox2d_common_Vec2(argCloneFrom.c0);
                    this.c.set$org_jbox2d_common_Vec2(argCloneFrom.c);
                    this.a0 = argCloneFrom.a0;
                    this.a = argCloneFrom.a;
                    this.t0 = argCloneFrom.t0;
                    return this;
                }
                /**
                 * Get the interpolated transform at a specific time.
                 * @param {org.jbox2d.common.XForm} xf the result is placed here - must not be null
                 * @param {number} t the normalized time in [0,1].
                 */
                getXForm(xf, t) {
                    if (Math.fround(1.0 - this.t0) > org.jbox2d.common.Settings.EPSILON) {
                        let alpha = Math.fround((Math.fround(t - this.t0)) / (Math.fround(1.0 - this.t0)));
                        xf.position.x = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.c0.x) + Math.fround(alpha * this.c.x));
                        xf.position.y = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.c0.y) + Math.fround(alpha * this.c.y));
                        let angle = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.a0) + Math.fround(alpha * this.a));
                        xf.R.set$float(angle);
                    }
                    else {
                        xf.position.set$org_jbox2d_common_Vec2(this.c);
                        xf.R.set$float(this.a);
                    }
                    xf.position.x -= Math.fround(Math.fround(xf.R.col1.x * this.localCenter.x) + Math.fround(xf.R.col2.x * this.localCenter.y));
                    xf.position.y -= Math.fround(Math.fround(xf.R.col1.y * this.localCenter.x) + Math.fround(xf.R.col2.y * this.localCenter.y));
                }
                /**
                 *
                 * Advance the sweep forward, yielding a new initial state.
                 * @param {number} t the new initial time.
                 */
                advance(t) {
                    if (this.t0 < t && Math.fround(1.0 - this.t0) > org.jbox2d.common.Settings.EPSILON) {
                        let alpha = Math.fround((Math.fround(t - this.t0)) / (Math.fround(1.0 - this.t0)));
                        this.c0.x = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.c0.x) + Math.fround(alpha * this.c.x));
                        this.c0.y = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.c0.y) + Math.fround(alpha * this.c.y));
                        this.a0 = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * this.a0) + Math.fround(alpha * this.a));
                        this.t0 = t;
                    }
                }
            }
            common.Sweep = Sweep;
            Sweep["__class"] = "org.jbox2d.common.Sweep";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * A 2-dimensional vector class.  Used heavily in JBox2d.
             * djm: added ToOut methods
             * @param {number} x
             * @param {number} y
             * @class
             */
            class Vec2 {
                constructor(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        let __args = arguments;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        (() => {
                            if (Vec2.watchCreations) {
                                ++Vec2.creationCount;
                            }
                            this.x = x;
                            this.y = y;
                        })();
                    }
                    else if (((x != null && x instanceof org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                        let __args = arguments;
                        let toCopy = __args[0];
                        {
                            let __args = arguments;
                            let x = toCopy.x;
                            let y = toCopy.y;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            (() => {
                                if (Vec2.watchCreations) {
                                    ++Vec2.creationCount;
                                }
                                this.x = x;
                                this.y = y;
                            })();
                        }
                    }
                    else if (x === undefined && y === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let x = 0;
                            let y = 0;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            (() => {
                                if (Vec2.watchCreations) {
                                    ++Vec2.creationCount;
                                }
                                this.x = x;
                                this.y = y;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Zero out this vector.
                 */
                setZero() {
                    this.x = 0.0;
                    this.y = 0.0;
                }
                set$float$float(x, y) {
                    this.x = x;
                    this.y = y;
                }
                /**
                 * Set the vector component-wise.
                 * @param {number} x
                 * @param {number} y
                 */
                set(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.set$float$float(x, y);
                    }
                    else if (((x != null && x instanceof org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                        return this.set$org_jbox2d_common_Vec2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                set$org_jbox2d_common_Vec2(v) {
                    this.x = v.x;
                    this.y = v.y;
                    return this;
                }
                /**
                 * Return the sum of this vector and another; does not alter either one.
                 * @param {org.jbox2d.common.Vec2} v
                 * @return {org.jbox2d.common.Vec2}
                 */
                add(v) {
                    return new Vec2(Math.fround(this.x + v.x), Math.fround(this.y + v.y));
                }
                /**
                 * Return the difference of this vector and another; does not alter either one.
                 * @param {org.jbox2d.common.Vec2} v
                 * @return {org.jbox2d.common.Vec2}
                 */
                sub(v) {
                    return new Vec2(Math.fround(this.x - v.x), Math.fround(this.y - v.y));
                }
                /**
                 * Return this vector multiplied by a scalar; does not alter this vector.
                 * @param {number} a
                 * @return {org.jbox2d.common.Vec2}
                 */
                mul(a) {
                    return new Vec2(Math.fround(this.x * a), Math.fround(this.y * a));
                }
                /**
                 * Return the negation of this vector; does not alter this vector.
                 * @return {org.jbox2d.common.Vec2}
                 */
                negate() {
                    return new Vec2(-this.x, -this.y);
                }
                /**
                 * Flip the vector and return it - alters this vector.
                 * @return {org.jbox2d.common.Vec2}
                 */
                negateLocal() {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                }
                addLocal$org_jbox2d_common_Vec2(v) {
                    this.x += v.x;
                    this.y += v.y;
                    return this;
                }
                addLocal$float$float(x, y) {
                    this.x += x;
                    this.y += y;
                    return this;
                }
                /**
                 * Adds values to this vector and returns result - alters this vector.
                 * @param {number} x
                 * @param {number} y
                 * @return {org.jbox2d.common.Vec2}
                 */
                addLocal(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.addLocal$float$float(x, y);
                    }
                    else if (((x != null && x instanceof org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                        return this.addLocal$org_jbox2d_common_Vec2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Subtract another vector from this one and return result - alters this vector.
                 * @param {org.jbox2d.common.Vec2} v
                 * @return {org.jbox2d.common.Vec2}
                 */
                subLocal(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    return this;
                }
                /**
                 * Multiply this vector by a number and return result - alters this vector.
                 * @param {number} a
                 * @return {org.jbox2d.common.Vec2}
                 */
                mulLocal(a) {
                    this.x *= a;
                    this.y *= a;
                    return this;
                }
                /**
                 * Return the length of this vector.
                 * @return {number}
                 */
                length() {
                    return org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(this.x * this.x) + Math.fround(this.y * this.y)));
                }
                /**
                 * Return the squared length of this vector.
                 * @return {number}
                 */
                lengthSquared() {
                    return (Math.fround(Math.fround(this.x * this.x) + Math.fround(this.y * this.y)));
                }
                /**
                 * Normalize this vector and return the length before normalization.  Alters this vector.
                 * @return {number}
                 */
                normalize() {
                    let length = this.length();
                    if (length < org.jbox2d.common.Settings.EPSILON) {
                        return 0.0;
                    }
                    let invLength = Math.fround(1.0 / length);
                    this.x *= invLength;
                    this.y *= invLength;
                    return length;
                }
                /**
                 * True if the vector represents a pair of valid, non-infinite floating point numbers.
                 * @return {boolean}
                 */
                isValid() {
                    return this.x !== NaN && this.x !== -Infinity && this.x !== Infinity && this.y !== NaN && this.y !== -Infinity && this.y !== Infinity;
                }
                /**
                 * Return a new vector that has positive components.
                 * @return {org.jbox2d.common.Vec2}
                 */
                abs() {
                    return new Vec2(org.jbox2d.common.MathUtils.abs(this.x), org.jbox2d.common.MathUtils.abs(this.y));
                }
                absLocal() {
                    this.x = org.jbox2d.common.MathUtils.abs(this.x);
                    this.y = org.jbox2d.common.MathUtils.abs(this.y);
                }
                /**
                 *
                 * @return {org.jbox2d.common.Vec2}
                 */
                clone() {
                    return new Vec2(this.x, this.y);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "(" + this.x + "," + this.y + ")";
                }
                static abs(a) {
                    return new Vec2(org.jbox2d.common.MathUtils.abs(a.x), org.jbox2d.common.MathUtils.abs(a.y));
                }
                static absToOut(a, out) {
                    out.x = org.jbox2d.common.MathUtils.abs(a.x);
                    out.y = org.jbox2d.common.MathUtils.abs(a.y);
                }
                static dot(a, b) {
                    return Math.fround(Math.fround(a.x * b.x) + Math.fround(a.y * b.y));
                }
                static cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b) {
                    return Math.fround(Math.fround(a.x * b.y) - Math.fround(a.y * b.x));
                }
                static cross(a, b) {
                    if (((a != null && a instanceof org.jbox2d.common.Vec2) || a === null) && ((b != null && b instanceof org.jbox2d.common.Vec2) || b === null)) {
                        return org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, b);
                    }
                    else if (((a != null && a instanceof org.jbox2d.common.Vec2) || a === null) && ((typeof b === 'number') || b === null)) {
                        return org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(a, b);
                    }
                    else if (((typeof a === 'number') || a === null) && ((b != null && b instanceof org.jbox2d.common.Vec2) || b === null)) {
                        return org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(a, b);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static cross$org_jbox2d_common_Vec2$float(a, s) {
                    return new Vec2(Math.fround(s * a.y), Math.fround(-s * a.x));
                }
                static crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a, s, out) {
                    let tempy = Math.fround(-s * a.x);
                    out.x = Math.fround(s * a.y);
                    out.y = tempy;
                }
                static crossToOut(a, s, out) {
                    if (((a != null && a instanceof org.jbox2d.common.Vec2) || a === null) && ((typeof s === 'number') || s === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(a, s, out);
                    }
                    else if (((typeof a === 'number') || a === null) && ((s != null && s instanceof org.jbox2d.common.Vec2) || s === null) && ((out != null && out instanceof org.jbox2d.common.Vec2) || out === null)) {
                        return org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, s, out);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static cross$float$org_jbox2d_common_Vec2(s, a) {
                    return new Vec2(Math.fround(-s * a.y), Math.fround(s * a.x));
                }
                static crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(s, a, out) {
                    let tempY = Math.fround(s * a.x);
                    out.x = Math.fround(-s * a.y);
                    out.y = tempY;
                }
                static negateToOut(a, out) {
                    out.x = -a.x;
                    out.y = -a.y;
                }
                static min(a, b) {
                    return new Vec2(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y);
                }
                static max(a, b) {
                    return new Vec2(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y);
                }
                static minToOut(a, b, out) {
                    out.x = a.x < b.x ? a.x : b.x;
                    out.y = a.y < b.y ? a.y : b.y;
                }
                static maxToOut(a, b, out) {
                    out.x = a.x > b.x ? a.x : b.x;
                    out.y = a.y > b.y ? a.y : b.y;
                }
                /**
                 * @see java.lang.Object#hashCode()
                 * @return {number}
                 */
                hashCode() {
                    let prime = 31;
                    let result = 1;
                    result = prime * result + ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.x);
                    result = prime * result + ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.y);
                    return result;
                }
                /**
                 * @see java.lang.Object#equals(java.lang.Object)
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (this === obj)
                        return true;
                    if (obj == null)
                        return false;
                    if (this.constructor !== obj.constructor)
                        return false;
                    let other = obj;
                    if (((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.x) !== ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(other.x))
                        return false;
                    if (((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.y) !== ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(other.y))
                        return false;
                    return true;
                }
            }
            /**
             * Should we count Vec2 creations?
             */
            Vec2.watchCreations = true;
            /**
             * Running count of Vec2 creations.  Must be zeroed out
             * manually (perhaps at start of time step).  Incremented
             * in Vec2 constructor if watchCreations flag is true.
             * <BR><BR>
             * Mainly used for optimization purposes, since temporary
             * Vec2 creation is often a bottleneck.
             */
            Vec2.creationCount = 0;
            common.Vec2 = Vec2;
            Vec2["__class"] = "org.jbox2d.common.Vec2";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            class Vec3 {
                constructor(argX, argY, argZ) {
                    if (((typeof argX === 'number') || argX === null) && ((typeof argY === 'number') || argY === null) && ((typeof argZ === 'number') || argZ === null)) {
                        let __args = arguments;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        (() => {
                            this.x = argX;
                            this.y = argY;
                            this.z = argZ;
                        })();
                    }
                    else if (((argX != null && argX instanceof org.jbox2d.common.Vec3) || argX === null) && argY === undefined && argZ === undefined) {
                        let __args = arguments;
                        let argCopy = __args[0];
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        (() => {
                            this.x = argCopy.x;
                            this.y = argCopy.y;
                            this.z = argCopy.z;
                        })();
                    }
                    else if (argX === undefined && argY === undefined && argZ === undefined) {
                        let __args = arguments;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        if (this.x === undefined)
                            this.x = 0;
                        if (this.y === undefined)
                            this.y = 0;
                        if (this.z === undefined)
                            this.z = 0;
                        (() => {
                            this.x = this.y = this.z = 0.0;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                set(argVec) {
                    this.x = argVec.x;
                    this.y = argVec.y;
                    this.z = argVec.z;
                }
                addLocal(argVec) {
                    this.x += argVec.x;
                    this.y += argVec.y;
                    this.z += argVec.z;
                    return this;
                }
                add(argVec) {
                    return new Vec3(Math.fround(this.x + argVec.x), Math.fround(this.y + argVec.y), Math.fround(this.z + argVec.z));
                }
                subLocal(argVec) {
                    this.x -= argVec.x;
                    this.y -= argVec.y;
                    this.z -= argVec.z;
                    return this;
                }
                sub(argVec) {
                    return new Vec3(Math.fround(this.x - argVec.x), Math.fround(this.y - argVec.y), Math.fround(this.z - argVec.z));
                }
                mulLocal(argScalar) {
                    this.x *= argScalar;
                    this.y *= argScalar;
                    this.z *= argScalar;
                    return this;
                }
                mul(argScalar) {
                    return new Vec3(Math.fround(this.x * argScalar), Math.fround(this.y * argScalar), Math.fround(this.z * argScalar));
                }
                negate() {
                    return new Vec3(-this.x, -this.y, -this.z);
                }
                negateLocal() {
                    this.x *= -1;
                    this.y *= -1;
                    this.z *= -1;
                    return this;
                }
                setZero() {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                }
                clone() {
                    return new Vec3(this);
                }
                /**
                 * @see java.lang.Object#hashCode()
                 * @return {number}
                 */
                hashCode() {
                    let prime = 31;
                    let result = 1;
                    result = prime * result + ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.x);
                    result = prime * result + ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.y);
                    result = prime * result + ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.z);
                    return result;
                }
                /**
                 * @see java.lang.Object#equals(java.lang.Object)
                 * @param {*} obj
                 * @return {boolean}
                 */
                equals(obj) {
                    if (this === obj)
                        return true;
                    if (obj == null)
                        return false;
                    if (this.constructor !== obj.constructor)
                        return false;
                    let other = obj;
                    if (((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.x) !== ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(other.x))
                        return false;
                    if (((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.y) !== ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(other.y))
                        return false;
                    if (((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(this.z) !== ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(other.z))
                        return false;
                    return true;
                }
                static dot(a, b) {
                    return Math.fround(Math.fround(Math.fround(a.x * b.x) + Math.fround(a.y * b.y)) + Math.fround(a.z * b.z));
                }
                static cross(a, b) {
                    return new Vec3(Math.fround(Math.fround(a.y * b.z) - Math.fround(a.z * b.y)), Math.fround(Math.fround(a.z * b.x) - Math.fround(a.x * b.z)), Math.fround(Math.fround(a.x * b.y) - Math.fround(a.y * b.x)));
                }
                static crossToOut(a, b, out) {
                    let tempy = Math.fround(Math.fround(a.z * b.x) - Math.fround(a.x * b.z));
                    let tempz = Math.fround(Math.fround(a.x * b.y) - Math.fround(a.y * b.x));
                    out.x = Math.fround(Math.fround(a.y * b.z) - Math.fround(a.z * b.y));
                    out.y = tempy;
                    out.z = tempz;
                }
            }
            common.Vec3 = Vec3;
            Vec3["__class"] = "org.jbox2d.common.Vec3";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * Initialize using a position vector and a rotation matrix.
             * @param {org.jbox2d.common.Vec2} _position
             * @param {org.jbox2d.common.Mat22} _R
             * @class
             */
            class XForm {
                constructor(_position, _R) {
                    if (((_position != null && _position instanceof org.jbox2d.common.Vec2) || _position === null) && ((_R != null && _R instanceof org.jbox2d.common.Mat22) || _R === null)) {
                        let __args = arguments;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        (() => {
                            this.position = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_position);
                            this.R = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(_R);
                        })();
                    }
                    else if (((_position != null && _position instanceof org.jbox2d.common.XForm) || _position === null) && _R === undefined) {
                        let __args = arguments;
                        let xf = __args[0];
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        (() => {
                            this.position = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(xf.position);
                            this.R = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(xf.R);
                        })();
                    }
                    else if (_position === undefined && _R === undefined) {
                        let __args = arguments;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.R === undefined)
                            this.R = null;
                        (() => {
                            this.position = new org.jbox2d.common.Vec2();
                            this.R = new org.jbox2d.common.Mat22();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                static __static_initialize() { if (!XForm.__static_initialized) {
                    XForm.__static_initialized = true;
                    XForm.__static_initializer_0();
                } }
                static identity_$LI$() { XForm.__static_initialize(); return XForm.identity; }
                ;
                static __static_initializer_0() {
                    XForm.identity = new XForm();
                    XForm.identity_$LI$().setIdentity();
                }
                /**
                 * Set this to equal another transform.
                 * @param {org.jbox2d.common.XForm} xf
                 * @return {org.jbox2d.common.XForm}
                 */
                set(xf) {
                    this.position.set$org_jbox2d_common_Vec2(xf.position);
                    this.R.set$org_jbox2d_common_Mat22(xf.R);
                    return this;
                }
                /**
                 * Set this to the identity transform.
                 */
                setIdentity() {
                    this.position.setZero();
                    this.R.setIdentity();
                }
                static mul(T, v) {
                    return new org.jbox2d.common.Vec2(Math.fround(Math.fround(T.position.x + Math.fround(T.R.col1.x * v.x)) + Math.fround(T.R.col2.x * v.y)), Math.fround(Math.fround(T.position.y + Math.fround(T.R.col1.y * v.x)) + Math.fround(T.R.col2.y * v.y)));
                }
                static mulToOut(T, v, out) {
                    let tempy = Math.fround(Math.fround(T.position.y + Math.fround(T.R.col1.y * v.x)) + Math.fround(T.R.col2.y * v.y));
                    out.x = Math.fround(Math.fround(T.position.x + Math.fround(T.R.col1.x * v.x)) + Math.fround(T.R.col2.x * v.y));
                    out.y = tempy;
                }
                static mulTrans(T, v) {
                    let v1x = Math.fround(v.x - T.position.x);
                    let v1y = Math.fround(v.y - T.position.y);
                    let b = T.R.col1;
                    let b1 = T.R.col2;
                    return new org.jbox2d.common.Vec2((Math.fround(Math.fround(v1x * b.x) + Math.fround(v1y * b.y))), (Math.fround(Math.fround(v1x * b1.x) + Math.fround(v1y * b1.y))));
                }
                static mulTransToOut(T, v, out) {
                    let v1x = Math.fround(v.x - T.position.x);
                    let v1y = Math.fround(v.y - T.position.y);
                    let b = T.R.col1;
                    let b1 = T.R.col2;
                    let tempy = Math.fround(Math.fround(v1x * b1.x) + Math.fround(v1y * b1.y));
                    out.x = Math.fround(Math.fround(v1x * b.x) + Math.fround(v1y * b.y));
                    out.y = tempy;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    let s = "XForm:\n";
                    s += "Position: " + this.position + "\n";
                    s += "R: \n" + this.R + "\n";
                    return s;
                }
            }
            XForm.__static_initialized = false;
            common.XForm = XForm;
            XForm["__class"] = "org.jbox2d.common.XForm";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default body definition.  Defines a body with the following characteristics:
             * <UL>
             * <LI>Zero mass/inertia (you can set this later on the Body with setMassFromShapes)
             * <LI>null userData
             * <LI>Position of (0.0f, 0.0f)
             * <LI>Zero rotation
             * <LI>Zero damping (linear + angular)
             * <LI>Able to sleep, but not sleeping to start
             * <LI>Able to rotate
             * <LI>Not a bullet
             * </UL>
             * @class
             */
            class BodyDef {
                constructor() {
                    if (this.massData === undefined)
                        this.massData = null;
                    if (this.userData === undefined)
                        this.userData = null;
                    if (this.position === undefined)
                        this.position = null;
                    if (this.angle === undefined)
                        this.angle = 0;
                    if (this.linearDamping === undefined)
                        this.linearDamping = 0;
                    if (this.angularDamping === undefined)
                        this.angularDamping = 0;
                    if (this.allowSleep === undefined)
                        this.allowSleep = false;
                    if (this.isSleeping === undefined)
                        this.isSleeping = false;
                    if (this.fixedRotation === undefined)
                        this.fixedRotation = false;
                    if (this.isBullet === undefined)
                        this.isBullet = false;
                    this.massData = new org.jbox2d.collision.MassData();
                    this.massData.center.setZero();
                    this.massData.mass = 0.0;
                    this.massData.I = 0.0;
                    this.userData = null;
                    this.position = new org.jbox2d.common.Vec2(0.0, 0.0);
                    this.angle = 0.0;
                    this.linearDamping = 0.0;
                    this.angularDamping = 0.0;
                    this.allowSleep = true;
                    this.isSleeping = false;
                    this.fixedRotation = false;
                    this.isBullet = false;
                }
            }
            dynamics.BodyDef = BodyDef;
            BodyDef["__class"] = "org.jbox2d.dynamics.BodyDef";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Create a BodyGroup from a group of bodies.
             * @param {Array} bodies
             * @class
             * @author eric
             */
            class BodyGroup {
                constructor(...bodies) {
                    /*private*/ this.children = ([]);
                    /*private*/ this.bodies = ([]);
                    if (((bodies != null && bodies instanceof Array && (bodies.length == 0 || bodies[0] == null || (bodies[0] != null && bodies[0] instanceof org.jbox2d.dynamics.Body))) || bodies === null)) {
                        let __args = arguments;
                        if (this.world === undefined)
                            this.world = null;
                        this.children = ([]);
                        this.bodies = ([]);
                        if (this.world === undefined)
                            this.world = null;
                        (() => {
                            let w = null;
                            for (let index124 = 0; index124 < bodies.length; index124++) {
                                let b = bodies[index124];
                                {
                                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                        s.push(e);
                                        return true;
                                    }
                                    else {
                                        return false;
                                    } })(this.bodies, b);
                                    if (w == null) {
                                        w = b.getWorld();
                                    }
                                }
                            }
                            this.world = w;
                        })();
                    }
                    else if (((bodies != null && bodies instanceof Array && (bodies.length == 0 || bodies[0] == null || (bodies[0] != null && bodies[0] instanceof org.jbox2d.dynamics.BodyGroup))) || bodies === null)) {
                        let __args = arguments;
                        let groups = __args[0];
                        if (this.world === undefined)
                            this.world = null;
                        this.children = ([]);
                        this.bodies = ([]);
                        if (this.world === undefined)
                            this.world = null;
                        (() => {
                            let w = null;
                            for (let index125 = 0; index125 < groups.length; index125++) {
                                let bg = groups[index125];
                                {
                                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                        s.push(e);
                                        return true;
                                    }
                                    else {
                                        return false;
                                    } })(this.children, bg);
                                    if (w == null) {
                                        w = bg.getWorld();
                                    }
                                }
                            }
                            this.world = w;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Get child BodyGroups. Does not return children-of-children.
                 * @return {org.jbox2d.dynamics.BodyGroup[]}
                 */
                getChildren() {
                    return this.children;
                }
                /**
                 *
                 * Get bodies. Does not return bodies that are members of child BodyGroups.
                 * @see #getBodiesDeep()
                 * @return {org.jbox2d.dynamics.Body[]}
                 */
                getBodies() {
                    return this.bodies;
                }
                /**
                 *
                 * Get all bodies in this group and all children, recursively.
                 * @see #getBodies() for non-recursive version
                 * @return {org.jbox2d.dynamics.Body[]}
                 */
                getBodiesDeep() {
                    let res = ([]);
                    /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(res, this.bodies);
                    for (let index126 = 0; index126 < this.children.length; index126++) {
                        let bg = this.children[index126];
                        {
                            /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(res, bg.getBodiesDeep());
                        }
                    }
                    return res;
                }
                /**
                 * @return {org.jbox2d.dynamics.World} the world this BodyGroup lives in
                 */
                getWorld() {
                    return this.world;
                }
                /**
                 * Create a BodyGroup by traversing the joint tree from a seed body.
                 * @param {org.jbox2d.dynamics.Body} seed
                 * @return {org.jbox2d.dynamics.BodyGroup}
                 */
                static fromSeedConnectedByJoints(seed) {
                    let bodies = seed.getConnectedDynamicBodyIsland();
                    return new (__Function.prototype.bind.apply(BodyGroup, [null].concat(bodies.slice(0))));
                }
            }
            dynamics.BodyGroup = BodyGroup;
            BodyGroup["__class"] = "org.jbox2d.dynamics.BodyGroup";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var BoundaryResponse;
            (function (BoundaryResponse) {
                BoundaryResponse[BoundaryResponse["FREEZE_BODY"] = 0] = "FREEZE_BODY";
                BoundaryResponse[BoundaryResponse["DESTROY_BODY"] = 1] = "DESTROY_BODY";
            })(BoundaryResponse = dynamics.BoundaryResponse || (dynamics.BoundaryResponse = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                /**
                 * Base class for contacts between shapes.
                 * @author ewjordan
                 * @param {org.jbox2d.collision.shapes.Shape} s1
                 * @param {org.jbox2d.collision.shapes.Shape} s2
                 * @class
                 */
                class Contact {
                    constructor(s1, s2) {
                        if (((s1 != null && s1 instanceof org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                if (this.m_world === undefined)
                                    this.m_world = null;
                                if (this.m_prev === undefined)
                                    this.m_prev = null;
                                if (this.m_next === undefined)
                                    this.m_next = null;
                                if (this.m_node1 === undefined)
                                    this.m_node1 = null;
                                if (this.m_node2 === undefined)
                                    this.m_node2 = null;
                                if (this.m_shape1 === undefined)
                                    this.m_shape1 = null;
                                if (this.m_shape2 === undefined)
                                    this.m_shape2 = null;
                                if (this.m_friction === undefined)
                                    this.m_friction = 0;
                                if (this.m_restitution === undefined)
                                    this.m_restitution = 0;
                                if (this.m_flags === undefined)
                                    this.m_flags = 0;
                                if (this.m_manifoldCount === undefined)
                                    this.m_manifoldCount = 0;
                                if (this.m_toi === undefined)
                                    this.m_toi = 0;
                                if (this.m_world === undefined)
                                    this.m_world = null;
                                if (this.m_prev === undefined)
                                    this.m_prev = null;
                                if (this.m_next === undefined)
                                    this.m_next = null;
                                if (this.m_node1 === undefined)
                                    this.m_node1 = null;
                                if (this.m_node2 === undefined)
                                    this.m_node2 = null;
                                if (this.m_shape1 === undefined)
                                    this.m_shape1 = null;
                                if (this.m_shape2 === undefined)
                                    this.m_shape2 = null;
                                if (this.m_friction === undefined)
                                    this.m_friction = 0;
                                if (this.m_restitution === undefined)
                                    this.m_restitution = 0;
                                if (this.m_flags === undefined)
                                    this.m_flags = 0;
                                if (this.m_manifoldCount === undefined)
                                    this.m_manifoldCount = 0;
                                if (this.m_toi === undefined)
                                    this.m_toi = 0;
                                (() => {
                                    this.m_node1 = new org.jbox2d.dynamics.contacts.ContactEdge();
                                    this.m_node2 = new org.jbox2d.dynamics.contacts.ContactEdge();
                                })();
                            }
                            (() => {
                                this.m_flags = 0;
                                if (s1.isSensor() || s2.isSensor()) {
                                    this.m_flags |= Contact.e_nonSolidFlag;
                                }
                                this.m_shape1 = s1;
                                this.m_shape2 = s2;
                                this.m_manifoldCount = 0;
                                this.m_friction = org.jbox2d.common.MathUtils.sqrt(Math.fround(this.m_shape1.m_friction * this.m_shape2.m_friction));
                                this.m_restitution = org.jbox2d.common.MathUtils.max$float$float(this.m_shape1.m_restitution, this.m_shape2.m_restitution);
                                this.m_prev = null;
                                this.m_next = null;
                                this.m_node1.contact = null;
                                this.m_node1.prev = null;
                                this.m_node1.next = null;
                                this.m_node1.other = null;
                                this.m_node2.contact = null;
                                this.m_node2.prev = null;
                                this.m_node2.next = null;
                                this.m_node2.other = null;
                            })();
                        }
                        else if (s1 === undefined && s2 === undefined) {
                            let __args = arguments;
                            if (this.m_world === undefined)
                                this.m_world = null;
                            if (this.m_prev === undefined)
                                this.m_prev = null;
                            if (this.m_next === undefined)
                                this.m_next = null;
                            if (this.m_node1 === undefined)
                                this.m_node1 = null;
                            if (this.m_node2 === undefined)
                                this.m_node2 = null;
                            if (this.m_shape1 === undefined)
                                this.m_shape1 = null;
                            if (this.m_shape2 === undefined)
                                this.m_shape2 = null;
                            if (this.m_friction === undefined)
                                this.m_friction = 0;
                            if (this.m_restitution === undefined)
                                this.m_restitution = 0;
                            if (this.m_flags === undefined)
                                this.m_flags = 0;
                            if (this.m_manifoldCount === undefined)
                                this.m_manifoldCount = 0;
                            if (this.m_toi === undefined)
                                this.m_toi = 0;
                            if (this.m_world === undefined)
                                this.m_world = null;
                            if (this.m_prev === undefined)
                                this.m_prev = null;
                            if (this.m_next === undefined)
                                this.m_next = null;
                            if (this.m_node1 === undefined)
                                this.m_node1 = null;
                            if (this.m_node2 === undefined)
                                this.m_node2 = null;
                            if (this.m_shape1 === undefined)
                                this.m_shape1 = null;
                            if (this.m_shape2 === undefined)
                                this.m_shape2 = null;
                            if (this.m_friction === undefined)
                                this.m_friction = 0;
                            if (this.m_restitution === undefined)
                                this.m_restitution = 0;
                            if (this.m_flags === undefined)
                                this.m_flags = 0;
                            if (this.m_manifoldCount === undefined)
                                this.m_manifoldCount = 0;
                            if (this.m_toi === undefined)
                                this.m_toi = 0;
                            (() => {
                                this.m_node1 = new org.jbox2d.dynamics.contacts.ContactEdge();
                                this.m_node2 = new org.jbox2d.dynamics.contacts.ContactEdge();
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Get the number of manifolds. This is 0 or 1 between convex shapes.
                     * This may be greater than 1 for convex-vs-concave shapes. Each
                     * manifold holds up to two contact points with a shared contact normal.
                     * @return {number}
                     */
                    getManifoldCount() {
                        return this.m_manifoldCount;
                    }
                    isSolid() {
                        return (this.m_flags & Contact.e_nonSolidFlag) === 0;
                    }
                    getNext() {
                        return this.m_next;
                    }
                    getShape1() {
                        return this.m_shape1;
                    }
                    getShape2() {
                        return this.m_shape2;
                    }
                    update(listener) {
                        let oldCount = this.getManifoldCount();
                        this.evaluate(listener);
                        let newCount = this.getManifoldCount();
                        let body1 = this.m_shape1.getBody();
                        let body2 = this.m_shape2.getBody();
                        if (newCount === 0 && oldCount > 0) {
                            body1.wakeUp();
                            body2.wakeUp();
                        }
                        if (body1.isStatic() || body1.isBullet() || body2.isStatic() || body2.isBullet()) {
                            this.m_flags &= ~Contact.e_slowFlag;
                        }
                        else {
                            this.m_flags |= Contact.e_slowFlag;
                        }
                    }
                    static initializeRegisters() {
                        Contact.s_registers = ([]);
                        Contact.addType(new org.jbox2d.dynamics.contacts.CircleContact(), org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.PolyAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.PolyContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.PolyAndEdgeContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.EdgeAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.PointAndCircleContact(), org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE, org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE);
                        Contact.addType(new org.jbox2d.dynamics.contacts.PointAndPolyContact(), org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE, org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE);
                    }
                    static addType(createFcn, type1, type2) {
                        let cr = new org.jbox2d.dynamics.contacts.ContactRegister();
                        cr.s1 = type1;
                        cr.s2 = type2;
                        cr.createFcn = createFcn;
                        cr.primary = true;
                        /* add */ (Contact.s_registers.push(cr) > 0);
                        if (type1 !== type2) {
                            let cr2 = new org.jbox2d.dynamics.contacts.ContactRegister();
                            cr2.s2 = type1;
                            cr2.s1 = type2;
                            cr2.createFcn = createFcn;
                            cr2.primary = false;
                            /* add */ (Contact.s_registers.push(cr2) > 0);
                        }
                    }
                    static createContact(shape1, shape2) {
                        if (Contact.s_initialized === false) {
                            Contact.initializeRegisters();
                            Contact.s_initialized = true;
                        }
                        let type1 = shape1.m_type;
                        let type2 = shape2.m_type;
                        let register = Contact.getContactRegister(type1, type2);
                        if (register != null) {
                            if (register.primary) {
                                return register.createFcn.create(shape1, shape2);
                            }
                            else {
                                let c = register.createFcn.create(shape2, shape1);
                                for (let i = 0; i < c.getManifoldCount(); ++i) {
                                    {
                                        let m = c.getManifolds()[i];
                                        m.normal.negateLocal();
                                    }
                                    ;
                                }
                                return c;
                            }
                        }
                        else {
                            return null;
                        }
                    }
                    /*private*/ static getContactRegister(type1, type2) {
                        for (let i = 0; i < Contact.s_registers.length; ++i) {
                            {
                                let cr = Contact.s_registers[i];
                                if (cr.s1 === type1 && cr.s2 === type2) {
                                    return cr;
                                }
                            }
                            ;
                        }
                        return null;
                    }
                    static destroy(contact) {
                        if (contact.getManifoldCount() > 0) {
                            contact.getShape1().getBody().wakeUp();
                            contact.getShape2().getBody().wakeUp();
                        }
                    }
                }
                Contact.e_nonSolidFlag = 1;
                Contact.e_slowFlag = 2;
                Contact.e_islandFlag = 4;
                Contact.e_toiFlag = 8;
                Contact.s_registers = null;
                Contact.s_initialized = false;
                contacts.Contact = Contact;
                Contact["__class"] = "org.jbox2d.dynamics.contacts.Contact";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class ContactConstraint {
                    constructor() {
                        if (this.points === undefined)
                            this.points = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.manifold === undefined)
                            this.manifold = null;
                        if (this.body1 === undefined)
                            this.body1 = null;
                        if (this.body2 === undefined)
                            this.body2 = null;
                        if (this.friction === undefined)
                            this.friction = 0;
                        if (this.restitution === undefined)
                            this.restitution = 0;
                        if (this.pointCount === undefined)
                            this.pointCount = 0;
                        this.points = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(org.jbox2d.common.Settings.maxManifoldPoints);
                        for (let i = 0; i < org.jbox2d.common.Settings.maxManifoldPoints; i++) {
                            {
                                this.points[i] = new org.jbox2d.dynamics.contacts.ContactConstraintPoint();
                            }
                            ;
                        }
                        this.pointCount = 0;
                        this.normal = new org.jbox2d.common.Vec2();
                        this.manifold = new org.jbox2d.collision.Manifold();
                    }
                    set(cp) {
                        this.pointCount = cp.pointCount;
                        this.normal.set$org_jbox2d_common_Vec2(cp.normal);
                        this.manifold.set(cp.manifold);
                        this.friction = cp.friction;
                        this.restitution = cp.restitution;
                        this.body1 = cp.body1;
                        this.body2 = cp.body2;
                        for (let i = 0; i < cp.pointCount; i++) {
                            {
                                this.points[i].set(cp.points[i]);
                            }
                            ;
                        }
                    }
                }
                contacts.ContactConstraint = ContactConstraint;
                ContactConstraint["__class"] = "org.jbox2d.dynamics.contacts.ContactConstraint";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class ContactConstraintPoint {
                    constructor() {
                        if (this.localAnchor1 === undefined)
                            this.localAnchor1 = null;
                        if (this.localAnchor2 === undefined)
                            this.localAnchor2 = null;
                        if (this.r1 === undefined)
                            this.r1 = null;
                        if (this.r2 === undefined)
                            this.r2 = null;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.positionImpulse === undefined)
                            this.positionImpulse = 0;
                        if (this.normalMass === undefined)
                            this.normalMass = 0;
                        if (this.tangentMass === undefined)
                            this.tangentMass = 0;
                        if (this.equalizedMass === undefined)
                            this.equalizedMass = 0;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.velocityBias === undefined)
                            this.velocityBias = 0;
                        this.localAnchor1 = new org.jbox2d.common.Vec2();
                        this.localAnchor2 = new org.jbox2d.common.Vec2();
                        this.r1 = new org.jbox2d.common.Vec2();
                        this.r2 = new org.jbox2d.common.Vec2();
                    }
                    set(cp) {
                        this.localAnchor1.set$org_jbox2d_common_Vec2(cp.localAnchor1);
                        this.localAnchor2.set$org_jbox2d_common_Vec2(cp.localAnchor2);
                        this.r1.set$org_jbox2d_common_Vec2(cp.r1);
                        this.r2.set$org_jbox2d_common_Vec2(cp.r2);
                        this.normalImpulse = cp.normalImpulse;
                        this.tangentImpulse = cp.tangentImpulse;
                        this.positionImpulse = cp.positionImpulse;
                        this.normalMass = cp.normalMass;
                        this.tangentMass = cp.tangentMass;
                        this.equalizedMass = cp.equalizedMass;
                        this.separation = cp.separation;
                        this.velocityBias = cp.velocityBias;
                    }
                }
                contacts.ContactConstraintPoint = ContactConstraintPoint;
                ContactConstraintPoint["__class"] = "org.jbox2d.dynamics.contacts.ContactConstraintPoint";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                /**
                 * A contact edge is used to connect bodies and contacts together
                 * in a contact graph where each body is a node and each contact
                 * is an edge. A contact edge belongs to a doubly linked list
                 * maintained in each attached body. Each contact has two contact
                 * nodes, one for each attached body.
                 * @class
                 */
                class ContactEdge {
                    constructor() {
                        if (this.other === undefined)
                            this.other = null;
                        if (this.contact === undefined)
                            this.contact = null;
                        if (this.prev === undefined)
                            this.prev = null;
                        if (this.next === undefined)
                            this.next = null;
                    }
                    set(argToCopy) {
                        this.other = argToCopy.other;
                        this.contact = argToCopy.contact;
                        this.prev = argToCopy.prev;
                        this.next = argToCopy.next;
                    }
                }
                contacts.ContactEdge = ContactEdge;
                ContactEdge["__class"] = "org.jbox2d.dynamics.contacts.ContactEdge";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class ContactPoint {
                    constructor() {
                        if (this.shape1 === undefined)
                            this.shape1 = null;
                        if (this.shape2 === undefined)
                            this.shape2 = null;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.velocity === undefined)
                            this.velocity = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.separation === undefined)
                            this.separation = 0;
                        if (this.friction === undefined)
                            this.friction = 0;
                        if (this.restitution === undefined)
                            this.restitution = 0;
                        if (this.id === undefined)
                            this.id = null;
                        this.position = new org.jbox2d.common.Vec2();
                        this.normal = new org.jbox2d.common.Vec2();
                        this.velocity = new org.jbox2d.common.Vec2();
                        this.id = new org.jbox2d.collision.ContactID();
                    }
                }
                contacts.ContactPoint = ContactPoint;
                ContactPoint["__class"] = "org.jbox2d.dynamics.contacts.ContactPoint";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class ContactRegister {
                    constructor() {
                        if (this.s1 === undefined)
                            this.s1 = null;
                        if (this.s2 === undefined)
                            this.s2 = null;
                        if (this.createFcn === undefined)
                            this.createFcn = null;
                        if (this.primary === undefined)
                            this.primary = false;
                    }
                }
                contacts.ContactRegister = ContactRegister;
                ContactRegister["__class"] = "org.jbox2d.dynamics.contacts.ContactRegister";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                /**
                 * This structure is used to report contact point results.
                 * @class
                 */
                class ContactResult {
                    constructor() {
                        if (this.shape1 === undefined)
                            this.shape1 = null;
                        if (this.shape2 === undefined)
                            this.shape2 = null;
                        if (this.position === undefined)
                            this.position = null;
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.normalImpulse === undefined)
                            this.normalImpulse = 0;
                        if (this.tangentImpulse === undefined)
                            this.tangentImpulse = 0;
                        if (this.id === undefined)
                            this.id = null;
                        this.position = new org.jbox2d.common.Vec2();
                        this.normal = new org.jbox2d.common.Vec2();
                        this.id = new org.jbox2d.collision.ContactID();
                    }
                }
                contacts.ContactResult = ContactResult;
                ContactResult["__class"] = "org.jbox2d.dynamics.contacts.ContactResult";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts_1) {
                class ContactSolver {
                    constructor() {
                        if (this.m_step === undefined)
                            this.m_step = null;
                        if (this.m_constraints === undefined)
                            this.m_constraints = null;
                        if (this.m_constraintCount === undefined)
                            this.m_constraintCount = 0;
                    }
                    init(step, contacts, contactCount) {
                        this.m_step = step;
                        this.m_constraintCount = 0;
                        for (let i = 0; i < contactCount; i++) {
                            {
                                this.m_constraintCount += contacts[i].getManifoldCount();
                            }
                            ;
                        }
                        this.m_constraints = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.m_constraintCount);
                        for (let i = 0; i < this.m_constraintCount; i++) {
                            {
                                this.m_constraints[i] = new org.jbox2d.dynamics.contacts.ContactConstraint();
                            }
                            ;
                        }
                        let count = 0;
                        for (let i = 0; i < contactCount; i++) {
                            {
                                let contact = contacts[i];
                                let b1 = contact.m_shape1.getBody();
                                let b2 = contact.m_shape2.getBody();
                                let manifoldCount = contact.getManifoldCount();
                                let manifolds = contact.getManifolds();
                                let friction = contact.m_friction;
                                let restitution = contact.m_restitution;
                                let v1 = b1.m_linearVelocity;
                                let v2 = b2.m_linearVelocity;
                                let w1 = b1.m_angularVelocity;
                                let w2 = b2.m_angularVelocity;
                                for (let j = 0; j < manifoldCount; ++j) {
                                    {
                                        let manifold = manifolds[j];
                                        let normal = manifold.normal;
                                        let c = this.m_constraints[count];
                                        c.body1 = b1;
                                        c.body2 = b2;
                                        c.manifold = manifold;
                                        c.normal.set$org_jbox2d_common_Vec2(normal);
                                        c.pointCount = manifold.pointCount;
                                        c.friction = friction;
                                        c.restitution = restitution;
                                        for (let k = 0; k < c.pointCount; ++k) {
                                            {
                                                let cp = manifold.points[k];
                                                let ccp = c.points[k];
                                                ccp.normalImpulse = cp.normalImpulse;
                                                ccp.tangentImpulse = cp.tangentImpulse;
                                                ccp.separation = cp.separation;
                                                ccp.positionImpulse = 0.0;
                                                ccp.localAnchor1.set$org_jbox2d_common_Vec2(cp.localPoint1);
                                                ccp.localAnchor2.set$org_jbox2d_common_Vec2(cp.localPoint2);
                                                let v3x = Math.fround(cp.localPoint1.x - b1.m_sweep.localCenter.x);
                                                let v3y = Math.fround(cp.localPoint1.y - b1.m_sweep.localCenter.y);
                                                ccp.r1.set$float$float(Math.fround(Math.fround(b1.m_xf.R.col1.x * v3x) + Math.fround(b1.m_xf.R.col2.x * v3y)), Math.fround(Math.fround(b1.m_xf.R.col1.y * v3x) + Math.fround(b1.m_xf.R.col2.y * v3y)));
                                                let v4x = Math.fround(cp.localPoint2.x - b2.m_sweep.localCenter.x);
                                                let v4y = Math.fround(cp.localPoint2.y - b2.m_sweep.localCenter.y);
                                                ccp.r2.set$float$float(Math.fround(Math.fround(b2.m_xf.R.col1.x * v4x) + Math.fround(b2.m_xf.R.col2.x * v4y)), Math.fround(Math.fround(b2.m_xf.R.col1.y * v4x) + Math.fround(b2.m_xf.R.col2.y * v4y)));
                                                let rn1 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(ccp.r1, normal);
                                                let rn2 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(ccp.r2, normal);
                                                rn1 *= rn1;
                                                rn2 *= rn2;
                                                let kNormal = Math.fround(Math.fround(Math.fround(b1.m_invMass + b2.m_invMass) + Math.fround(b1.m_invI * rn1)) + Math.fround(b2.m_invI * rn2));
                                                ccp.normalMass = Math.fround(1.0 / kNormal);
                                                let kEqualized = Math.fround(Math.fround(b1.m_mass * b1.m_invMass) + Math.fround(b2.m_mass * b2.m_invMass));
                                                kEqualized += Math.fround(Math.fround(Math.fround(b1.m_mass * b1.m_invI) * rn1) + Math.fround(Math.fround(b2.m_mass * b2.m_invI) * rn2));
                                                ccp.equalizedMass = Math.fround(1.0 / kEqualized);
                                                let tangentx = normal.y;
                                                let tangenty = -normal.x;
                                                let a = ccp.r1;
                                                let rt1 = Math.fround(Math.fround(a.x * tangenty) - Math.fround(a.y * tangentx));
                                                let a1 = ccp.r2;
                                                let rt2 = Math.fround(Math.fround(a1.x * tangenty) - Math.fround(a1.y * tangentx));
                                                rt1 *= rt1;
                                                rt2 *= rt2;
                                                let kTangent = Math.fround(Math.fround(Math.fround(b1.m_invMass + b2.m_invMass) + Math.fround(b1.m_invI * rt1)) + Math.fround(b2.m_invI * rt2));
                                                ccp.tangentMass = Math.fround(1.0 / kTangent);
                                                ccp.velocityBias = 0.0;
                                                if (ccp.separation > 0.0) {
                                                    ccp.velocityBias = Math.fround(-60.0 * ccp.separation);
                                                }
                                                let a2 = ccp.r2;
                                                let a3 = ccp.r1;
                                                let bufferx = Math.fround(Math.fround(Math.fround(Math.fround(-w2 * a2.y) - (Math.fround(-w1 * a3.y))) + v2.x) - v1.x);
                                                let buffery = Math.fround(Math.fround(Math.fround(Math.fround(w2 * a2.x) - Math.fround(w1 * a3.x)) + v2.y) - v1.y);
                                                let vRel = Math.fround(Math.fround(c.normal.x * bufferx) + Math.fround(c.normal.y * buffery));
                                                if (vRel < -org.jbox2d.common.Settings.velocityThreshold_$LI$()) {
                                                    ccp.velocityBias += Math.fround(-c.restitution * vRel);
                                                }
                                            }
                                            ;
                                        }
                                        ++count;
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    initVelocityConstraints(step) {
                        for (let i = 0; i < this.m_constraintCount; ++i) {
                            {
                                let c = this.m_constraints[i];
                                let b1 = c.body1;
                                let b2 = c.body2;
                                let invMass1 = b1.m_invMass;
                                let invI1 = b1.m_invI;
                                let invMass2 = b2.m_invMass;
                                let invI2 = b2.m_invI;
                                let normalx = c.normal.x;
                                let normaly = c.normal.y;
                                let tangentx = normaly;
                                let tangenty = -normalx;
                                if (step.warmStarting) {
                                    for (let j = 0; j < c.pointCount; ++j) {
                                        {
                                            let ccp = c.points[j];
                                            ccp.normalImpulse *= step.dtRatio;
                                            ccp.tangentImpulse *= step.dtRatio;
                                            let px = (Math.fround(Math.fround(ccp.normalImpulse * normalx) + Math.fround(ccp.tangentImpulse * tangentx)));
                                            let py = (Math.fround(Math.fround(ccp.normalImpulse * normaly) + Math.fround(ccp.tangentImpulse * tangenty)));
                                            b1.m_angularVelocity -= Math.fround(invI1 * (Math.fround(Math.fround(ccp.r1.x * py) - Math.fround(ccp.r1.y * px))));
                                            b1.m_linearVelocity.x -= Math.fround(px * invMass1);
                                            b1.m_linearVelocity.y -= Math.fround(py * invMass1);
                                            b2.m_angularVelocity += Math.fround(invI2 * (Math.fround(Math.fround(ccp.r2.x * py) - Math.fround(ccp.r2.y * px))));
                                            b2.m_linearVelocity.x += Math.fround(px * invMass2);
                                            b2.m_linearVelocity.y += Math.fround(py * invMass2);
                                        }
                                        ;
                                    }
                                }
                                else {
                                    for (let j = 0; j < c.pointCount; ++j) {
                                        {
                                            let ccp = c.points[j];
                                            ccp.normalImpulse = 0.0;
                                            ccp.tangentImpulse = 0.0;
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                        }
                    }
                    solveVelocityConstraints() {
                        for (let i = 0; i < this.m_constraintCount; ++i) {
                            {
                                let c = this.m_constraints[i];
                                let b1 = c.body1;
                                let b2 = c.body2;
                                let w1 = b1.m_angularVelocity;
                                let w2 = b2.m_angularVelocity;
                                let v1x = b1.m_linearVelocity.x;
                                let v1y = b1.m_linearVelocity.y;
                                let v2x = b2.m_linearVelocity.x;
                                let v2y = b2.m_linearVelocity.y;
                                let invMass1 = b1.m_invMass;
                                let invI1 = b1.m_invI;
                                let invMass2 = b2.m_invMass;
                                let invI2 = b2.m_invI;
                                let normalx = c.normal.x;
                                let normaly = c.normal.y;
                                let tangentx = normaly;
                                let tangenty = -normalx;
                                let friction = c.friction;
                                for (let j = 0; j < c.pointCount; ++j) {
                                    {
                                        let ccp = c.points[j];
                                        let dvx = Math.fround(Math.fround(Math.fround(v2x - Math.fround(w2 * ccp.r2.y)) - v1x) + Math.fround(w1 * ccp.r1.y));
                                        let dvy = Math.fround(Math.fround(Math.fround(v2y + Math.fround(w2 * ccp.r2.x)) - v1y) - Math.fround(w1 * ccp.r1.x));
                                        let vn = Math.fround(Math.fround(dvx * normalx) + Math.fround(dvy * normaly));
                                        let lambda = Math.fround(-ccp.normalMass * (Math.fround(vn - ccp.velocityBias)));
                                        let newImpulse = org.jbox2d.common.MathUtils.max$float$float(Math.fround(ccp.normalImpulse + lambda), 0.0);
                                        lambda = Math.fround(newImpulse - ccp.normalImpulse);
                                        let Px = Math.fround(lambda * normalx);
                                        let Py = Math.fround(lambda * normaly);
                                        v1x -= Math.fround(invMass1 * Px);
                                        v1y -= Math.fround(invMass1 * Py);
                                        w1 -= Math.fround(invI1 * (Math.fround(Math.fround(ccp.r1.x * Py) - Math.fround(ccp.r1.y * Px))));
                                        v2x += Math.fround(invMass2 * Px);
                                        v2y += Math.fround(invMass2 * Py);
                                        w2 += Math.fround(invI2 * (Math.fround(Math.fround(ccp.r2.x * Py) - Math.fround(ccp.r2.y * Px))));
                                        ccp.normalImpulse = newImpulse;
                                    }
                                    ;
                                }
                                for (let j = 0; j < c.pointCount; ++j) {
                                    {
                                        let ccp = c.points[j];
                                        let dvx = Math.fround(Math.fround(Math.fround(v2x - Math.fround(w2 * ccp.r2.y)) - v1x) + Math.fround(w1 * ccp.r1.y));
                                        let dvy = Math.fround(Math.fround(Math.fround(v2y + Math.fround(w2 * ccp.r2.x)) - v1y) - Math.fround(w1 * ccp.r1.x));
                                        let vt = Math.fround(Math.fround(dvx * tangentx) + Math.fround(dvy * tangenty));
                                        let lambda = Math.fround(ccp.tangentMass * (-vt));
                                        let maxFriction = Math.fround(friction * ccp.normalImpulse);
                                        let newImpulse = org.jbox2d.common.MathUtils.max$float$float(-maxFriction, org.jbox2d.common.MathUtils.min(Math.fround(ccp.tangentImpulse + lambda), maxFriction));
                                        lambda = Math.fround(newImpulse - ccp.tangentImpulse);
                                        let px = Math.fround(lambda * tangentx);
                                        let py = Math.fround(lambda * tangenty);
                                        v1x -= Math.fround(px * invMass1);
                                        v1y -= Math.fround(py * invMass1);
                                        w1 -= Math.fround(invI1 * (Math.fround(Math.fround(ccp.r1.x * py) - Math.fround(ccp.r1.y * px))));
                                        v2x += Math.fround(px * invMass2);
                                        v2y += Math.fround(py * invMass2);
                                        w2 += Math.fround(invI2 * (Math.fround(Math.fround(ccp.r2.x * py) - Math.fround(ccp.r2.y * px))));
                                        ccp.tangentImpulse = newImpulse;
                                    }
                                    ;
                                }
                                b1.m_linearVelocity.x = v1x;
                                b1.m_linearVelocity.y = v1y;
                                b1.m_angularVelocity = w1;
                                b2.m_linearVelocity.x = v2x;
                                b2.m_linearVelocity.y = v2y;
                                b2.m_angularVelocity = w2;
                            }
                            ;
                        }
                    }
                    finalizeVelocityConstraints() {
                        for (let i = 0; i < this.m_constraintCount; ++i) {
                            {
                                let c = this.m_constraints[i];
                                let m = c.manifold;
                                for (let j = 0; j < c.pointCount; ++j) {
                                    {
                                        m.points[j].normalImpulse = c.points[j].normalImpulse;
                                        m.points[j].tangentImpulse = c.points[j].tangentImpulse;
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    solvePositionConstraints(baumgarte) {
                        let minSeparation = 0.0;
                        for (let i = 0; i < this.m_constraintCount; ++i) {
                            {
                                let c = this.m_constraints[i];
                                let b1 = c.body1;
                                let b2 = c.body2;
                                let invMass1 = Math.fround(b1.m_mass * b1.m_invMass);
                                let invI1 = Math.fround(b1.m_mass * b1.m_invI);
                                let invMass2 = Math.fround(b2.m_mass * b2.m_invMass);
                                let invI2 = Math.fround(b2.m_mass * b2.m_invI);
                                let normal = c.normal;
                                for (let j = 0; j < c.pointCount; ++j) {
                                    {
                                        let ccp = c.points[j];
                                        let vx = Math.fround(ccp.localAnchor1.x - b1.m_sweep.localCenter.x);
                                        let vy = Math.fround(ccp.localAnchor1.y - b1.m_sweep.localCenter.y);
                                        let r1x = Math.fround(Math.fround(b1.m_xf.R.col1.x * vx) + Math.fround(b1.m_xf.R.col2.x * vy));
                                        let r1y = Math.fround(Math.fround(b1.m_xf.R.col1.y * vx) + Math.fround(b1.m_xf.R.col2.y * vy));
                                        vx = Math.fround(ccp.localAnchor2.x - b2.m_sweep.localCenter.x);
                                        vy = Math.fround(ccp.localAnchor2.y - b2.m_sweep.localCenter.y);
                                        let r2x = Math.fround(Math.fround(b2.m_xf.R.col1.x * vx) + Math.fround(b2.m_xf.R.col2.x * vy));
                                        let r2y = Math.fround(Math.fround(b2.m_xf.R.col1.y * vx) + Math.fround(b2.m_xf.R.col2.y * vy));
                                        let dpx = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.x + r2x) - b1.m_sweep.c.x) - r1x);
                                        let dpy = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.y + r2y) - b1.m_sweep.c.y) - r1y);
                                        let separation = Math.fround(Math.fround(Math.fround(dpx * normal.x) + Math.fround(dpy * normal.y)) + ccp.separation);
                                        minSeparation = org.jbox2d.common.MathUtils.min(minSeparation, separation);
                                        let C = Math.fround(baumgarte * org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(separation + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0));
                                        let dImpulse = Math.fround(-ccp.equalizedMass * C);
                                        let impulse0 = ccp.positionImpulse;
                                        ccp.positionImpulse = org.jbox2d.common.MathUtils.max$float$float(Math.fround(impulse0 + dImpulse), 0.0);
                                        dImpulse = Math.fround(ccp.positionImpulse - impulse0);
                                        let impulsex = Math.fround(dImpulse * normal.x);
                                        let impulsey = Math.fround(dImpulse * normal.y);
                                        b1.m_sweep.c.x -= Math.fround(invMass1 * impulsex);
                                        b1.m_sweep.c.y -= Math.fround(invMass1 * impulsey);
                                        b1.m_sweep.a -= Math.fround(invI1 * (Math.fround(Math.fround(r1x * impulsey) - Math.fround(r1y * impulsex))));
                                        b1.synchronizeTransform();
                                        b2.m_sweep.c.x += Math.fround(invMass2 * impulsex);
                                        b2.m_sweep.c.y += Math.fround(invMass2 * impulsey);
                                        b2.m_sweep.a += Math.fround(invI2 * (Math.fround(Math.fround(r2x * impulsey) - Math.fround(r2y * impulsex))));
                                        b2.synchronizeTransform();
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return minSeparation >= Math.fround(-1.5 * org.jbox2d.common.Settings.linearSlop_$LI$());
                    }
                }
                contacts_1.ContactSolver = ContactSolver;
                ContactSolver["__class"] = "org.jbox2d.dynamics.contacts.ContactSolver";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var controllers;
            (function (controllers) {
                /**
                 *
                 * Base class for controllers. Controllers are a convience for encapsulating common
                 * per-step functionality.
                 * @class
                 */
                class Controller {
                    constructor(def) {
                        if (this.m_world === undefined)
                            this.m_world = null;
                        if (this.m_bodyList === undefined)
                            this.m_bodyList = null;
                        if (this.m_bodyCount === undefined)
                            this.m_bodyCount = 0;
                        if (this.m_prev === undefined)
                            this.m_prev = null;
                        if (this.m_next === undefined)
                            this.m_next = null;
                        this.m_world = null;
                        this.m_bodyList = null;
                        this.m_bodyCount = 0;
                        this.m_prev = null;
                        this.m_next = null;
                    }
                    /**
                     * Controllers override this to implement per-step functionality.
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    step(step) {
                    }
                    /**
                     * Controllers override this to provide debug drawing.
                     * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
                     */
                    draw(debugDraw) {
                    }
                    /**
                     * Adds a body to the controller list.
                     * @param {org.jbox2d.dynamics.Body} body
                     */
                    addBody(body) {
                        let edge = new org.jbox2d.dynamics.controllers.ControllerEdge();
                        edge.body = body;
                        edge.controller = this;
                        edge.nextBody = this.m_bodyList;
                        edge.prevBody = null;
                        if (this.m_bodyList != null) {
                            this.m_bodyList.prevBody = edge;
                        }
                        this.m_bodyList = edge;
                        ++this.m_bodyCount;
                        edge.nextController = body.m_controllerList;
                        edge.prevController = null;
                        if (body.m_controllerList != null)
                            body.m_controllerList.prevController = edge;
                        body.m_controllerList = edge;
                    }
                    /**
                     * Removes a body from the controller list.
                     * @param {org.jbox2d.dynamics.Body} body
                     */
                    removeBody(body) {
                        let edge = this.m_bodyList;
                        while ((edge != null && edge.body !== body)) {
                            {
                                edge = edge.nextBody;
                            }
                        }
                        ;
                        if (edge.prevBody != null) {
                            edge.prevBody.nextBody = edge.nextBody;
                        }
                        if (edge.nextBody != null) {
                            edge.nextBody.prevBody = edge.prevBody;
                        }
                        if (edge === this.m_bodyList) {
                            this.m_bodyList = edge.nextBody;
                        }
                        --this.m_bodyCount;
                        if (edge.prevController != null)
                            edge.prevController.nextController = edge.nextController;
                        if (edge.nextController != null)
                            edge.nextController.prevController = edge.prevController;
                        if (edge === body.m_controllerList)
                            body.m_controllerList = edge.nextController;
                    }
                    /**
                     * Removes all bodies from the controller list.
                     */
                    clear() {
                        while ((this.m_bodyList != null)) {
                            {
                                let edge = this.m_bodyList;
                                this.m_bodyList = edge.nextBody;
                                if (edge.prevController != null)
                                    edge.prevController.nextController = edge.nextController;
                                if (edge.nextController != null)
                                    edge.nextController.prevController = edge.prevController;
                                if (edge === edge.body.m_controllerList)
                                    edge.body.m_controllerList = edge.nextController;
                            }
                        }
                        ;
                        this.m_bodyCount = 0;
                    }
                    /**
                     * Get the next controller in the world's body list.
                     * @return {org.jbox2d.dynamics.controllers.Controller}
                     */
                    getNext() {
                        return this.m_next;
                    }
                    /**
                     * Get the parent world of this body.
                     * @return {org.jbox2d.dynamics.World}
                     */
                    getWorld() {
                        return this.m_world;
                    }
                    /**
                     * Get the attached body list
                     * @return {org.jbox2d.dynamics.controllers.ControllerEdge}
                     */
                    getBodyList() {
                        return this.m_bodyList;
                    }
                }
                controllers.Controller = Controller;
                Controller["__class"] = "org.jbox2d.dynamics.controllers.Controller";
            })(controllers = dynamics.controllers || (dynamics.controllers = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var controllers;
            (function (controllers) {
                /**
                 * @author eric
                 * @class
                 */
                class ControllerDef {
                }
                controllers.ControllerDef = ControllerDef;
                ControllerDef["__class"] = "org.jbox2d.dynamics.controllers.ControllerDef";
            })(controllers = dynamics.controllers || (dynamics.controllers = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var controllers;
            (function (controllers) {
                /**
                 * @author eric
                 * @class
                 */
                class ControllerEdge {
                    constructor() {
                        if (this.controller === undefined)
                            this.controller = null;
                        if (this.body === undefined)
                            this.body = null;
                        if (this.prevBody === undefined)
                            this.prevBody = null;
                        if (this.nextBody === undefined)
                            this.nextBody = null;
                        if (this.prevController === undefined)
                            this.prevController = null;
                        if (this.nextController === undefined)
                            this.nextController = null;
                    }
                }
                controllers.ControllerEdge = ControllerEdge;
                ControllerEdge["__class"] = "org.jbox2d.dynamics.controllers.ControllerEdge";
            })(controllers = dynamics.controllers || (dynamics.controllers = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Implement this abstract class to allow JBox2d to
             * automatically draw your physics for debugging purposes.
             * Not intended to replace your own custom rendering
             * routines!
             * @param {*} viewport
             * @class
             */
            class DebugDraw {
                constructor(viewport) {
                    if (this.m_drawFlags === undefined)
                        this.m_drawFlags = 0;
                    if (this.viewportTransform === undefined)
                        this.viewportTransform = null;
                    this.m_drawFlags = 0;
                    this.viewportTransform = viewport;
                }
                setFlags(flags) {
                    this.m_drawFlags = flags;
                }
                getFlags() {
                    return this.m_drawFlags;
                }
                appendFlags(flags) {
                    this.m_drawFlags |= flags;
                }
                clearFlags(flags) {
                    this.m_drawFlags &= ~flags;
                }
                getViewportTranform() {
                    return this.viewportTransform;
                }
                /**
                 * @param {number} x
                 * @param {number} y
                 * @param {number} scale
                 * @see IViewportTransform#setCamera(float, float, float)
                 */
                setCamera(x, y, scale) {
                    this.viewportTransform.setCamera(x, y, scale);
                }
                getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argWorld) {
                    this.viewportTransform.getScreenToWorld(argScreen, argWorld);
                }
                getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argScreen) {
                    this.viewportTransform.getWorldToScreen(argWorld, argScreen);
                }
                getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX, worldY, argScreen) {
                    argScreen.set$float$float(worldX, worldY);
                    this.viewportTransform.getWorldToScreen(argScreen, argScreen);
                }
                /**
                 * Takes the world coordinates and puts the corresponding screen
                 * coordinates in argScreen.
                 * @param {number} worldX
                 * @param {number} worldY
                 * @param {org.jbox2d.common.Vec2} argScreen
                 */
                getWorldToScreenToOut(worldX, worldY, argScreen) {
                    if (((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null) && ((argScreen != null && argScreen instanceof org.jbox2d.common.Vec2) || argScreen === null)) {
                        return this.getWorldToScreenToOut$float$float$org_jbox2d_common_Vec2(worldX, worldY, argScreen);
                    }
                    else if (((worldX != null && worldX instanceof org.jbox2d.common.Vec2) || worldX === null) && ((worldY != null && worldY instanceof org.jbox2d.common.Vec2) || worldY === null) && argScreen === undefined) {
                        return this.getWorldToScreenToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(worldX, worldY);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getWorldToScreen$org_jbox2d_common_Vec2(argWorld) {
                    let screen = new org.jbox2d.common.Vec2();
                    this.viewportTransform.getWorldToScreen(argWorld, screen);
                    return screen;
                }
                getWorldToScreen$float$float(worldX, worldY) {
                    let argScreen = new org.jbox2d.common.Vec2(worldX, worldY);
                    this.viewportTransform.getWorldToScreen(argScreen, argScreen);
                    return argScreen;
                }
                /**
                 * Takes the world coordinates and returns the screen
                 * coordinates.
                 * @param {number} worldX
                 * @param {number} worldY
                 * @return {org.jbox2d.common.Vec2}
                 */
                getWorldToScreen(worldX, worldY) {
                    if (((typeof worldX === 'number') || worldX === null) && ((typeof worldY === 'number') || worldY === null)) {
                        return this.getWorldToScreen$float$float(worldX, worldY);
                    }
                    else if (((worldX != null && worldX instanceof org.jbox2d.common.Vec2) || worldX === null) && worldY === undefined) {
                        return this.getWorldToScreen$org_jbox2d_common_Vec2(worldX);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX, screenY, argWorld) {
                    argWorld.set$float$float(screenX, screenY);
                    this.viewportTransform.getScreenToWorld(argWorld, argWorld);
                }
                /**
                 * takes the screen coordinates and puts the corresponding
                 * world coordinates in argWorld.
                 * @param {number} screenX
                 * @param {number} screenY
                 * @param {org.jbox2d.common.Vec2} argWorld
                 */
                getScreenToWorldToOut(screenX, screenY, argWorld) {
                    if (((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null) && ((argWorld != null && argWorld instanceof org.jbox2d.common.Vec2) || argWorld === null)) {
                        return this.getScreenToWorldToOut$float$float$org_jbox2d_common_Vec2(screenX, screenY, argWorld);
                    }
                    else if (((screenX != null && screenX instanceof org.jbox2d.common.Vec2) || screenX === null) && ((screenY != null && screenY instanceof org.jbox2d.common.Vec2) || screenY === null) && argWorld === undefined) {
                        return this.getScreenToWorldToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(screenX, screenY);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getScreenToWorld$org_jbox2d_common_Vec2(argScreen) {
                    let world = new org.jbox2d.common.Vec2();
                    this.viewportTransform.getScreenToWorld(argScreen, world);
                    return world;
                }
                getScreenToWorld$float$float(screenX, screenY) {
                    let screen = new org.jbox2d.common.Vec2(screenX, screenY);
                    this.viewportTransform.getScreenToWorld(screen, screen);
                    return screen;
                }
                /**
                 * takes the screen coordinates and returns the
                 * world coordinates.
                 * @param {number} screenX
                 * @param {number} screenY
                 * @return {org.jbox2d.common.Vec2}
                 */
                getScreenToWorld(screenX, screenY) {
                    if (((typeof screenX === 'number') || screenX === null) && ((typeof screenY === 'number') || screenY === null)) {
                        return this.getScreenToWorld$float$float(screenX, screenY);
                    }
                    else if (((screenX != null && screenX instanceof org.jbox2d.common.Vec2) || screenX === null) && screenY === undefined) {
                        return this.getScreenToWorld$org_jbox2d_common_Vec2(screenX);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            DebugDraw.e_shapeBit = 1;
            DebugDraw.e_jointBit = 2;
            DebugDraw.e_coreShapeBit = 4;
            DebugDraw.e_aabbBit = 8;
            DebugDraw.e_obbBit = 16;
            DebugDraw.e_pairBit = 32;
            DebugDraw.e_centerOfMassBit = 64;
            DebugDraw.e_controllerBit = 128;
            dynamics.DebugDraw = DebugDraw;
            DebugDraw["__class"] = "org.jbox2d.dynamics.DebugDraw";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Default sample implementation of ContactFilter.
             * @class
             */
            class DefaultContactFilter {
                constructor() {
                }
                /**
                 * Return true if contact calculations should be performed between these two shapes.
                 * If you implement your own collision filter you may want to build from this implementation.
                 * @param {org.jbox2d.collision.shapes.Shape} shape1
                 * @param {org.jbox2d.collision.shapes.Shape} shape2
                 * @return {boolean}
                 */
                shouldCollide(shape1, shape2) {
                    let filter1 = shape1.getFilterData();
                    let filter2 = shape2.getFilterData();
                    if (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0) {
                        return filter1.groupIndex > 0;
                    }
                    let collide = (filter1.maskBits & filter2.categoryBits) !== 0 && (filter1.categoryBits & filter2.maskBits) !== 0;
                    return collide;
                }
                rayCollide(userData, shape) {
                    if (userData == null) {
                        return true;
                    }
                    return this.shouldCollide(userData, shape);
                }
            }
            dynamics.DefaultContactFilter = DefaultContactFilter;
            DefaultContactFilter["__class"] = "org.jbox2d.dynamics.DefaultContactFilter";
            DefaultContactFilter["__interfaces"] = ["org.jbox2d.dynamics.ContactFilter"];
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class Jacobian {
                    constructor() {
                        if (this.linear1 === undefined)
                            this.linear1 = null;
                        if (this.angular1 === undefined)
                            this.angular1 = 0;
                        if (this.linear2 === undefined)
                            this.linear2 = null;
                        if (this.angular2 === undefined)
                            this.angular2 = 0;
                        this.linear1 = new org.jbox2d.common.Vec2();
                        this.linear2 = new org.jbox2d.common.Vec2();
                        this.angular1 = 0;
                        this.angular2 = 0;
                    }
                    setZero() {
                        this.linear1.setZero();
                        this.angular1 = 0.0;
                        this.linear2.setZero();
                        this.angular2 = 0.0;
                    }
                    set(x1, a1, x2, a2) {
                        this.linear1.set$org_jbox2d_common_Vec2(x1);
                        this.angular1 = a1;
                        this.linear2.set$org_jbox2d_common_Vec2(x2);
                        this.angular2 = a2;
                    }
                    compute(x1, a1, x2, a2) {
                        return Math.fround(Math.fround(Math.fround(org.jbox2d.common.Vec2.dot(this.linear1, x1) + Math.fround(this.angular1 * a1)) + org.jbox2d.common.Vec2.dot(this.linear2, x2)) + Math.fround(this.angular2 * a2));
                    }
                }
                joints.Jacobian = Jacobian;
                Jacobian["__class"] = "org.jbox2d.dynamics.joints.Jacobian";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * Base class for all Joints
                 * @param {org.jbox2d.dynamics.joints.JointDef} description
                 * @class
                 */
                class Joint {
                    constructor(description) {
                        if (this.m_type === undefined)
                            this.m_type = null;
                        if (this.m_prev === undefined)
                            this.m_prev = null;
                        if (this.m_next === undefined)
                            this.m_next = null;
                        if (this.m_node1 === undefined)
                            this.m_node1 = null;
                        if (this.m_node2 === undefined)
                            this.m_node2 = null;
                        if (this.m_body1 === undefined)
                            this.m_body1 = null;
                        if (this.m_body2 === undefined)
                            this.m_body2 = null;
                        if (this.m_islandFlag === undefined)
                            this.m_islandFlag = false;
                        if (this.m_collideConnected === undefined)
                            this.m_collideConnected = false;
                        if (this.m_userData === undefined)
                            this.m_userData = null;
                        if (this.m_inv_dt === undefined)
                            this.m_inv_dt = 0;
                        this.m_type = description.type;
                        this.m_prev = null;
                        this.m_next = null;
                        this.m_node1 = new org.jbox2d.dynamics.joints.JointEdge();
                        this.m_node2 = new org.jbox2d.dynamics.joints.JointEdge();
                        this.m_body1 = description.body1;
                        this.m_body2 = description.body2;
                        this.m_collideConnected = description.collideConnected;
                        this.m_islandFlag = false;
                        this.m_userData = description.userData;
                    }
                    static destroy(j) {
                        j.destructor();
                        return;
                    }
                    destructor() {
                    }
                    static create(description) {
                        let joint = null;
                        if (description.type === org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.DistanceJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.MouseJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.PrismaticJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.RevoluteJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.PulleyJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.GEAR_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.GearJoint(description);
                        }
                        else if (description.type === org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT) {
                            joint = new org.jbox2d.dynamics.joints.ConstantVolumeJoint(description);
                        }
                        else {
                        }
                        return joint;
                    }
                    /**
                     * Get the type of the concrete joint.
                     * @return {org.jbox2d.dynamics.joints.JointType}
                     */
                    getType() {
                        return this.m_type;
                    }
                    /**
                     * Get the first body attached to this joint.
                     * @return {org.jbox2d.dynamics.Body}
                     */
                    getBody1() {
                        return this.m_body1;
                    }
                    /**
                     * Get the second body attached to this joint.
                     * @return {org.jbox2d.dynamics.Body}
                     */
                    getBody2() {
                        return this.m_body2;
                    }
                    /**
                     * Get the next joint the world joint list.
                     * @return {org.jbox2d.dynamics.joints.Joint}
                     */
                    getNext() {
                        return this.m_next;
                    }
                    /**
                     * Get the user data pointer.
                     * @return {*}
                     */
                    getUserData() {
                        return this.m_userData;
                    }
                    /**
                     * Set the user data pointer.
                     * @param {*} o
                     */
                    setUserData(o) {
                        this.m_userData = o;
                    }
                    initPositionConstraints() {
                        return;
                    }
                }
                joints.Joint = Joint;
                Joint["__class"] = "org.jbox2d.dynamics.joints.Joint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * Base class for all joint definitions
                 * @class
                 */
                class JointDef {
                    constructor() {
                        if (this.type === undefined)
                            this.type = null;
                        if (this.body1 === undefined)
                            this.body1 = null;
                        if (this.body2 === undefined)
                            this.body2 = null;
                        if (this.userData === undefined)
                            this.userData = null;
                        if (this.collideConnected === undefined)
                            this.collideConnected = false;
                        this.type = org.jbox2d.dynamics.joints.JointType.UNKNOWN_JOINT;
                        this.body1 = null;
                        this.body2 = null;
                        this.userData = null;
                        this.collideConnected = false;
                    }
                }
                joints.JointDef = JointDef;
                JointDef["__class"] = "org.jbox2d.dynamics.joints.JointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class JointEdge {
                    constructor() {
                        if (this.other === undefined)
                            this.other = null;
                        if (this.joint === undefined)
                            this.joint = null;
                        if (this.prev === undefined)
                            this.prev = null;
                        if (this.next === undefined)
                            this.next = null;
                    }
                }
                joints.JointEdge = JointEdge;
                JointEdge["__class"] = "org.jbox2d.dynamics.joints.JointEdge";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                var JointType;
                (function (JointType) {
                    JointType[JointType["UNKNOWN_JOINT"] = 0] = "UNKNOWN_JOINT";
                    JointType[JointType["REVOLUTE_JOINT"] = 1] = "REVOLUTE_JOINT";
                    JointType[JointType["PRISMATIC_JOINT"] = 2] = "PRISMATIC_JOINT";
                    JointType[JointType["DISTANCE_JOINT"] = 3] = "DISTANCE_JOINT";
                    JointType[JointType["PULLEY_JOINT"] = 4] = "PULLEY_JOINT";
                    JointType[JointType["MOUSE_JOINT"] = 5] = "MOUSE_JOINT";
                    JointType[JointType["GEAR_JOINT"] = 6] = "GEAR_JOINT";
                    JointType[JointType["CONSTANT_VOLUME_JOINT"] = 7] = "CONSTANT_VOLUME_JOINT";
                })(JointType = joints.JointType || (joints.JointType = {}));
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                var LimitState;
                (function (LimitState) {
                    LimitState[LimitState["INACTIVE_LIMIT"] = 0] = "INACTIVE_LIMIT";
                    LimitState[LimitState["AT_LOWER_LIMIT"] = 1] = "AT_LOWER_LIMIT";
                    LimitState[LimitState["AT_UPPER_LIMIT"] = 2] = "AT_UPPER_LIMIT";
                    LimitState[LimitState["EQUAL_LIMITS"] = 3] = "EQUAL_LIMITS";
                })(LimitState = joints.LimitState || (joints.LimitState = {}));
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * A holder for time step information.
             * @class
             */
            class TimeStep {
                constructor() {
                    if (this.dt === undefined)
                        this.dt = 0;
                    if (this.inv_dt === undefined)
                        this.inv_dt = 0;
                    if (this.dtRatio === undefined)
                        this.dtRatio = 0;
                    if (this.warmStarting === undefined)
                        this.warmStarting = false;
                    if (this.positionCorrection === undefined)
                        this.positionCorrection = false;
                    if (this.maxIterations === undefined)
                        this.maxIterations = 0;
                }
            }
            dynamics.TimeStep = TimeStep;
            TimeStep["__class"] = "org.jbox2d.dynamics.TimeStep";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var arrays;
            (function (arrays) {
                class DynamicTLArray {
                    constructor() {
                        /*private*/ this.tlMap = ((() => { let __o = new DynamicTLArray.TLHashMap(); __o.__delegate = new DynamicTLArray.TLHashMap(); return __o; })());
                    }
                    get(argLength) {
                        let map = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(this.tlMap);
                        if (!((m, k) => { if (m.entries == null)
                            m.entries = []; for (let i = 0; i < m.entries.length; i++)
                            if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                                return true;
                            } return false; })(map, argLength)) {
                            /* put */ ((m, k, v) => { if (m.entries == null)
                                m.entries = []; for (let i = 0; i < m.entries.length; i++)
                                if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                                    m.entries[i].value = v;
                                    return;
                                } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); })(map, argLength, this.getInitializedArray(argLength));
                        }
                        return ((m, k) => { if (m.entries == null)
                            m.entries = []; for (let i = 0; i < m.entries.length; i++)
                            if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                                return m.entries[i].value;
                            } return null; })(map, argLength);
                    }
                    recycle(argArray) {
                    }
                }
                arrays.DynamicTLArray = DynamicTLArray;
                DynamicTLArray["__class"] = "org.jbox2d.pooling.arrays.DynamicTLArray";
                (function (DynamicTLArray) {
                    class TLHashMap {
                        constructor() {
                        }
                        initialValue() {
                            return ({});
                        }
                    }
                    DynamicTLArray.TLHashMap = TLHashMap;
                    TLHashMap["__class"] = "org.jbox2d.pooling.arrays.DynamicTLArray.TLHashMap";
                })(DynamicTLArray = arrays.DynamicTLArray || (arrays.DynamicTLArray = {}));
            })(arrays = pooling.arrays || (pooling.arrays = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class SingletonPool {
                static pool_$LI$() { if (SingletonPool.pool == null)
                    SingletonPool.pool = (() => { let __o = new SingletonPool.Pool(); __o.__delegate = new SingletonPool.Pool(); return __o; })(); return SingletonPool.pool; }
                ;
                static getCollideCircle() {
                    return ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(SingletonPool.pool_$LI$()).collideCircle;
                }
                static getCollidePoly() {
                    return ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(SingletonPool.pool_$LI$()).collidePoly;
                }
                static getDistance() {
                    return ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(SingletonPool.pool_$LI$()).distance;
                }
            }
            pooling.SingletonPool = SingletonPool;
            SingletonPool["__class"] = "org.jbox2d.pooling.SingletonPool";
            (function (SingletonPool) {
                class Singletons {
                    constructor() {
                        this.collideCircle = new org.jbox2d.collision.shapes.CollideCircle();
                        this.collidePoly = new org.jbox2d.collision.shapes.CollidePoly();
                        this.distance = new org.jbox2d.collision.Distance();
                    }
                }
                SingletonPool.Singletons = Singletons;
                Singletons["__class"] = "org.jbox2d.pooling.SingletonPool.Singletons";
                class Pool {
                    constructor() {
                    }
                    initialValue() {
                        return new SingletonPool.Singletons();
                    }
                }
                SingletonPool.Pool = Pool;
                Pool["__class"] = "org.jbox2d.pooling.SingletonPool.Pool";
            })(SingletonPool = pooling.SingletonPool || (pooling.SingletonPool = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var stacks;
            (function (stacks) {
                class DynamicTLStack {
                    constructor() {
                        /*private*/ this.tlStack = ((() => { let __o = new org.jbox2d.pooling.TLStack(); __o.__delegate = new org.jbox2d.pooling.TLStack(); return __o; })());
                    }
                    get() {
                        let stack = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(this.tlStack);
                        if ((stack.length == 0)) {
                            /* push */ (stack.push(this.newObjectInstance()) > 0);
                            /* push */ (stack.push(this.newObjectInstance()) > 0);
                            /* push */ (stack.push(this.newObjectInstance()) > 0);
                        }
                        return stack.pop();
                    }
                    recycle(argObject) {
                        /* push */ (((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(this.tlStack).push(argObject) > 0);
                    }
                }
                stacks.DynamicTLStack = DynamicTLStack;
                DynamicTLStack["__class"] = "org.jbox2d.pooling.stacks.DynamicTLStack";
            })(stacks = pooling.stacks || (pooling.stacks = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLAABB {
                initialValue() {
                    return new org.jbox2d.collision.AABB();
                }
            }
            pooling.TLAABB = TLAABB;
            TLAABB["__class"] = "org.jbox2d.pooling.TLAABB";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLBoundValues {
                initialValue() {
                    return new org.jbox2d.collision.BoundValues();
                }
            }
            pooling.TLBoundValues = TLBoundValues;
            TLBoundValues["__class"] = "org.jbox2d.pooling.TLBoundValues";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLContactPoint {
                initialValue() {
                    return new org.jbox2d.dynamics.contacts.ContactPoint();
                }
            }
            pooling.TLContactPoint = TLContactPoint;
            TLContactPoint["__class"] = "org.jbox2d.pooling.TLContactPoint";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLContactSolver {
                initialValue() {
                    return new org.jbox2d.dynamics.contacts.ContactSolver();
                }
            }
            pooling.TLContactSolver = TLContactSolver;
            TLContactSolver["__class"] = "org.jbox2d.pooling.TLContactSolver";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLManifold {
                initialValue() {
                    return new org.jbox2d.collision.Manifold();
                }
            }
            pooling.TLManifold = TLManifold;
            TLManifold["__class"] = "org.jbox2d.pooling.TLManifold";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLMassData {
                initialValue() {
                    return new org.jbox2d.collision.MassData();
                }
            }
            pooling.TLMassData = TLMassData;
            TLMassData["__class"] = "org.jbox2d.pooling.TLMassData";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLMat22 {
                initialValue() {
                    return new org.jbox2d.common.Mat22();
                }
            }
            pooling.TLMat22 = TLMat22;
            TLMat22["__class"] = "org.jbox2d.pooling.TLMat22";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLStack {
                initialValue() {
                    return ([]);
                }
            }
            pooling.TLStack = TLStack;
            TLStack["__class"] = "org.jbox2d.pooling.TLStack";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLTimeStep {
                /**
                 *
                 * @return {org.jbox2d.dynamics.TimeStep}
                 */
                initialValue() {
                    return new org.jbox2d.dynamics.TimeStep();
                }
            }
            pooling.TLTimeStep = TLTimeStep;
            TLTimeStep["__class"] = "org.jbox2d.pooling.TLTimeStep";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLVec2 {
                initialValue() {
                    return new org.jbox2d.common.Vec2();
                }
            }
            pooling.TLVec2 = TLVec2;
            TLVec2["__class"] = "org.jbox2d.pooling.TLVec2";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            class TLXForm {
                initialValue() {
                    return new org.jbox2d.common.XForm();
                }
            }
            pooling.TLXForm = TLXForm;
            TLXForm["__class"] = "org.jbox2d.pooling.TLXForm";
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                /**
                 * BlobMaker offers a static API for the creation of blobs.
                 * @class
                 */
                class BlobMaker {
                    static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World(s, c, w) {
                        BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s, c, w, 1.0, 1.0);
                    }
                    static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s, c, w, scaleX, scaleY) {
                        BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s, c, w, scaleX, scaleY, 0.0, 0.0);
                    }
                    static createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s, c, w, scaleX, scaleY, transX, transY) {
                        let aabb = c.getAABB();
                        while ((transX > 0.0)) {
                            transX -= scaleX;
                        }
                        ;
                        while ((transY > 0.0)) {
                            transY -= scaleY;
                        }
                        ;
                        let xMin = Math.fround(aabb.lowerBound.x + transX);
                        let yMin = Math.fround(aabb.lowerBound.y + transY);
                        let nWidth = (Math.ceil(Math.fround((Math.fround(aabb.upperBound.x - xMin)) / scaleX)) | 0);
                        let nHeight = (Math.ceil(Math.fround((Math.fround(aabb.upperBound.y - yMin)) / scaleY)) | 0);
                        nWidth += 3;
                        nHeight += 3;
                        let nPerCell = s.points.length;
                        let nPoints = nPerCell * nWidth * nHeight;
                        console.info(nWidth + " " + nHeight);
                        let bodies = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(nPoints);
                        let cd = new org.jbox2d.collision.shapes.CircleDef();
                        cd.radius = BlobMaker.pointRadius;
                        cd.density = BlobMaker.pointDensity;
                        cd.friction = BlobMaker.pointFriction;
                        let index = 0;
                        for (let j = 0; j < nHeight; ++j) {
                            {
                                let yStart = Math.fround(Math.fround(yMin + transY) + Math.fround(j * scaleY));
                                for (let i = 0; i < nWidth; ++i) {
                                    {
                                        let xStart = Math.fround(Math.fround(xMin + transX) + Math.fround(i * scaleX));
                                        for (let k = 0; k < nPerCell; ++k) {
                                            {
                                                let position = new org.jbox2d.common.Vec2(Math.fround(/* get */ s.points[k].position.x + xStart), Math.fround(/* get */ s.points[k].position.y + yStart));
                                                if (!c.containsPoint(position)) {
                                                    bodies[index++] = null;
                                                    continue;
                                                }
                                                let bd = new org.jbox2d.dynamics.BodyDef();
                                                bd.position = position;
                                                bd.fixedRotation = false;
                                                bd.angularDamping = 0.2;
                                                bodies[index] = w.createBody(bd);
                                                bodies[index].createShape(cd);
                                                bodies[index].setMassFromShapes();
                                                ++index;
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        for (let j = 0; j < nHeight; ++j) {
                            {
                                let rowStartIndex = j * nWidth * nPerCell;
                                for (let i = 0; i < nWidth; ++i) {
                                    {
                                        let boxStartIndex = rowStartIndex + i * nPerCell;
                                        let indexUR = -(nWidth - 1) * nPerCell + boxStartIndex;
                                        let indexR = nPerCell + boxStartIndex;
                                        let indexDR = (nWidth + 1) * nPerCell + boxStartIndex;
                                        let indexD = nWidth * nPerCell + boxStartIndex;
                                        for (let k = 0; k < s.connections.length; ++k) {
                                            {
                                                let iiff = s.connections[k];
                                                let a = iiff.a + boxStartIndex;
                                                let b = iiff.b + boxStartIndex;
                                                let freq = iiff.c;
                                                let damp = iiff.d;
                                                BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                                            }
                                            ;
                                        }
                                        for (let k = 0; k < s.connectionsR.length; ++k) {
                                            {
                                                let iiff = s.connectionsR[k];
                                                let a = iiff.a + boxStartIndex;
                                                let b = iiff.b + indexR;
                                                let freq = iiff.c;
                                                let damp = iiff.d;
                                                BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                                            }
                                            ;
                                        }
                                        for (let k = 0; k < s.connectionsDR.length; ++k) {
                                            {
                                                let iiff = s.connectionsDR[k];
                                                let a = iiff.a + boxStartIndex;
                                                let b = iiff.b + indexDR;
                                                let freq = iiff.c;
                                                let damp = iiff.d;
                                                BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                                            }
                                            ;
                                        }
                                        for (let k = 0; k < s.connectionsD.length; ++k) {
                                            {
                                                let iiff = s.connectionsD[k];
                                                let a = iiff.a + boxStartIndex;
                                                let b = iiff.b + indexD;
                                                let freq = iiff.c;
                                                let damp = iiff.d;
                                                BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                                            }
                                            ;
                                        }
                                        for (let k = 0; k < s.connectionsUR.length; ++k) {
                                            {
                                                if (j === 0)
                                                    break;
                                                let iiff = s.connectionsUR[k];
                                                let a = iiff.a + boxStartIndex;
                                                let b = iiff.b + indexUR;
                                                let freq = iiff.c;
                                                let damp = iiff.d;
                                                BlobMaker.createConnection(bodies, a, b, freq, damp, w);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    /**
                     * Creates a blob in a given physics world.
                     * Applies the specified x/y scaling to the structure before fill.
                     * <BR><BR>
                     * The fill procedure aligns the structure with the upper
                     * left corner of the container AABB, applies the scaling,
                     * shifts the cell by the requested translation amounts,
                     * then repeats the structure until the AABB is filled,
                     * testing at each point whether the container is supposed
                     * to have geometry there.
                     * @param {org.jbox2d.util.blob.BlobStructure} s The BlobStructure definition
                     * @param {*} c The BlobContainer that specifies the geometry to fill
                     * @param {org.jbox2d.dynamics.World} w The World to create the blob in
                     * @param {number} scaleX The world width of one repeating cell of the structure
                     * @param {number} scaleY The world height of one repeating cell of the structure
                     * @param {number} transX The world x offset of the cells from the AABB edge
                     * @param {number} transY The world y offset of the cells from the AABB edge
                     */
                    static createBlob(s, c, w, scaleX, scaleY, transX, transY) {
                        if (((s != null && s instanceof org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof org.jbox2d.dynamics.World) || w === null) && ((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && ((typeof transX === 'number') || transX === null) && ((typeof transY === 'number') || transY === null)) {
                            return org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float$float$float(s, c, w, scaleX, scaleY, transX, transY);
                        }
                        else if (((s != null && s instanceof org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof org.jbox2d.dynamics.World) || w === null) && ((typeof scaleX === 'number') || scaleX === null) && ((typeof scaleY === 'number') || scaleY === null) && transX === undefined && transY === undefined) {
                            return org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World$float$float(s, c, w, scaleX, scaleY);
                        }
                        else if (((s != null && s instanceof org.jbox2d.util.blob.BlobStructure) || s === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("org.jbox2d.util.blob.BlobContainer") >= 0)) || c === null) && ((w != null && w instanceof org.jbox2d.dynamics.World) || w === null) && scaleX === undefined && scaleY === undefined && transX === undefined && transY === undefined) {
                            return org.jbox2d.util.blob.BlobMaker.createBlob$org_jbox2d_util_blob_BlobStructure$org_jbox2d_util_blob_BlobContainer$org_jbox2d_dynamics_World(s, c, w);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ static createConnection(bodies, a, b, frequency, damping, w) {
                        if (a >= bodies.length || b >= bodies.length || bodies[a] == null || bodies[b] == null)
                            return null;
                        let jd = new org.jbox2d.dynamics.joints.DistanceJointDef();
                        jd.collideConnected = false;
                        jd.dampingRatio = damping;
                        jd.frequencyHz = frequency;
                        jd.initialize(bodies[a], bodies[b], bodies[a].getMemberPosition(), bodies[b].getMemberPosition());
                        return w.createJoint(jd);
                    }
                }
                BlobMaker.pointRadius = 3.0;
                BlobMaker.pointDensity = 1.0;
                BlobMaker.pointFriction = 0.5;
                blob.BlobMaker = BlobMaker;
                BlobMaker["__class"] = "org.jbox2d.util.blob.BlobMaker";
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                class BlobPoint {
                    constructor(x, y) {
                        this.mass = 1.0;
                        if (this.position === undefined)
                            this.position = null;
                        this.position = new org.jbox2d.common.Vec2(x, y);
                    }
                }
                blob.BlobPoint = BlobPoint;
                BlobPoint["__class"] = "org.jbox2d.util.blob.BlobPoint";
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                /**
                 * <p>Class for a toroidal repeating blob structure.
                 * Should be subclassed with code to initialize
                 * the structure in appropriate ways, such as for
                 * a hexagonal lattice or a uniform grid.</p>
                 * <p>Blobs are defined within an AABB from
                 * (0,0)->(1,1) that is then repeated to fill the
                 * full space after scaling (using the BlobMaker methods).
                 * The connections list keeps track of pairs of BlobPoints
                 * by index that are connected, and the connections* lists keep
                 * track of connections outside the AABB (to the
                 * corresponding points in the next regions).
                 * </p>
                 * <p>
                 * Connections should only be defined once per pair.
                 * </p>
                 * <p>
                 * This class does not allow for arbitrary repeated structures,
                 * but most structures of interest will be expressible
                 * as toroidally repeating in this way.
                 * </p>
                 * @class
                 */
                class BlobStructure {
                    constructor() {
                        this.currentFrequency = 10.0;
                        this.currentDamping = 0.9;
                        if (this.points === undefined)
                            this.points = null;
                        if (this.connections === undefined)
                            this.connections = null;
                        if (this.connectionsR === undefined)
                            this.connectionsR = null;
                        if (this.connectionsDR === undefined)
                            this.connectionsDR = null;
                        if (this.connectionsD === undefined)
                            this.connectionsD = null;
                        if (this.connectionsUR === undefined)
                            this.connectionsUR = null;
                        this.points = ([]);
                        this.connections = ([]);
                        this.connectionsR = ([]);
                        this.connectionsDR = ([]);
                        this.connectionsD = ([]);
                        this.connectionsUR = ([]);
                    }
                    updateSprings() {
                        for (let index127 = 0; index127 < this.connections.length; index127++) {
                            let iiff = this.connections[index127];
                            {
                                iiff.c = this.currentFrequency;
                                iiff.d = this.currentDamping;
                            }
                        }
                        for (let index128 = 0; index128 < this.connectionsR.length; index128++) {
                            let iiff = this.connectionsR[index128];
                            {
                                iiff.c = this.currentFrequency;
                                iiff.d = this.currentDamping;
                            }
                        }
                        for (let index129 = 0; index129 < this.connectionsDR.length; index129++) {
                            let iiff = this.connectionsDR[index129];
                            {
                                iiff.c = this.currentFrequency;
                                iiff.d = this.currentDamping;
                            }
                        }
                        for (let index130 = 0; index130 < this.connectionsD.length; index130++) {
                            let iiff = this.connectionsD[index130];
                            {
                                iiff.c = this.currentFrequency;
                                iiff.d = this.currentDamping;
                            }
                        }
                        for (let index131 = 0; index131 < this.connectionsUR.length; index131++) {
                            let iiff = this.connectionsUR[index131];
                            {
                                iiff.c = this.currentFrequency;
                                iiff.d = this.currentDamping;
                            }
                        }
                    }
                    setSpringFrequency(freq) {
                        this.currentFrequency = freq;
                        this.updateSprings();
                    }
                    getSpringFrequency() {
                        return this.currentFrequency;
                    }
                    setSpringDamping(damp) {
                        this.currentDamping = damp;
                        this.updateSprings();
                    }
                    getSpringDamping() {
                        return this.currentDamping;
                    }
                    addPoint(p) {
                        if (p.position.x < 0.0 || p.position.x > 1.0 || p.position.y < 0.0 || p.position.y > 1.0)
                            throw Object.defineProperty(new Error("Points must be within (0,0)->(1,1) in a BlobStructure."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                        /* add */ (this.points.push(p) > 0);
                        return this.points.indexOf(p);
                    }
                    addConnection$int$int(a, b) {
                        /* add */ (this.connections.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping)) > 0);
                    }
                    addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(a, b, r) {
                        switch ((r)) {
                            case org.jbox2d.util.blob.BlobStructure.Region.CENTER:
                                this.addConnection$int$int(a, b);
                                break;
                            case org.jbox2d.util.blob.BlobStructure.Region.RIGHT:
                                /* add */ (this.connectionsR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping)) > 0);
                                break;
                            case org.jbox2d.util.blob.BlobStructure.Region.DOWN_RIGHT:
                                /* add */ (this.connectionsDR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping)) > 0);
                                break;
                            case org.jbox2d.util.blob.BlobStructure.Region.DOWN:
                                /* add */ (this.connectionsD.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping)) > 0);
                                break;
                            case org.jbox2d.util.blob.BlobStructure.Region.UP_RIGHT:
                                /* add */ (this.connectionsUR.push(new BlobStructure.IntIntFloatFloat(this, a, b, this.currentFrequency, this.currentDamping)) > 0);
                                break;
                        }
                    }
                    /**
                     *
                     * Add a connection between point at index a in the fundamental domain
                     * and point at index b in region r.
                     * <BR><BR>
                     * Point indices can be obtained when points are added by storing the
                     * return value of the addPoint method.
                     * @param {number} a
                     * @param {number} b
                     * @param {org.jbox2d.util.blob.BlobStructure.Region} r
                     */
                    addConnection(a, b, r) {
                        if (((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null) && ((typeof r === 'number') || r === null)) {
                            return this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(a, b, r);
                        }
                        else if (((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null) && r === undefined) {
                            return this.addConnection$int$int(a, b);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                blob.BlobStructure = BlobStructure;
                BlobStructure["__class"] = "org.jbox2d.util.blob.BlobStructure";
                (function (BlobStructure) {
                    class IntIntFloatFloat {
                        constructor(__parent, _a, _b, _c, _d) {
                            this.__parent = __parent;
                            if (this.a === undefined)
                                this.a = 0;
                            if (this.b === undefined)
                                this.b = 0;
                            if (this.c === undefined)
                                this.c = 0;
                            if (this.d === undefined)
                                this.d = 0;
                            this.a = _a;
                            this.b = _b;
                            this.c = _c;
                            this.d = _d;
                        }
                    }
                    BlobStructure.IntIntFloatFloat = IntIntFloatFloat;
                    IntIntFloatFloat["__class"] = "org.jbox2d.util.blob.BlobStructure.IntIntFloatFloat";
                    /**
                     * Determines what region in toroidal space we're referring to.
                     * @enum
                     * @property {org.jbox2d.util.blob.BlobStructure.Region} DOWN
                     * @property {org.jbox2d.util.blob.BlobStructure.Region} RIGHT
                     * @property {org.jbox2d.util.blob.BlobStructure.Region} DOWN_RIGHT
                     * @property {org.jbox2d.util.blob.BlobStructure.Region} UP_RIGHT
                     * @property {org.jbox2d.util.blob.BlobStructure.Region} CENTER
                     * @class
                     */
                    var Region;
                    (function (Region) {
                        Region[Region["DOWN"] = 0] = "DOWN";
                        Region[Region["RIGHT"] = 1] = "RIGHT";
                        Region[Region["DOWN_RIGHT"] = 2] = "DOWN_RIGHT";
                        Region[Region["UP_RIGHT"] = 3] = "UP_RIGHT";
                        Region[Region["CENTER"] = 4] = "CENTER";
                    })(Region = BlobStructure.Region || (BlobStructure.Region = {}));
                })(BlobStructure = blob.BlobStructure || (blob.BlobStructure = {}));
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                /**
                 * A circular blob container specified by radius and center.
                 * @param {org.jbox2d.common.Vec2} _center
                 * @param {number} _radius
                 * @class
                 */
                class CircularBlobContainer {
                    constructor(_center, _radius) {
                        if (this.centerX === undefined)
                            this.centerX = 0;
                        if (this.centerY === undefined)
                            this.centerY = 0;
                        if (this.radius === undefined)
                            this.radius = 0;
                        if (this.radiusSqr === undefined)
                            this.radiusSqr = 0;
                        this.centerX = _center.x;
                        this.centerY = _center.y;
                        this.radius = _radius;
                        this.radiusSqr = Math.fround(_radius * _radius);
                    }
                    getRadius() {
                        return this.radius;
                    }
                    setRadius(r) {
                        this.radius = r;
                        this.radiusSqr = Math.fround(r * r);
                    }
                    getCenter() {
                        return new org.jbox2d.common.Vec2(this.centerX, this.centerY);
                    }
                    setCenter(c) {
                        this.centerX = c.x;
                        this.centerY = c.y;
                    }
                    containsPoint(p) {
                        let distSqr = Math.fround(Math.fround((Math.fround(p.x - this.centerX)) * (Math.fround(p.x - this.centerX))) + Math.fround((Math.fround(p.y - this.centerY)) * (Math.fround(p.y - this.centerY))));
                        if (distSqr > this.radiusSqr)
                            return false;
                        return true;
                    }
                    getAABB() {
                        let min = new org.jbox2d.common.Vec2(Math.fround(this.centerX - Math.fround(this.radius * 1.2)), Math.fround(this.centerY - Math.fround(this.radius * 1.2)));
                        let max = new org.jbox2d.common.Vec2(Math.fround(this.centerX + Math.fround(this.radius * 1.2)), Math.fround(this.centerY + Math.fround(this.radius * 1.2)));
                        return new org.jbox2d.collision.AABB(min, max);
                    }
                }
                blob.CircularBlobContainer = CircularBlobContainer;
                CircularBlobContainer["__class"] = "org.jbox2d.util.blob.CircularBlobContainer";
                CircularBlobContainer["__interfaces"] = ["org.jbox2d.util.blob.BlobContainer"];
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                /**
                 * A donut blob container specified by two radii and a center.
                 * @param {org.jbox2d.common.Vec2} _center
                 * @param {number} _radiusSmall
                 * @param {number} _radiusLarge
                 * @class
                 */
                class DonutBlobContainer {
                    constructor(_center, _radiusSmall, _radiusLarge) {
                        if (this.centerX === undefined)
                            this.centerX = 0;
                        if (this.centerY === undefined)
                            this.centerY = 0;
                        if (this.radiusLarge === undefined)
                            this.radiusLarge = 0;
                        if (this.radiusSmallSqr === undefined)
                            this.radiusSmallSqr = 0;
                        if (this.radiusLargeSqr === undefined)
                            this.radiusLargeSqr = 0;
                        this.centerX = _center.x;
                        this.centerY = _center.y;
                        this.radiusLarge = _radiusLarge;
                        this.radiusSmallSqr = Math.fround(_radiusSmall * _radiusSmall);
                        this.radiusLargeSqr = Math.fround(_radiusLarge * _radiusLarge);
                    }
                    containsPoint(p) {
                        let distSqr = Math.fround(Math.fround((Math.fround(p.x - this.centerX)) * (Math.fround(p.x - this.centerX))) + Math.fround((Math.fround(p.y - this.centerY)) * (Math.fround(p.y - this.centerY))));
                        if (distSqr > this.radiusLargeSqr)
                            return false;
                        if (distSqr < this.radiusSmallSqr)
                            return false;
                        return true;
                    }
                    getAABB() {
                        let min = new org.jbox2d.common.Vec2(Math.fround(this.centerX - Math.fround(1.2 * this.radiusLarge)), Math.fround(this.centerY - Math.fround(1.2 * this.radiusLarge)));
                        let max = new org.jbox2d.common.Vec2(Math.fround(this.centerX + Math.fround(1.2 * this.radiusLarge)), Math.fround(this.centerY + Math.fround(1.2 * this.radiusLarge)));
                        return new org.jbox2d.collision.AABB(min, max);
                    }
                }
                blob.DonutBlobContainer = DonutBlobContainer;
                DonutBlobContainer["__class"] = "org.jbox2d.util.blob.DonutBlobContainer";
                DonutBlobContainer["__interfaces"] = ["org.jbox2d.util.blob.BlobContainer"];
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var nonconvex;
            (function (nonconvex) {
                class Triangle {
                    constructor(x1, y1, x2, y2, x3, y3) {
                        if (((typeof x1 === 'number') || x1 === null) && ((typeof y1 === 'number') || y1 === null) && ((typeof x2 === 'number') || x2 === null) && ((typeof y2 === 'number') || y2 === null) && ((typeof x3 === 'number') || x3 === null) && ((typeof y3 === 'number') || y3 === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                (() => {
                                    this.x = [0, 0, 0];
                                    this.y = [0, 0, 0];
                                })();
                            }
                            (() => {
                                let dx1 = Math.fround(x2 - x1);
                                let dx2 = Math.fround(x3 - x1);
                                let dy1 = Math.fround(y2 - y1);
                                let dy2 = Math.fround(y3 - y1);
                                let cross = Math.fround(Math.fround(dx1 * dy2) - Math.fround(dx2 * dy1));
                                let ccw = (cross > 0);
                                if (ccw) {
                                    this.x[0] = x1;
                                    this.x[1] = x2;
                                    this.x[2] = x3;
                                    this.y[0] = y1;
                                    this.y[1] = y2;
                                    this.y[2] = y3;
                                }
                                else {
                                    this.x[0] = x1;
                                    this.x[1] = x3;
                                    this.x[2] = x2;
                                    this.y[0] = y1;
                                    this.y[1] = y3;
                                    this.y[2] = y2;
                                }
                            })();
                        }
                        else if (x1 === undefined && y1 === undefined && x2 === undefined && y2 === undefined && x3 === undefined && y3 === undefined) {
                            let __args = arguments;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            (() => {
                                this.x = [0, 0, 0];
                                this.y = [0, 0, 0];
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    set(t) {
                        this.x[0] = t.x[0];
                        this.x[1] = t.x[1];
                        this.x[2] = t.x[2];
                        this.y[0] = t.y[0];
                        this.y[1] = t.y[1];
                        this.y[2] = t.y[2];
                    }
                    containsPoint(_x, _y) {
                        let vx2 = Math.fround(_x - this.x[0]);
                        let vy2 = Math.fround(_y - this.y[0]);
                        let vx1 = Math.fround(this.x[1] - this.x[0]);
                        let vy1 = Math.fround(this.y[1] - this.y[0]);
                        let vx0 = Math.fround(this.x[2] - this.x[0]);
                        let vy0 = Math.fround(this.y[2] - this.y[0]);
                        let dot00 = Math.fround(Math.fround(vx0 * vx0) + Math.fround(vy0 * vy0));
                        let dot01 = Math.fround(Math.fround(vx0 * vx1) + Math.fround(vy0 * vy1));
                        let dot02 = Math.fround(Math.fround(vx0 * vx2) + Math.fround(vy0 * vy2));
                        let dot11 = Math.fround(Math.fround(vx1 * vx1) + Math.fround(vy1 * vy1));
                        let dot12 = Math.fround(Math.fround(vx1 * vx2) + Math.fround(vy1 * vy2));
                        let invDenom = Math.fround(1.0 / (Math.fround(Math.fround(dot00 * dot11) - Math.fround(dot01 * dot01))));
                        let u = Math.fround((Math.fround(Math.fround(dot11 * dot02) - Math.fround(dot01 * dot12))) * invDenom);
                        let v = Math.fround((Math.fround(Math.fround(dot00 * dot12) - Math.fround(dot01 * dot02))) * invDenom);
                        return ((u >= 0) && (v >= 0) && (Math.fround(u + v) <= 1));
                    }
                }
                nonconvex.Triangle = Triangle;
                Triangle["__class"] = "org.jbox2d.util.nonconvex.Triangle";
            })(nonconvex = util.nonconvex || (util.nonconvex = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * creates the circle definition at the given point with
                 * a radius of 1
                 * @param {org.jbox2d.common.Vec2} argVec
                 * @class
                 * @extends org.jbox2d.collision.shapes.ShapeDef
                 */
                class CircleDef extends org.jbox2d.collision.shapes.ShapeDef {
                    constructor(argVec) {
                        if (((argVec != null && argVec instanceof org.jbox2d.common.Vec2) || argVec === null)) {
                            let __args = arguments;
                            super();
                            if (this.radius === undefined)
                                this.radius = 0;
                            if (this.localPosition === undefined)
                                this.localPosition = null;
                            if (this.radius === undefined)
                                this.radius = 0;
                            if (this.localPosition === undefined)
                                this.localPosition = null;
                            (() => {
                                this.localPosition = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(argVec);
                                this.type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
                                this.radius = 1.0;
                            })();
                        }
                        else if (argVec === undefined) {
                            let __args = arguments;
                            super();
                            if (this.radius === undefined)
                                this.radius = 0;
                            if (this.localPosition === undefined)
                                this.localPosition = null;
                            if (this.radius === undefined)
                                this.radius = 0;
                            if (this.localPosition === undefined)
                                this.localPosition = null;
                            (() => {
                                this.type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
                                this.localPosition = new org.jbox2d.common.Vec2(0.0, 0.0);
                                this.radius = 1.0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                shapes.CircleDef = CircleDef;
                CircleDef["__class"] = "org.jbox2d.collision.shapes.CircleDef";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                class EdgeChainDef extends org.jbox2d.collision.shapes.ShapeDef {
                    constructor() {
                        super();
                        if (this.vertices === undefined)
                            this.vertices = null;
                        if (this.isALoop === undefined)
                            this.isALoop = false;
                        this.type = org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE;
                        this.isALoop = true;
                        this.vertices = ([]);
                    }
                    /**
                     * Add a vertex to the chain.
                     * @param {org.jbox2d.common.Vec2} newV
                     */
                    addVertex(newV) {
                        /* add */ (this.vertices.push(newV) > 0);
                    }
                    /**
                     * Get the number of vertices in the chain.
                     * @return
                     * @return {number}
                     */
                    getVertexCount() {
                        return this.vertices.length;
                    }
                    /**
                     * Is the chain a closed loop?  If so,
                     * an extra edge will be created between the
                     * first and last vertices.
                     * @return {boolean}
                     */
                    isLoop() {
                        return this.isALoop;
                    }
                    /**
                     * Set whether an extra edge should be
                     * created between first and last vertices.
                     * @param {boolean} isLoop True if the chain should be a closed loop
                     */
                    setIsLoop(isLoop) {
                        this.isALoop = isLoop;
                    }
                    /**
                     * Return the raw vertex list.  Modifications
                     * will effect the edge chain.
                     * @return
                     * @return {org.jbox2d.common.Vec2[]}
                     */
                    getVertices() {
                        return this.vertices;
                    }
                }
                shapes.EdgeChainDef = EdgeChainDef;
                EdgeChainDef["__class"] = "org.jbox2d.collision.shapes.EdgeChainDef";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Point shape definition.
                 * @class
                 * @extends org.jbox2d.collision.shapes.ShapeDef
                 */
                class PointDef extends org.jbox2d.collision.shapes.ShapeDef {
                    constructor() {
                        super();
                        if (this.localPosition === undefined)
                            this.localPosition = null;
                        if (this.mass === undefined)
                            this.mass = 0;
                        this.type = org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE;
                        this.localPosition = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.mass = 0.0;
                    }
                }
                shapes.PointDef = PointDef;
                PointDef["__class"] = "org.jbox2d.collision.shapes.PointDef";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Convex polygon. The vertices must be in CCW order for a right-handed
                 * coordinate system with the z-axis coming out of the screen.
                 * Add vertices using PolygonDef.add(Vec2),
                 * and create the polygon shape using Body::createShape(ShapeDef).
                 * @class
                 * @extends org.jbox2d.collision.shapes.ShapeDef
                 */
                class PolygonDef extends org.jbox2d.collision.shapes.ShapeDef {
                    constructor() {
                        super();
                        if (this.vertices === undefined)
                            this.vertices = null;
                        this.type = org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE;
                        this.vertices = ([]);
                    }
                    set(copyMe) {
                        this.density = copyMe.density;
                        this.filter = new org.jbox2d.collision.FilterData();
                        this.filter.set(copyMe.filter);
                        this.friction = copyMe.friction;
                        this.isSensor = copyMe.isSensor;
                        this.restitution = copyMe.restitution;
                        this.type = copyMe.type;
                        this.userData = copyMe.userData;
                        this.vertices = ([]);
                        for (let i = 0; i < copyMe.vertices.length; ++i) {
                            {
                                this.addVertex(/* clone */ /* clone */ ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(/* get */ copyMe.vertices[i]));
                            }
                            ;
                        }
                    }
                    /**
                     * Add a vertex to the polygon.
                     * @param {org.jbox2d.common.Vec2} v
                     */
                    addVertex(v) {
                        /* add */ (this.vertices.push(v) > 0);
                    }
                    /**
                     * Removes all vertices.
                     */
                    clearVertices() {
                        /* clear */ (this.vertices.length = 0);
                    }
                    /**
                     * Return the vertex list as an array.
                     * @return {Array}
                     */
                    getVertexArray() {
                        return this.vertices.slice(0);
                    }
                    /**
                     * Return the vertex list as a List<Vec2>.
                     * @return {org.jbox2d.common.Vec2[]}
                     */
                    getVertexList() {
                        return this.vertices;
                    }
                    setAsBox$float$float(hx, hy) {
                        /* clear */ (this.vertices.length = 0);
                        /* add */ (this.vertices.push(new org.jbox2d.common.Vec2(-hx, -hy)) > 0);
                        /* add */ (this.vertices.push(new org.jbox2d.common.Vec2(hx, -hy)) > 0);
                        /* add */ (this.vertices.push(new org.jbox2d.common.Vec2(hx, hy)) > 0);
                        /* add */ (this.vertices.push(new org.jbox2d.common.Vec2(-hx, hy)) > 0);
                    }
                    setAsBox$float$float$org_jbox2d_common_Vec2$float(hx, hy, center, angle) {
                        this.setAsBox$float$float(hx, hy);
                        let xf = new org.jbox2d.common.XForm();
                        xf.position.set$org_jbox2d_common_Vec2(center);
                        xf.R.set$float(angle);
                        for (let i = 0; i < this.vertices.length; ++i) {
                            {
                                org.jbox2d.common.XForm.mulToOut(xf, /* get */ this.vertices[i], /* get */ this.vertices[i]);
                            }
                            ;
                        }
                    }
                    /**
                     * Build vertices to represent an oriented box.
                     * @param {number} hx the half-width.
                     * @param {number} hy the half-height.
                     * @param {org.jbox2d.common.Vec2} center the center of the box in local coordinates.
                     * @param {number} angle the rotation of the box in local coordinates.
                     */
                    setAsBox(hx, hy, center, angle) {
                        if (((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && ((center != null && center instanceof org.jbox2d.common.Vec2) || center === null) && ((typeof angle === 'number') || angle === null)) {
                            return this.setAsBox$float$float$org_jbox2d_common_Vec2$float(hx, hy, center, angle);
                        }
                        else if (((typeof hx === 'number') || hx === null) && ((typeof hy === 'number') || hy === null) && center === undefined && angle === undefined) {
                            return this.setAsBox$float$float(hx, hy);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Return the number of vertices.
                     * @return {number}
                     */
                    getVertexCount() {
                        return this.vertices.length;
                    }
                }
                shapes.PolygonDef = PolygonDef;
                PolygonDef["__class"] = "org.jbox2d.collision.shapes.PolygonDef";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            class PairManager {
                constructor() {
                    if (this.m_pairs === undefined)
                        this.m_pairs = null;
                    if (this.m_pairCount === undefined)
                        this.m_pairCount = 0;
                    if (this.m_hashTable === undefined)
                        this.m_hashTable = null;
                    if (this.m_broadPhase === undefined)
                        this.m_broadPhase = null;
                    if (this.m_callback === undefined)
                        this.m_callback = null;
                    if (this.m_freePair === undefined)
                        this.m_freePair = 0;
                    if (this.m_pairBuffer === undefined)
                        this.m_pairBuffer = null;
                    if (this.m_pairBufferCount === undefined)
                        this.m_pairBufferCount = 0;
                    this.m_pairs = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
                    this.m_hashTable = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(PairManager.TABLE_CAPACITY_$LI$());
                    this.m_pairBuffer = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
                    for (let i = 0; i < PairManager.TABLE_CAPACITY_$LI$(); ++i) {
                        {
                            this.m_hashTable[i] = PairManager.NULL_PAIR_$LI$();
                        }
                        ;
                    }
                    this.m_freePair = 0;
                    for (let i = 0; i < org.jbox2d.common.Settings.maxPairs_$LI$(); ++i) {
                        {
                            this.m_pairs[i] = new org.jbox2d.collision.Pair();
                            this.m_pairs[i].proxyId1 = PairManager.NULL_PROXY_$LI$();
                            this.m_pairs[i].proxyId2 = PairManager.NULL_PROXY_$LI$();
                            this.m_pairs[i].userData = null;
                            this.m_pairs[i].status = 0;
                            this.m_pairs[i].next = i + 1;
                            this.m_pairBuffer[i] = new org.jbox2d.collision.BufferedPair();
                        }
                        ;
                    }
                    this.m_pairs[org.jbox2d.common.Settings.maxPairs_$LI$() - 1].next = PairManager.NULL_PAIR_$LI$();
                    this.m_pairCount = 0;
                    this.m_pairBufferCount = 0;
                }
                static NULL_PAIR_$LI$() { if (PairManager.NULL_PAIR == null)
                    PairManager.NULL_PAIR = 2147483647; return PairManager.NULL_PAIR; }
                ;
                static NULL_PROXY_$LI$() { if (PairManager.NULL_PROXY == null)
                    PairManager.NULL_PROXY = 2147483647; return PairManager.NULL_PROXY; }
                ;
                static TABLE_CAPACITY_$LI$() { if (PairManager.TABLE_CAPACITY == null)
                    PairManager.TABLE_CAPACITY = org.jbox2d.common.Settings.maxPairs_$LI$(); return PairManager.TABLE_CAPACITY; }
                ;
                static TABLE_MASK_$LI$() { if (PairManager.TABLE_MASK == null)
                    PairManager.TABLE_MASK = PairManager.TABLE_CAPACITY_$LI$() - 1; return PairManager.TABLE_MASK; }
                ;
                initialize(broadPhase, callback) {
                    this.m_broadPhase = broadPhase;
                    this.m_callback = callback;
                }
                addPair(proxyId1, proxyId2) {
                    if (proxyId1 > proxyId2) {
                        proxyId1 += proxyId2;
                        proxyId2 = proxyId1 - proxyId2;
                        proxyId1 -= proxyId2;
                    }
                    let hash = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
                    let pair = this.find$int$int$int(proxyId1, proxyId2, hash);
                    if (pair != null) {
                        return pair;
                    }
                    let pairIndex = this.m_freePair;
                    pair = this.m_pairs[pairIndex];
                    this.m_freePair = pair.next;
                    pair.proxyId1 = proxyId1;
                    pair.proxyId2 = proxyId2;
                    pair.status = 0;
                    pair.userData = null;
                    pair.next = this.m_hashTable[hash];
                    this.m_hashTable[hash] = pairIndex;
                    ++this.m_pairCount;
                    return pair;
                }
                removePair(proxyId1, proxyId2) {
                    if (proxyId1 > proxyId2) {
                        proxyId1 += proxyId2;
                        proxyId2 = proxyId1 - proxyId2;
                        proxyId1 -= proxyId2;
                    }
                    let hash = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
                    let derefnode = this.m_hashTable[hash];
                    let isHash = true;
                    let pderefnode = 0;
                    while ((derefnode !== PairManager.NULL_PAIR_$LI$())) {
                        {
                            if (this.equals$org_jbox2d_collision_Pair$int$int(this.m_pairs[derefnode], proxyId1, proxyId2)) {
                                let index = derefnode;
                                if (isHash) {
                                    this.m_hashTable[hash] = this.m_pairs[this.m_hashTable[hash]].next;
                                }
                                else {
                                    this.m_pairs[pderefnode].next = this.m_pairs[derefnode].next;
                                }
                                let pair = this.m_pairs[index];
                                let userData = pair.userData;
                                pair.next = this.m_freePair;
                                pair.proxyId1 = PairManager.NULL_PROXY_$LI$();
                                pair.proxyId2 = PairManager.NULL_PROXY_$LI$();
                                pair.userData = null;
                                pair.status = 0;
                                this.m_freePair = index;
                                --this.m_pairCount;
                                return userData;
                            }
                            else {
                                pderefnode = derefnode;
                                derefnode = this.m_pairs[derefnode].next;
                                isHash = false;
                            }
                        }
                    }
                    ;
                    return null;
                }
                /**
                 * Buffer a pair for addition.
                 * We may add a pair that is not in the pair manager or pair buffer.
                 * We may add a pair that is already in the pair manager and pair buffer.
                 * If the added pair is not a new pair, then it must be in the pair buffer (because RemovePair was called).
                 * @param {number} id1
                 * @param {number} id2
                 */
                addBufferedPair(id1, id2) {
                    let pair = this.addPair(id1, id2);
                    if (pair.isBuffered() === false) {
                        pair.setBuffered();
                        this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = pair.proxyId1;
                        this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = pair.proxyId2;
                        ++this.m_pairBufferCount;
                    }
                    pair.clearRemoved();
                    if (org.jbox2d.collision.BroadPhase.s_validate) {
                        this.validateBuffer();
                    }
                }
                /**
                 * Buffer a pair for removal.
                 * @param {number} id1
                 * @param {number} id2
                 */
                removeBufferedPair(id1, id2) {
                    let pair = this.find$int$int(id1, id2);
                    if (pair == null) {
                        return;
                    }
                    if (pair.isBuffered() === false) {
                        pair.setBuffered();
                        this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = pair.proxyId1;
                        this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = pair.proxyId2;
                        ++this.m_pairBufferCount;
                    }
                    pair.setRemoved();
                    if (org.jbox2d.collision.BroadPhase.s_validate) {
                        this.validateBuffer();
                    }
                }
                /**
                 * commits the proxies
                 */
                commit() {
                    let removeCount = 0;
                    let proxies = this.m_broadPhase.m_proxyPool;
                    for (let i = 0; i < this.m_pairBufferCount; ++i) {
                        {
                            let pair = this.find$int$int(this.m_pairBuffer[i].proxyId1, this.m_pairBuffer[i].proxyId2);
                            pair.clearBuffered();
                            let proxy1 = proxies[pair.proxyId1];
                            let proxy2 = proxies[pair.proxyId2];
                            if (pair.isRemoved()) {
                                if (pair.isFinal() === true) {
                                    this.m_callback.pairRemoved(proxy1.userData, proxy2.userData, pair.userData);
                                }
                                this.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1;
                                this.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2;
                                ++removeCount;
                            }
                            else {
                                if (pair.isFinal() === false) {
                                    pair.userData = this.m_callback.pairAdded(proxy1.userData, proxy2.userData);
                                    pair.setFinal();
                                }
                            }
                        }
                        ;
                    }
                    for (let i = 0; i < removeCount; ++i) {
                        {
                            this.removePair(this.m_pairBuffer[i].proxyId1, this.m_pairBuffer[i].proxyId2);
                        }
                        ;
                    }
                    this.m_pairBufferCount = 0;
                    if (org.jbox2d.collision.BroadPhase.s_validate) {
                        this.validateTable();
                    }
                }
                /**
                 * Unimplemented - for debugging purposes only in C++ version
                 */
                validateBuffer() {
                }
                /**
                 * For debugging
                 */
                validateTable() {
                    for (let i = 0; i < PairManager.TABLE_CAPACITY_$LI$(); ++i) {
                        {
                            let index = this.m_hashTable[i];
                            while ((index !== PairManager.NULL_PAIR_$LI$())) {
                                {
                                    let pair = this.m_pairs[index];
                                    let proxy1 = this.m_broadPhase.m_proxyPool[pair.proxyId1];
                                    let proxy2 = this.m_broadPhase.m_proxyPool[pair.proxyId2];
                                    index = pair.next;
                                }
                            }
                            ;
                        }
                        ;
                    }
                }
                find$int$int$int(proxyId1, proxyId2, hash) {
                    let index = this.m_hashTable[hash];
                    while ((index !== PairManager.NULL_PAIR_$LI$() && this.equals$org_jbox2d_collision_Pair$int$int(this.m_pairs[index], proxyId1, proxyId2) === false)) {
                        {
                            index = this.m_pairs[index].next;
                        }
                    }
                    ;
                    if (index === PairManager.NULL_PAIR_$LI$()) {
                        return null;
                    }
                    return this.m_pairs[index];
                }
                /**
                 * finds the pair with the given hash
                 * @param {number} proxyId1
                 * @param {number} proxyId2
                 * @param {number} hash
                 * @return
                 * @return {org.jbox2d.collision.Pair}
                 */
                find(proxyId1, proxyId2, hash) {
                    if (((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null) && ((typeof hash === 'number') || hash === null)) {
                        return this.find$int$int$int(proxyId1, proxyId2, hash);
                    }
                    else if (((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null) && hash === undefined) {
                        return this.find$int$int(proxyId1, proxyId2);
                    }
                    else
                        throw new Error('invalid overload');
                }
                find$int$int(proxyId1, proxyId2) {
                    if (proxyId1 > proxyId2) {
                        let tmp = proxyId1;
                        proxyId1 = proxyId2;
                        proxyId2 = tmp;
                    }
                    let hash = this.hash(proxyId1, proxyId2) & PairManager.TABLE_MASK_$LI$();
                    return this.find$int$int$int(proxyId1, proxyId2, hash);
                }
                /*private*/ hash(proxyId1, proxyId2) {
                    let key = (proxyId2 << 16) | proxyId1;
                    key = ~key + (key << 15);
                    key = key ^ (key >>> 12);
                    key = key + (key << 2);
                    key = key ^ (key >>> 4);
                    key = key * 2057;
                    key = key ^ (key >>> 16);
                    return key;
                }
                equals$org_jbox2d_collision_Pair$int$int(pair, proxyId1, proxyId2) {
                    return pair.proxyId1 === proxyId1 && pair.proxyId2 === proxyId2;
                }
                /**
                 * returns if the pair has the two proxy id's
                 * @param {org.jbox2d.collision.Pair} pair
                 * @param {number} proxyId1
                 * @param {number} proxyId2
                 * @return
                 * @return {boolean}
                 */
                equals(pair, proxyId1, proxyId2) {
                    if (((pair != null && pair instanceof org.jbox2d.collision.Pair) || pair === null) && ((typeof proxyId1 === 'number') || proxyId1 === null) && ((typeof proxyId2 === 'number') || proxyId2 === null)) {
                        return this.equals$org_jbox2d_collision_Pair$int$int(pair, proxyId1, proxyId2);
                    }
                    else if (((pair != null && pair instanceof org.jbox2d.collision.BufferedPair) || pair === null) && ((proxyId1 != null && proxyId1 instanceof org.jbox2d.collision.BufferedPair) || proxyId1 === null) && proxyId2 === undefined) {
                        return this.equals$org_jbox2d_collision_BufferedPair$org_jbox2d_collision_BufferedPair(pair, proxyId1);
                    }
                    else
                        throw new Error('invalid overload');
                }
                equals$org_jbox2d_collision_BufferedPair$org_jbox2d_collision_BufferedPair(pair1, pair2) {
                    return pair1.proxyId1 === pair2.proxyId1 && pair1.proxyId2 === pair2.proxyId2;
                }
                /**
                 * For sorting.  Returns if the first pair's proxyid's are less than the
                 * second pair, starting with proxyId1
                 * @param {org.jbox2d.collision.BufferedPair} pair1
                 * @param {org.jbox2d.collision.BufferedPair} pair2
                 * @return
                 * @return {boolean}
                 */
                minor(pair1, pair2) {
                    if (pair1.proxyId1 < pair2.proxyId1) {
                        return true;
                    }
                    if (pair1.proxyId1 === pair2.proxyId1) {
                        return pair1.proxyId2 < pair2.proxyId2;
                    }
                    return false;
                }
            }
            collision.PairManager = PairManager;
            PairManager["__class"] = "org.jbox2d.collision.PairManager";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            /**
             * A few math methods that don't fit very well anywhere else.
             * @class
             */
            class MathUtils {
                static __static_initialize() { if (!MathUtils.__static_initialized) {
                    MathUtils.__static_initialized = true;
                    MathUtils.__static_initializer_0();
                } }
                static PI_$LI$() { MathUtils.__static_initialize(); if (MathUtils.PI == null)
                    MathUtils.PI = Math.fround(Math.PI); return MathUtils.PI; }
                ;
                static TWOPI_$LI$() { MathUtils.__static_initialize(); if (MathUtils.TWOPI == null)
                    MathUtils.TWOPI = Math.fround((Math.PI * 2)); return MathUtils.TWOPI; }
                ;
                static sinLUT_$LI$() { MathUtils.__static_initialize(); if (MathUtils.sinLUT == null)
                    MathUtils.sinLUT = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()); return MathUtils.sinLUT; }
                ;
                static cosLUT_$LI$() { MathUtils.__static_initialize(); if (MathUtils.cosLUT == null)
                    MathUtils.cosLUT = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()); return MathUtils.cosLUT; }
                ;
                static __static_initializer_0() {
                    for (let i = 0; i < org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$(); i++) {
                        {
                            MathUtils.sinLUT_$LI$()[i] = Math.fround(Math.sin(Math.fround(i * org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)));
                            MathUtils.cosLUT_$LI$()[i] = Math.fround(Math.cos(Math.fround(i * org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)));
                        }
                        ;
                    }
                }
                static sin(x) {
                    if (org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                        x %= MathUtils.TWOPI_$LI$();
                        while ((x < 0)) {
                            {
                                x += MathUtils.TWOPI_$LI$();
                            }
                        }
                        ;
                        if (org.jbox2d.common.Settings.SINCOS_LUT_LERP) {
                            x /= org.jbox2d.common.Settings.SINCOS_LUT_PRECISION;
                            let index = (x | 0);
                            if (index !== 0) {
                                x %= index;
                            }
                            if (index === org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$() - 1) {
                                return (Math.fround(Math.fround((Math.fround(1 - x)) * MathUtils.sinLUT_$LI$()[index]) + Math.fround(x * MathUtils.sinLUT_$LI$()[0])));
                            }
                            else {
                                return (Math.fround(Math.fround((Math.fround(1 - x)) * MathUtils.sinLUT_$LI$()[index]) + Math.fround(x * MathUtils.sinLUT_$LI$()[index + 1])));
                            }
                        }
                        else {
                            return MathUtils.sinLUT_$LI$()[MathUtils.round(Math.fround(x / org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)) % org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()];
                        }
                    }
                    else {
                        return Math.fround(Math.sin(x));
                    }
                }
                static cos(x) {
                    if (org.jbox2d.common.Settings.SINCOS_LUT_ENABLED) {
                        x %= MathUtils.TWOPI_$LI$();
                        while ((x < 0)) {
                            {
                                x += MathUtils.TWOPI_$LI$();
                            }
                        }
                        ;
                        if (org.jbox2d.common.Settings.SINCOS_LUT_LERP) {
                            x /= org.jbox2d.common.Settings.SINCOS_LUT_PRECISION;
                            let index = (x | 0);
                            if (index !== 0) {
                                x %= index;
                            }
                            if (index === org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$() - 1) {
                                return (Math.fround(Math.fround((Math.fround(1 - x)) * MathUtils.cosLUT_$LI$()[index]) + Math.fround(x * MathUtils.cosLUT_$LI$()[0])));
                            }
                            else {
                                return (Math.fround(Math.fround((Math.fround(1 - x)) * MathUtils.cosLUT_$LI$()[index]) + Math.fround(x * MathUtils.cosLUT_$LI$()[index + 1])));
                            }
                        }
                        else {
                            return MathUtils.cosLUT_$LI$()[MathUtils.round(Math.fround(x / org.jbox2d.common.Settings.SINCOS_LUT_PRECISION)) % org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$()];
                        }
                    }
                    else {
                        return Math.fround(Math.cos(x));
                    }
                }
                static abs(x) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        return x > 0 ? x : -x;
                    }
                    else {
                        return Math.abs(x);
                    }
                }
                static floor(x) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        return x > 0 ? (x | 0) : (x | 0) - 1;
                    }
                    else {
                        return (Math.floor(x) | 0);
                    }
                }
                static ceil(x) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        return MathUtils.floor(Math.fround(x + 0.5));
                    }
                    else {
                        return (Math.ceil(x) | 0);
                    }
                }
                static round(x) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        return MathUtils.floor(Math.fround(x + 0.5));
                    }
                    else {
                        return Math.round(x);
                    }
                }
                static max$float$float(a, b) {
                    return a > b ? a : b;
                }
                static max$int$int(a, b) {
                    return a > b ? a : b;
                }
                static max(a, b) {
                    if (((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                        return org.jbox2d.common.MathUtils.max$int$int(a, b);
                    }
                    else if (((typeof a === 'number') || a === null) && ((typeof b === 'number') || b === null)) {
                        return org.jbox2d.common.MathUtils.max$float$float(a, b);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static min(a, b) {
                    return a < b ? a : b;
                }
                static map(val, fromMin, fromMax, toMin, toMax) {
                    let mult = Math.fround((Math.fround(val - fromMin)) / (Math.fround(fromMax - fromMin)));
                    let res = Math.fround(toMin + Math.fround(mult * (Math.fround(toMax - toMin))));
                    return res;
                }
                static clamp$float$float$float(a, low, high) {
                    return MathUtils.max$float$float(low, MathUtils.min(a, high));
                }
                static clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, low, high) {
                    let min = new org.jbox2d.common.Vec2();
                    org.jbox2d.common.Vec2.minToOut(a, high, min);
                    org.jbox2d.common.Vec2.maxToOut(low, min, min);
                    return min;
                }
                static clamp(a, low, high) {
                    if (((a != null && a instanceof org.jbox2d.common.Vec2) || a === null) && ((low != null && low instanceof org.jbox2d.common.Vec2) || low === null) && ((high != null && high instanceof org.jbox2d.common.Vec2) || high === null)) {
                        return org.jbox2d.common.MathUtils.clamp$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(a, low, high);
                    }
                    else if (((typeof a === 'number') || a === null) && ((typeof low === 'number') || low === null) && ((typeof high === 'number') || high === null)) {
                        return org.jbox2d.common.MathUtils.clamp$float$float$float(a, low, high);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static clampToOut(a, low, high, dest) {
                    org.jbox2d.common.Vec2.minToOut(a, high, dest);
                    org.jbox2d.common.Vec2.maxToOut(low, dest, dest);
                }
                /**
                 * Next Largest Power of 2: Given a binary integer value x, the next largest
                 * power of 2 can be computed by a SWAR algorithm that recursively "folds"
                 * the upper bits into the lower bits. This process yields a bit vector with
                 * the same most significant 1 as x, but all 1's below it. Adding 1 to that
                 * value yields the next largest power of 2.
                 * @param {number} x
                 * @return {number}
                 */
                static nextPowerOfTwo(x) {
                    x |= x >> 1;
                    x |= x >> 2;
                    x |= x >> 4;
                    x |= x >> 8;
                    x |= x >> 16;
                    return x + 1;
                }
                static isPowerOfTwo(x) {
                    return x > 0 && (x & x - 1) === 0;
                }
                static atan2(y, x) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        let abs_y = Math.fround(MathUtils.abs(y) + 1.0E-10);
                        let angle;
                        let r;
                        if (x >= 0) {
                            r = Math.fround((Math.fround(x - abs_y)) / (Math.fround(x + abs_y)));
                            angle = Math.fround(Math.fround(Math.fround(Math.fround(Math.fround(0.1963 * r) * r) * r) - Math.fround(0.9817 * r)) + Math.fround(org.jbox2d.common.Settings.pi_$LI$() / 4));
                        }
                        else {
                            r = Math.fround((Math.fround(x + abs_y)) / (Math.fround(abs_y - x)));
                            angle = Math.fround(Math.fround(Math.fround(Math.fround(Math.fround(0.1963 * r) * r) * r) - Math.fround(0.9817 * r)) + Math.fround(Math.fround(3 * org.jbox2d.common.Settings.pi_$LI$()) / 4));
                        }
                        if (y < 0) {
                            return -angle;
                        }
                        else {
                            return angle;
                        }
                    }
                    else {
                        return Math.fround(Math.atan2(y, x));
                    }
                }
                /**
                 * Computes a fast approximation to <code>Math.pow(a, b)</code>.
                 * Adapted from <url>http://www.dctsystems.co.uk/Software/power.html</url>.
                 *
                 * @param {number} a
                 * a positive number
                 * @param {number} b
                 * a number
                 * @return {number} a^b
                 */
                static pow(a, b) {
                    if (org.jbox2d.common.Settings.FAST_MATH) {
                        let x = ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(a);
                        x *= Math.fround(1.0 / (1 << 23));
                        x = Math.fround(x - 127);
                        let y = Math.fround(x - MathUtils.floor(x));
                        b *= Math.fround(x + Math.fround((Math.fround(y - Math.fround(y * y))) * 0.346607));
                        y = Math.fround(b - MathUtils.floor(b));
                        y = Math.fround((Math.fround(y - Math.fround(y * y))) * 0.33971);
                        return ((v) => { let buf = new ArrayBuffer(4); (new Uint32Array(buf))[0] = v; return (new Float32Array(buf))[0]; })(((Math.fround((Math.fround(Math.fround(b + 127) - y)) * (1 << 23))) | 0));
                    }
                    else {
                        return Math.fround(Math.pow(a, b));
                    }
                }
                static sqrt(x) {
                    return Math.fround(Math.sqrt(x));
                }
                static invSqrt(x) {
                    let xhalf = Math.fround(0.5 * x);
                    let i = ((f) => { let buf = new ArrayBuffer(4); (new Float32Array(buf))[0] = f; return (new Uint32Array(buf))[0]; })(x);
                    i = 1597463007 - (i >> 1);
                    x = ((v) => { let buf = new ArrayBuffer(4); (new Uint32Array(buf))[0] = v; return (new Float32Array(buf))[0]; })(i);
                    x *= Math.fround(1.5 - Math.fround(Math.fround(xhalf * x) * x));
                    x *= Math.fround(1.5 - Math.fround(Math.fround(xhalf * x) * x));
                    x *= Math.fround(1.5 - Math.fround(Math.fround(xhalf * x) * x));
                    x *= Math.fround(1.5 - Math.fround(Math.fround(xhalf * x) * x));
                    return x;
                }
            }
            MathUtils.__static_initialized = false;
            common.MathUtils = MathUtils;
            MathUtils["__class"] = "org.jbox2d.common.MathUtils";
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var nonconvex;
            (function (nonconvex) {
                /**
                 *
                 * @author ewjordan
                 * @param {Array} _x
                 * @param {Array} _y
                 * @param {number} nVert
                 * @class
                 */
                class Polygon {
                    constructor(_x, _y, nVert) {
                        if (((_x != null && _x instanceof Array && (_x.length == 0 || _x[0] == null || (typeof _x[0] === 'number'))) || _x === null) && ((_y != null && _y instanceof Array && (_y.length == 0 || _y[0] == null || (typeof _y[0] === 'number'))) || _y === null) && ((typeof nVert === 'number') || nVert === null)) {
                            let __args = arguments;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            (() => {
                                this.nVertices = nVert;
                                this.x = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                this.y = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                for (let i = 0; i < this.nVertices; ++i) {
                                    {
                                        this.x[i] = _x[i];
                                        this.y[i] = _y[i];
                                    }
                                    ;
                                }
                                this.areaIsSet = false;
                            })();
                        }
                        else if (((_x != null && _x instanceof Array && (_x.length == 0 || _x[0] == null || (typeof _x[0] === 'number'))) || _x === null) && ((_y != null && _y instanceof Array && (_y.length == 0 || _y[0] == null || (typeof _y[0] === 'number'))) || _y === null) && nVert === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let nVert = __args[0].length;
                                if (this.nVertices === undefined)
                                    this.nVertices = 0;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                if (this.areaIsSet === undefined)
                                    this.areaIsSet = false;
                                if (this.area === undefined)
                                    this.area = 0;
                                if (this.nVertices === undefined)
                                    this.nVertices = 0;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                if (this.areaIsSet === undefined)
                                    this.areaIsSet = false;
                                if (this.area === undefined)
                                    this.area = 0;
                                (() => {
                                    this.nVertices = nVert;
                                    this.x = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(this.nVertices);
                                    this.y = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(this.nVertices);
                                    for (let i = 0; i < this.nVertices; ++i) {
                                        {
                                            this.x[i] = _x[i];
                                            this.y[i] = _y[i];
                                        }
                                        ;
                                    }
                                    this.areaIsSet = false;
                                })();
                            }
                        }
                        else if (((_x != null && _x instanceof Array && (_x.length == 0 || _x[0] == null || (_x[0] != null && _x[0] instanceof org.jbox2d.common.Vec2))) || _x === null) && ((typeof _y === 'number') || _y === null) && nVert === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            let nVert = __args[1];
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            (() => {
                                this.nVertices = nVert;
                                this.x = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                this.y = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                for (let i = 0; i < this.nVertices; ++i) {
                                    {
                                        this.x[i] = v[i].x;
                                        this.y[i] = v[i].y;
                                    }
                                    ;
                                }
                                this.areaIsSet = false;
                            })();
                        }
                        else if (((_x != null && _x instanceof Array && (_x.length == 0 || _x[0] == null || (_x[0] != null && _x[0] instanceof org.jbox2d.common.Vec2))) || _x === null) && _y === undefined && nVert === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            {
                                let __args = arguments;
                                let nVert = __args[0].length;
                                if (this.nVertices === undefined)
                                    this.nVertices = 0;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                if (this.areaIsSet === undefined)
                                    this.areaIsSet = false;
                                if (this.area === undefined)
                                    this.area = 0;
                                if (this.nVertices === undefined)
                                    this.nVertices = 0;
                                if (this.x === undefined)
                                    this.x = null;
                                if (this.y === undefined)
                                    this.y = null;
                                if (this.areaIsSet === undefined)
                                    this.areaIsSet = false;
                                if (this.area === undefined)
                                    this.area = 0;
                                (() => {
                                    this.nVertices = nVert;
                                    this.x = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(this.nVertices);
                                    this.y = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(this.nVertices);
                                    for (let i = 0; i < this.nVertices; ++i) {
                                        {
                                            this.x[i] = v[i].x;
                                            this.y[i] = v[i].y;
                                        }
                                        ;
                                    }
                                    this.areaIsSet = false;
                                })();
                            }
                        }
                        else if (((_x != null && _x instanceof org.jbox2d.util.nonconvex.Triangle) || _x === null) && _y === undefined && nVert === undefined) {
                            let __args = arguments;
                            let t = __args[0];
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            (() => {
                                this.nVertices = 3;
                                this.x = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                this.y = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.nVertices);
                                for (let i = 0; i < this.nVertices; ++i) {
                                    {
                                        this.x[i] = t.x[i];
                                        this.y[i] = t.y[i];
                                    }
                                    ;
                                }
                            })();
                        }
                        else if (_x === undefined && _y === undefined && nVert === undefined) {
                            let __args = arguments;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            if (this.nVertices === undefined)
                                this.nVertices = 0;
                            if (this.x === undefined)
                                this.x = null;
                            if (this.y === undefined)
                                this.y = null;
                            if (this.areaIsSet === undefined)
                                this.areaIsSet = false;
                            if (this.area === undefined)
                                this.area = 0;
                            (() => {
                                this.x = null;
                                this.y = null;
                                this.nVertices = 0;
                                this.areaIsSet = false;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static toiSlop_$LI$() { if (Polygon.toiSlop == null)
                        Polygon.toiSlop = org.jbox2d.common.Settings.toiSlop_$LI$(); return Polygon.toiSlop; }
                    ;
                    static COLLAPSE_DIST_SQR_$LI$() { if (Polygon.COLLAPSE_DIST_SQR == null)
                        Polygon.COLLAPSE_DIST_SQR = Math.fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON); return Polygon.COLLAPSE_DIST_SQR; }
                    ;
                    static maxPolygonVertices_$LI$() { if (Polygon.maxPolygonVertices == null)
                        Polygon.maxPolygonVertices = org.jbox2d.common.Settings.maxPolygonVertices; return Polygon.maxPolygonVertices; }
                    ;
                    /**
                     * Check if the lines a0->a1 and b0->b1 cross.
                     * If they do, intersectionPoint will be filled
                     * with the point of crossing.
                     *
                     * Grazing lines should not return true, though
                     * this is not very robust.
                     *
                     * @param {org.jbox2d.common.Vec2} a0
                     * @param {org.jbox2d.common.Vec2} a1
                     * @param {org.jbox2d.common.Vec2} b0
                     * @param {org.jbox2d.common.Vec2} b1
                     * @param {org.jbox2d.common.Vec2} intersectionPoint
                     * @return {boolean}
                     */
                    static intersect(a0, a1, b0, b1, intersectionPoint) {
                        if (a0 === b0 || a0 === b1 || a1 === b0 || a1 === b1)
                            return false;
                        let x1 = a0.x;
                        let y1 = a0.y;
                        let x2 = a1.x;
                        let y2 = a1.y;
                        let x3 = b0.x;
                        let y3 = b0.y;
                        let x4 = b1.x;
                        let y4 = b1.y;
                        if (org.jbox2d.common.MathUtils.max$float$float(x1, x2) < org.jbox2d.common.MathUtils.min(x3, x4) || org.jbox2d.common.MathUtils.max$float$float(x3, x4) < org.jbox2d.common.MathUtils.min(x1, x2))
                            return false;
                        if (org.jbox2d.common.MathUtils.max$float$float(y1, y2) < org.jbox2d.common.MathUtils.min(y3, y4) || org.jbox2d.common.MathUtils.max$float$float(y3, y4) < org.jbox2d.common.MathUtils.min(y1, y2))
                            return false;
                        let ua = (Math.fround(Math.fround((Math.fround(x4 - x3)) * (Math.fround(y1 - y3))) - Math.fround((Math.fround(y4 - y3)) * (Math.fround(x1 - x3)))));
                        let ub = (Math.fround(Math.fround((Math.fround(x2 - x1)) * (Math.fround(y1 - y3))) - Math.fround((Math.fround(y2 - y1)) * (Math.fround(x1 - x3)))));
                        let denom = Math.fround(Math.fround((Math.fround(y4 - y3)) * (Math.fround(x2 - x1))) - Math.fround((Math.fround(x4 - x3)) * (Math.fround(y2 - y1))));
                        if (org.jbox2d.common.MathUtils.abs(denom) < org.jbox2d.common.Settings.EPSILON) {
                            return false;
                        }
                        ua /= denom;
                        ub /= denom;
                        if ((0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)) {
                            intersectionPoint.x = (Math.fround(x1 + Math.fround(ua * (Math.fround(x2 - x1)))));
                            intersectionPoint.y = (Math.fround(y1 + Math.fround(ua * (Math.fround(y2 - y1)))));
                            return true;
                        }
                        return false;
                    }
                    intersect(a0, a1, b0, b1) {
                        let myVec = new org.jbox2d.common.Vec2(0.0, 0.0);
                        return Polygon.intersect(a0, a1, b0, b1, myVec);
                    }
                    getArea() {
                        this.area = 0.0;
                        this.area += Math.fround(Math.fround(this.x[this.nVertices - 1] * this.y[0]) - Math.fround(this.x[0] * this.y[this.nVertices - 1]));
                        for (let i = 0; i < this.nVertices - 1; ++i) {
                            {
                                this.area += Math.fround(Math.fround(this.x[i] * this.y[i + 1]) - Math.fround(this.x[i + 1] * this.y[i]));
                            }
                            ;
                        }
                        this.area *= 0.5;
                        this.areaIsSet = true;
                        return this.area;
                    }
                    isCCW() {
                        return (this.getArea() > 0.0);
                    }
                    mergeParallelEdges(tolerance) {
                        if (this.nVertices <= 3)
                            return;
                        let mergeMe = (s => { let a = []; while (s-- > 0)
                            a.push(false); return a; })(this.nVertices);
                        let newNVertices = this.nVertices;
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                let lower = (i === 0) ? (this.nVertices - 1) : (i - 1);
                                let middle = i;
                                let upper = (i === this.nVertices - 1) ? (0) : (i + 1);
                                let dx0 = Math.fround(this.x[middle] - this.x[lower]);
                                let dy0 = Math.fround(this.y[middle] - this.y[lower]);
                                let dx1 = Math.fround(this.x[upper] - this.x[middle]);
                                let dy1 = Math.fround(this.y[upper] - this.y[middle]);
                                let norm0 = Math.fround(Math.sqrt(Math.fround(Math.fround(dx0 * dx0) + Math.fround(dy0 * dy0))));
                                let norm1 = Math.fround(Math.sqrt(Math.fround(Math.fround(dx1 * dx1) + Math.fround(dy1 * dy1))));
                                if (!(norm0 > 0.0 && norm1 > 0.0) && newNVertices > 3) {
                                    mergeMe[i] = true;
                                    --newNVertices;
                                }
                                dx0 /= norm0;
                                dy0 /= norm0;
                                dx1 /= norm1;
                                dy1 /= norm1;
                                let cross = Math.fround(Math.fround(dx0 * dy1) - Math.fround(dx1 * dy0));
                                let dot = Math.fround(Math.fround(dx0 * dx1) + Math.fround(dy0 * dy1));
                                if (org.jbox2d.common.MathUtils.abs(cross) < tolerance && dot > 0 && newNVertices > 3) {
                                    mergeMe[i] = true;
                                    --newNVertices;
                                }
                                else {
                                    mergeMe[i] = false;
                                }
                            }
                            ;
                        }
                        if (newNVertices === this.nVertices || newNVertices === 0) {
                            return;
                        }
                        let newx = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(newNVertices);
                        let newy = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(newNVertices);
                        let currIndex = 0;
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                if (mergeMe[i] || newNVertices === 0 || currIndex === newNVertices)
                                    continue;
                                newx[currIndex] = this.x[i];
                                newy[currIndex] = this.y[i];
                                ++currIndex;
                            }
                            ;
                        }
                        this.x = newx;
                        this.y = newy;
                        this.nVertices = newNVertices;
                    }
                    getVertexVecs() {
                        let out = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.nVertices);
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                out[i] = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
                            }
                            ;
                        }
                        return out;
                    }
                    set(p) {
                        if (this.nVertices !== p.nVertices) {
                            this.nVertices = p.nVertices;
                            this.x = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(this.nVertices);
                            this.y = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(this.nVertices);
                        }
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                this.x[i] = p.x[i];
                                this.y[i] = p.y[i];
                            }
                            ;
                        }
                        this.areaIsSet = false;
                    }
                    /**
                     * Assuming the polygon is simple, checks if it is convex.
                     * @return {boolean}
                     */
                    isConvex() {
                        let isPositive = false;
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                let lower = (i === 0) ? (this.nVertices - 1) : (i - 1);
                                let middle = i;
                                let upper = (i === this.nVertices - 1) ? (0) : (i + 1);
                                let dx0 = Math.fround(this.x[middle] - this.x[lower]);
                                let dy0 = Math.fround(this.y[middle] - this.y[lower]);
                                let dx1 = Math.fround(this.x[upper] - this.x[middle]);
                                let dy1 = Math.fround(this.y[upper] - this.y[middle]);
                                let cross = Math.fround(Math.fround(dx0 * dy1) - Math.fround(dx1 * dy0));
                                let newIsP = (cross >= 0) ? true : false;
                                if (i === 0) {
                                    isPositive = newIsP;
                                }
                                else if (isPositive !== newIsP) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    }
                    static polyCentroid(vs, count) {
                        let c = new org.jbox2d.common.Vec2(0.0, 0.0);
                        let area = 0.0;
                        let inv3 = Math.fround(1.0 / 3.0);
                        let pRef = new org.jbox2d.common.Vec2(0.0, 0.0);
                        for (let i = 0; i < count; ++i) {
                            {
                                let p1 = pRef;
                                let p2 = vs[i];
                                let p3 = i + 1 < count ? vs[i + 1] : vs[0];
                                let e1 = p2.sub(p1);
                                let e2 = p3.sub(p1);
                                let D = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                                let triangleArea = Math.fround(0.5 * D);
                                area += triangleArea;
                                c.x += Math.fround(Math.fround(triangleArea * inv3) * (Math.fround(Math.fround(p1.x + p2.x) + p3.x)));
                                c.y += Math.fround(Math.fround(triangleArea * inv3) * (Math.fround(Math.fround(p1.y + p2.y) + p3.y)));
                            }
                            ;
                        }
                        c.x *= Math.fround(1.0 / area);
                        c.y *= Math.fround(1.0 / area);
                        return c;
                    }
                    isUsable$boolean(printErrors) {
                        let error = -1;
                        let noError = true;
                        if (this.nVertices < 3 || this.nVertices > Polygon.maxPolygonVertices_$LI$()) {
                            noError = false;
                            error = 0;
                        }
                        if (!this.isConvex()) {
                            noError = false;
                            error = 1;
                        }
                        if (!this.isSimple()) {
                            noError = false;
                            error = 2;
                        }
                        if (this.getArea() < org.jbox2d.common.Settings.EPSILON) {
                            noError = false;
                            error = 3;
                        }
                        let normals = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.nVertices);
                        let vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.nVertices);
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                vertices[i] = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
                                let i1 = i;
                                let i2 = i + 1 < this.nVertices ? i + 1 : 0;
                                let edge = new org.jbox2d.common.Vec2(Math.fround(this.x[i2] - this.x[i1]), Math.fround(this.y[i2] - this.y[i1]));
                                normals[i] = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(edge, 1.0);
                                normals[i].normalize();
                            }
                            ;
                        }
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                let iminus = (i === 0) ? this.nVertices - 1 : i - 1;
                                let cross = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(normals[iminus], normals[i]);
                                cross = org.jbox2d.common.MathUtils.clamp$float$float$float(cross, -1.0, 1.0);
                                let angle = Math.fround(Math.asin(cross));
                                if (angle <= org.jbox2d.common.Settings.angularSlop_$LI$()) {
                                    noError = false;
                                    error = 4;
                                    break;
                                }
                                for (let j = 0; j < this.nVertices; ++j) {
                                    {
                                        if (j === i || j === (i + 1) % this.nVertices) {
                                            continue;
                                        }
                                        let s = org.jbox2d.common.Vec2.dot(normals[i], vertices[j].sub(vertices[i]));
                                        if (s >= -org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                            noError = false;
                                            error = 5;
                                        }
                                    }
                                    ;
                                }
                                let centroid = Polygon.polyCentroid(vertices, this.nVertices);
                                let n1 = normals[iminus];
                                let n2 = normals[i];
                                let v = vertices[i].sub(centroid);
                                let d = new org.jbox2d.common.Vec2();
                                d.x = Math.fround(org.jbox2d.common.Vec2.dot(n1, v) - Polygon.toiSlop_$LI$());
                                d.y = Math.fround(org.jbox2d.common.Vec2.dot(n2, v) - Polygon.toiSlop_$LI$());
                                if ((d.x < 0.0) || (d.y < 0.0)) {
                                    noError = false;
                                    error = 6;
                                }
                            }
                            ;
                        }
                        if (!noError && printErrors) {
                            console.info("Found invalid polygon, ");
                            switch ((error)) {
                                case 0:
                                    console.info("must have between 3 and " + org.jbox2d.common.Settings.maxPolygonVertices + " vertices.");
                                    break;
                                case 1:
                                    console.info("must be convex.\n");
                                    break;
                                case 2:
                                    console.info("must be simple (cannot intersect itself).\n");
                                    break;
                                case 3:
                                    console.info("area is too small.\n");
                                    break;
                                case 4:
                                    console.info("sides are too close to parallel.\n");
                                    break;
                                case 5:
                                    console.info("polygon is too thin.\n");
                                    break;
                                case 6:
                                    console.info("core shape generation would move edge past centroid (too thin).\n");
                                    break;
                                default:
                                    console.info("don\'t know why.\n");
                                    ;
                            }
                        }
                        return noError;
                    }
                    /**
                     * Checks if polygon is valid for use in Box2d engine.
                     * Last ditch effort to ensure no invalid polygons are
                     * added to world geometry.
                     *
                     * Performs a full check, for simplicity, convexity,
                     * orientation, minimum angle, and volume.  This won't
                     * be very efficient, and a lot of it is redundant when
                     * other tools in this section are used.
                     * @param {boolean} printErrors
                     * @return {boolean}
                     */
                    isUsable(printErrors) {
                        if (((typeof printErrors === 'boolean') || printErrors === null)) {
                            return this.isUsable$boolean(printErrors);
                        }
                        else if (printErrors === undefined) {
                            return this.isUsable$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    isUsable$() {
                        return this.isUsable$boolean(Polygon.B2_POLYGON_REPORT_ERRORS);
                    }
                    isSimple() {
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                let iplus = (i + 1 > this.nVertices - 1) ? 0 : i + 1;
                                let a1 = new org.jbox2d.common.Vec2(this.x[i], this.y[i]);
                                let a2 = new org.jbox2d.common.Vec2(this.x[iplus], this.y[iplus]);
                                for (let j = i + 1; j < this.nVertices; ++j) {
                                    {
                                        let jplus = (j + 1 > this.nVertices - 1) ? 0 : j + 1;
                                        let b1 = new org.jbox2d.common.Vec2(this.x[j], this.y[j]);
                                        let b2 = new org.jbox2d.common.Vec2(this.x[jplus], this.y[jplus]);
                                        if (this.intersect(a1, a2, b1, b2)) {
                                            return false;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return true;
                    }
                    /**
                     * Tries to add a triangle to the polygon. Returns null if it can't connect
                     * properly, otherwise returns a pointer to the new Polygon. Assumes bitwise
                     * equality of joined vertex positions.
                     *
                     * Remember to delete the pointer afterwards.
                     * TODO: Make this return a Polygon instead
                     * of a pointer to a heap-allocated one.
                     *
                     * For internal use.
                     * @param {org.jbox2d.util.nonconvex.Triangle} t
                     * @return {org.jbox2d.util.nonconvex.Polygon}
                     */
                    add(t) {
                        let firstP = -1;
                        let firstT = -1;
                        let secondP = -1;
                        let secondT = -1;
                        for (let i = 0; i < this.nVertices; i++) {
                            {
                                if (t.x[0] === this.x[i] && t.y[0] === this.y[i]) {
                                    if (firstP === -1) {
                                        firstP = i;
                                        firstT = 0;
                                    }
                                    else {
                                        secondP = i;
                                        secondT = 0;
                                    }
                                }
                                else if (t.x[1] === this.x[i] && t.y[1] === this.y[i]) {
                                    if (firstP === -1) {
                                        firstP = i;
                                        firstT = 1;
                                    }
                                    else {
                                        secondP = i;
                                        secondT = 1;
                                    }
                                }
                                else if (t.x[2] === this.x[i] && t.y[2] === this.y[i]) {
                                    if (firstP === -1) {
                                        firstP = i;
                                        firstT = 2;
                                    }
                                    else {
                                        secondP = i;
                                        secondT = 2;
                                    }
                                }
                                else {
                                }
                            }
                            ;
                        }
                        if (firstP === 0 && secondP === this.nVertices - 1) {
                            firstP = this.nVertices - 1;
                            secondP = 0;
                        }
                        if (secondP === -1) {
                            return null;
                        }
                        let tipT = 0;
                        if (tipT === firstT || tipT === secondT)
                            tipT = 1;
                        if (tipT === firstT || tipT === secondT)
                            tipT = 2;
                        let newx = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(this.nVertices + 1);
                        let newy = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(this.nVertices + 1);
                        let currOut = 0;
                        for (let i = 0; i < this.nVertices; i++) {
                            {
                                newx[currOut] = this.x[i];
                                newy[currOut] = this.y[i];
                                if (i === firstP) {
                                    ++currOut;
                                    newx[currOut] = t.x[tipT];
                                    newy[currOut] = t.y[tipT];
                                }
                                ++currOut;
                            }
                            ;
                        }
                        let result = new Polygon(newx, newy, this.nVertices + 1);
                        return result;
                    }
                    /**
                     * Adds this polygon to a PolyDef.
                     * @param {org.jbox2d.collision.shapes.PolygonDef} pd
                     */
                    addTo(pd) {
                        if (this.nVertices < 3)
                            return;
                        let vecs = this.getVertexVecs();
                        let offset = 0;
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                if (vecs[i].x === vecs[Polygon.remainder(i + 1, this.nVertices)].x && vecs[i].y === vecs[Polygon.remainder(i + 1, this.nVertices)].y) {
                                    offset++;
                                    continue;
                                }
                                /* add */ (pd.vertices.push(vecs[i]) > 0);
                            }
                            ;
                        }
                    }
                    /**
                     * Finds and fixes "pinch points," points where two polygon
                     * vertices are at the same point.
                     *
                     * If a pinch point is found, pin is broken up into poutA and poutB
                     * and true is returned; otherwise, returns false.
                     *
                     * Mostly for internal use.
                     *
                     * O(N^2) time, which sucks...
                     * @param {org.jbox2d.util.nonconvex.Polygon} pin
                     * @param {org.jbox2d.util.nonconvex.Polygon} poutA
                     * @param {org.jbox2d.util.nonconvex.Polygon} poutB
                     * @return {boolean}
                     * @private
                     */
                    /*private*/ static resolvePinchPoint(pin, poutA, poutB) {
                        if (pin.nVertices < 3)
                            return false;
                        let tol = 0.001;
                        let hasPinchPoint = false;
                        let pinchIndexA = -1;
                        let pinchIndexB = -1;
                        for (let i = 0; i < pin.nVertices; ++i) {
                            {
                                for (let j = i + 1; j < pin.nVertices; ++j) {
                                    {
                                        if (org.jbox2d.common.MathUtils.abs(Math.fround(pin.x[i] - pin.x[j])) < tol && org.jbox2d.common.MathUtils.abs(Math.fround(pin.y[i] - pin.y[j])) < tol && j !== i + 1) {
                                            pinchIndexA = i;
                                            pinchIndexB = j;
                                            hasPinchPoint = true;
                                            break;
                                        }
                                    }
                                    ;
                                }
                                if (hasPinchPoint)
                                    break;
                            }
                            ;
                        }
                        if (hasPinchPoint) {
                            let sizeA = pinchIndexB - pinchIndexA;
                            if (sizeA === pin.nVertices)
                                return false;
                            let xA = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(sizeA);
                            let yA = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(sizeA);
                            for (let i = 0; i < sizeA; ++i) {
                                {
                                    let ind = Polygon.remainder(pinchIndexA + i, pin.nVertices);
                                    xA[i] = pin.x[ind];
                                    yA[i] = pin.y[ind];
                                }
                                ;
                            }
                            let tempA = new Polygon(xA, yA, sizeA);
                            poutA.set(tempA);
                            let sizeB = pin.nVertices - sizeA;
                            let xB = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(sizeB);
                            let yB = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(sizeB);
                            for (let i = 0; i < sizeB; ++i) {
                                {
                                    let ind = Polygon.remainder(pinchIndexB + i, pin.nVertices);
                                    xB[i] = pin.x[ind];
                                    yB[i] = pin.y[ind];
                                }
                                ;
                            }
                            let tempB = new Polygon(xB, yB, sizeB);
                            poutB.set(tempB);
                        }
                        return hasPinchPoint;
                    }
                    /**
                     * Triangulates a polygon using simple ear-clipping algorithm. Returns
                     * size of Triangle array unless the polygon can't be triangulated.
                     * This should only happen if the polygon self-intersects,
                     * though it will not _always_ return null for a bad polygon - it is the
                     * caller's responsibility to check for self-intersection, and if it
                     * doesn't, it should at least check that the return value is non-null
                     * before using. You're warned!
                     *
                     * Triangles may be degenerate, especially if you have identical points
                     * in the input to the algorithm.  Check this before you use them.
                     *
                     * This is totally unoptimized, so for large polygons it should not be part
                     * of the simulation loop.
                     *
                     * Returns:
                     * -1 if algorithm fails (self-intersection most likely)
                     * 0 if there are not enough vertices to triangulate anything.
                     * Number of triangles if triangulation was successful.
                     *
                     * results will be filled with results - ear clipping always creates vNum - 2
                     * or fewer (due to pinch point polygon snipping), so allocate an array of
                     * this size.
                     * @param {Array} xv
                     * @param {Array} yv
                     * @param {number} vNum
                     * @param {Array} results
                     * @return {number}
                     */
                    static triangulatePolygon(xv, yv, vNum, results) {
                        if (vNum < 3)
                            return 0;
                        let pA = new Polygon();
                        let pB = new Polygon();
                        let pin = new Polygon(xv, yv, vNum);
                        if (Polygon.resolvePinchPoint(pin, pA, pB)) {
                            let mergeA = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(pA.nVertices);
                            let mergeB = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(pB.nVertices);
                            for (let i = 0; i < pA.nVertices; ++i) {
                                {
                                    mergeA[i] = new org.jbox2d.util.nonconvex.Triangle();
                                }
                                ;
                            }
                            for (let i = 0; i < pB.nVertices; ++i) {
                                {
                                    mergeB[i] = new org.jbox2d.util.nonconvex.Triangle();
                                }
                                ;
                            }
                            let nA = Polygon.triangulatePolygon(pA.x, pA.y, pA.nVertices, mergeA);
                            let nB = Polygon.triangulatePolygon(pB.x, pB.y, pB.nVertices, mergeB);
                            if (nA === -1 || nB === -1) {
                                return -1;
                            }
                            for (let i = 0; i < nA; ++i) {
                                {
                                    results[i].set(mergeA[i]);
                                }
                                ;
                            }
                            for (let i = 0; i < nB; ++i) {
                                {
                                    results[nA + i].set(mergeB[i]);
                                }
                                ;
                            }
                            return (nA + nB);
                        }
                        let buffer = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(vNum - 2);
                        for (let i = 0; i < buffer.length; ++i) {
                            {
                                buffer[i] = new org.jbox2d.util.nonconvex.Triangle();
                            }
                            ;
                        }
                        let bufferSize = 0;
                        let xrem = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(vNum);
                        let yrem = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(vNum);
                        for (let i = 0; i < vNum; ++i) {
                            {
                                xrem[i] = xv[i];
                                yrem[i] = yv[i];
                            }
                            ;
                        }
                        let xremLength = vNum;
                        while ((vNum > 3)) {
                            {
                                let earIndex = -1;
                                let earMaxMinCross = -1000.0;
                                for (let i = 0; i < vNum; ++i) {
                                    {
                                        if (Polygon.isEar(i, xrem, yrem, vNum)) {
                                            let lower = Polygon.remainder(i - 1, vNum);
                                            let upper = Polygon.remainder(i + 1, vNum);
                                            let d1 = new org.jbox2d.common.Vec2(Math.fround(xrem[upper] - xrem[i]), Math.fround(yrem[upper] - yrem[i]));
                                            let d2 = new org.jbox2d.common.Vec2(Math.fround(xrem[i] - xrem[lower]), Math.fround(yrem[i] - yrem[lower]));
                                            let d3 = new org.jbox2d.common.Vec2(Math.fround(xrem[lower] - xrem[upper]), Math.fround(yrem[lower] - yrem[upper]));
                                            d1.normalize();
                                            d2.normalize();
                                            d3.normalize();
                                            let cross12 = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d1, d2));
                                            let cross23 = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d2, d3));
                                            let cross31 = org.jbox2d.common.MathUtils.abs(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(d3, d1));
                                            let minCross = org.jbox2d.common.MathUtils.min(cross12, org.jbox2d.common.MathUtils.min(cross23, cross31));
                                            if (minCross > earMaxMinCross) {
                                                earIndex = i;
                                                earMaxMinCross = minCross;
                                            }
                                        }
                                    }
                                    ;
                                }
                                if (earIndex === -1) {
                                    if (Polygon.B2_POLYGON_REPORT_ERRORS) {
                                        let dump = new Polygon(xrem, yrem, vNum);
                                        console.info("Couldn\'t find an ear, dumping remaining poly:\n");
                                        dump.printFormatted();
                                        console.info("Please submit this dump to ewjordan at Box2d forums\n");
                                    }
                                    for (let i = 0; i < bufferSize; i++) {
                                        {
                                            results[i].set(buffer[i]);
                                        }
                                        ;
                                    }
                                    if (bufferSize > 0)
                                        return bufferSize;
                                    else
                                        return -1;
                                }
                                --vNum;
                                let newx = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(vNum);
                                let newy = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(vNum);
                                let currDest = 0;
                                for (let i = 0; i < vNum; ++i) {
                                    {
                                        if (currDest === earIndex)
                                            ++currDest;
                                        newx[i] = xrem[currDest];
                                        newy[i] = yrem[currDest];
                                        ++currDest;
                                    }
                                    ;
                                }
                                let under = (earIndex === 0) ? (vNum) : (earIndex - 1);
                                let over = (earIndex === vNum) ? 0 : (earIndex + 1);
                                let toAdd = new org.jbox2d.util.nonconvex.Triangle(xrem[earIndex], yrem[earIndex], xrem[over], yrem[over], xrem[under], yrem[under]);
                                buffer[bufferSize] = toAdd;
                                ++bufferSize;
                                xrem = newx;
                                yrem = newy;
                            }
                        }
                        ;
                        let toAdd = new org.jbox2d.util.nonconvex.Triangle(xrem[1], yrem[1], xrem[2], yrem[2], xrem[0], yrem[0]);
                        buffer[bufferSize] = toAdd;
                        ++bufferSize;
                        for (let i = 0; i < bufferSize; i++) {
                            {
                                results[i].set(buffer[i]);
                            }
                            ;
                        }
                        return bufferSize;
                    }
                    /**
                     * Turns a list of triangles into a list of convex polygons. Very simple
                     * method - start with a seed triangle, keep adding triangles to it until
                     * you can't add any more without making the polygon non-convex.
                     *
                     * Returns an integer telling how many polygons were created.  Will fill
                     * polys array up to polysLength entries, which may be smaller or larger
                     * than the return value.
                     *
                     * Takes O(N*P) where P is the number of resultant polygons, N is triangle
                     * count.
                     *
                     * The final polygon list will not necessarily be minimal, though in
                     * practice it works fairly well.
                     * @param {Array} triangulated
                     * @param {number} triangulatedLength
                     * @param {Array} polys
                     * @param {number} polysLength
                     * @return {number}
                     */
                    static polygonizeTriangles(triangulated, triangulatedLength, polys, polysLength) {
                        let polyIndex = 0;
                        if (triangulatedLength <= 0) {
                            return 0;
                        }
                        else {
                            let covered = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(triangulatedLength);
                            for (let i = 0; i < triangulatedLength; ++i) {
                                {
                                    covered[i] = 0;
                                    if (((triangulated[i].x[0] === triangulated[i].x[1]) && (triangulated[i].y[0] === triangulated[i].y[1])) || ((triangulated[i].x[1] === triangulated[i].x[2]) && (triangulated[i].y[1] === triangulated[i].y[2])) || ((triangulated[i].x[0] === triangulated[i].x[2]) && (triangulated[i].y[0] === triangulated[i].y[2]))) {
                                        covered[i] = 1;
                                    }
                                }
                                ;
                            }
                            let notDone = true;
                            while ((notDone)) {
                                {
                                    let currTri = -1;
                                    for (let i = 0; i < triangulatedLength; ++i) {
                                        {
                                            if (covered[i] !== 0)
                                                continue;
                                            currTri = i;
                                            break;
                                        }
                                        ;
                                    }
                                    if (currTri === -1) {
                                        notDone = false;
                                    }
                                    else {
                                        let poly = new Polygon(triangulated[currTri]);
                                        covered[currTri] = 1;
                                        let index = 0;
                                        for (let i = 0; i < 2 * triangulatedLength; ++i, ++index) {
                                            {
                                                while ((index >= triangulatedLength)) {
                                                    index -= triangulatedLength;
                                                }
                                                ;
                                                if (covered[index] !== 0) {
                                                    continue;
                                                }
                                                let newP = poly.add(triangulated[index]);
                                                if (newP == null) {
                                                    continue;
                                                }
                                                if (newP.nVertices > Polygon.maxPolygonVertices_$LI$()) {
                                                    newP = null;
                                                    continue;
                                                }
                                                if (newP.isConvex()) {
                                                    poly.set(newP);
                                                    newP = null;
                                                    covered[index] = 1;
                                                }
                                                else {
                                                    newP = null;
                                                }
                                            }
                                            ;
                                        }
                                        if (polyIndex < polysLength) {
                                            poly.mergeParallelEdges(org.jbox2d.common.Settings.angularSlop_$LI$());
                                            if (poly.nVertices >= 3)
                                                polys[polyIndex].set(poly);
                                        }
                                        if (poly.nVertices >= 3)
                                            polyIndex++;
                                    }
                                }
                            }
                            ;
                        }
                        return polyIndex;
                    }
                    /**
                     * Checks if vertex i is the tip of an ear in polygon defined by xv[] and
                     * yv[].
                     *
                     * Assumes clockwise orientation of polygon...ick
                     * @param {number} i
                     * @param {Array} xv
                     * @param {Array} yv
                     * @param {number} xvLength
                     * @return {boolean}
                     * @private
                     */
                    /*private*/ static isEar(i, xv, yv, xvLength) {
                        let dx0;
                        let dy0;
                        let dx1;
                        let dy1;
                        dx0 = dy0 = dx1 = dy1 = 0;
                        if (i >= xvLength || i < 0 || xvLength < 3) {
                            return false;
                        }
                        let upper = i + 1;
                        let lower = i - 1;
                        if (i === 0) {
                            dx0 = Math.fround(xv[0] - xv[xvLength - 1]);
                            dy0 = Math.fround(yv[0] - yv[xvLength - 1]);
                            dx1 = Math.fround(xv[1] - xv[0]);
                            dy1 = Math.fround(yv[1] - yv[0]);
                            lower = xvLength - 1;
                        }
                        else if (i === xvLength - 1) {
                            dx0 = Math.fround(xv[i] - xv[i - 1]);
                            dy0 = Math.fround(yv[i] - yv[i - 1]);
                            dx1 = Math.fround(xv[0] - xv[i]);
                            dy1 = Math.fround(yv[0] - yv[i]);
                            upper = 0;
                        }
                        else {
                            dx0 = Math.fround(xv[i] - xv[i - 1]);
                            dy0 = Math.fround(yv[i] - yv[i - 1]);
                            dx1 = Math.fround(xv[i + 1] - xv[i]);
                            dy1 = Math.fround(yv[i + 1] - yv[i]);
                        }
                        let cross = Math.fround(Math.fround(dx0 * dy1) - Math.fround(dx1 * dy0));
                        if (cross > 0)
                            return false;
                        let myTri = new org.jbox2d.util.nonconvex.Triangle(xv[i], yv[i], xv[upper], yv[upper], xv[lower], yv[lower]);
                        for (let j = 0; j < xvLength; ++j) {
                            {
                                if (j === i || j === lower || j === upper)
                                    continue;
                                if (myTri.containsPoint(xv[j], yv[j]))
                                    return false;
                            }
                            ;
                        }
                        return true;
                    }
                    static reversePolygon$org_jbox2d_util_nonconvex_Polygon(p) {
                        Polygon.reversePolygon$float_A$float_A$int(p.x, p.y, p.nVertices);
                        if (p.areaIsSet)
                            p.area *= -1;
                    }
                    static reversePolygon$float_A$float_A$int(x, y, n) {
                        if (n === 1)
                            return;
                        let low = 0;
                        let high = n - 1;
                        while ((low < high)) {
                            {
                                let buffer = x[low];
                                x[low] = x[high];
                                x[high] = buffer;
                                buffer = y[low];
                                y[low] = y[high];
                                y[high] = buffer;
                                ++low;
                                --high;
                            }
                        }
                        ;
                    }
                    static reversePolygon(x, y, n) {
                        if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((y != null && y instanceof Array && (y.length == 0 || y[0] == null || (typeof y[0] === 'number'))) || y === null) && ((typeof n === 'number') || n === null)) {
                            return org.jbox2d.util.nonconvex.Polygon.reversePolygon$float_A$float_A$int(x, y, n);
                        }
                        else if (((x != null && x instanceof org.jbox2d.util.nonconvex.Polygon) || x === null) && y === undefined && n === undefined) {
                            return org.jbox2d.util.nonconvex.Polygon.reversePolygon$org_jbox2d_util_nonconvex_Polygon(x);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Decomposes a non-convex polygon into a number of convex polygons, up
                     * to maxPolys (remaining pieces are thrown out, but the total number
                     * is returned, so the return value can be greater than maxPolys).
                     *
                     * Each resulting polygon will have no more than maxVerticesPerPolygon
                     * vertices (set to b2MaxPolyVertices by default, though you can change
                     * this).
                     *
                     * Returns -1 if operation fails (usually due to self-intersection of
                     * polygon).
                     * @param {org.jbox2d.util.nonconvex.Polygon} p
                     * @param {Array} results
                     * @param {number} maxPolys
                     * @return {number}
                     */
                    static decomposeConvex(p, results, maxPolys) {
                        if (p.nVertices < 3)
                            return 0;
                        let triangulated = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(p.nVertices - 2);
                        for (let i = 0; i < triangulated.length; ++i) {
                            {
                                triangulated[i] = new org.jbox2d.util.nonconvex.Triangle();
                            }
                            ;
                        }
                        let nTri;
                        if (p.isCCW()) {
                            let tempP = new Polygon();
                            tempP.set(p);
                            Polygon.reversePolygon$float_A$float_A$int(tempP.x, tempP.y, tempP.nVertices);
                            nTri = Polygon.triangulatePolygon(tempP.x, tempP.y, tempP.nVertices, triangulated);
                        }
                        else {
                            nTri = Polygon.triangulatePolygon(p.x, p.y, p.nVertices, triangulated);
                        }
                        if (nTri < 1) {
                            return -1;
                        }
                        let nPolys = Polygon.polygonizeTriangles(triangulated, nTri, results, maxPolys);
                        return nPolys;
                    }
                    /**
                     * Decomposes a polygon into convex polygons and adds all pieces to a b2BodyDef
                     * using a prototype b2PolyDef. All fields of the prototype are used for every
                     * shape except the vertices (friction, restitution, density, filter, etc).
                     *
                     * If you want finer control, you'll have to add everything by hand.
                     *
                     * This is the simplest method to add a complicated polygon to a body.
                     * @param {org.jbox2d.util.nonconvex.Polygon} p
                     * @param {org.jbox2d.dynamics.Body} bd
                     * @param {org.jbox2d.collision.shapes.PolygonDef} prototype
                     */
                    static decomposeConvexAndAddTo(p, bd, prototype) {
                        if (p.nVertices < 3)
                            return;
                        let decomposed = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(p.nVertices - 2);
                        for (let i = 0; i < decomposed.length; ++i) {
                            {
                                decomposed[i] = new Polygon();
                            }
                            ;
                        }
                        let nPolys = Polygon.decomposeConvex(p, decomposed, p.nVertices - 2);
                        let pdarray = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(2 * p.nVertices);
                        for (let i = 0; i < pdarray.length; ++i) {
                            {
                                pdarray[i] = new org.jbox2d.collision.shapes.PolygonDef();
                            }
                            ;
                        }
                        let extra = 0;
                        for (let i = 0; i < nPolys; ++i) {
                            {
                                let toAdd = pdarray[i + extra];
                                toAdd.set(prototype);
                                let curr = decomposed[i];
                                if (curr.nVertices === 3) {
                                    for (let j = 0; j < 3; ++j) {
                                        {
                                            let lower = (j === 0) ? (curr.nVertices - 1) : (j - 1);
                                            let middle = j;
                                            let upper = (j === curr.nVertices - 1) ? (0) : (j + 1);
                                            let dx0 = Math.fround(curr.x[middle] - curr.x[lower]);
                                            let dy0 = Math.fround(curr.y[middle] - curr.y[lower]);
                                            let dx1 = Math.fround(curr.x[upper] - curr.x[middle]);
                                            let dy1 = Math.fround(curr.y[upper] - curr.y[middle]);
                                            let norm0 = Math.fround(Math.sqrt(Math.fround(Math.fround(dx0 * dx0) + Math.fround(dy0 * dy0))));
                                            let norm1 = Math.fround(Math.sqrt(Math.fround(Math.fround(dx1 * dx1) + Math.fround(dy1 * dy1))));
                                            if (!(norm0 > 0.0 && norm1 > 0.0)) {
                                                continue;
                                            }
                                            dx0 /= norm0;
                                            dy0 /= norm0;
                                            dx1 /= norm1;
                                            dy1 /= norm1;
                                            let cross = Math.fround(Math.fround(dx0 * dy1) - Math.fround(dx1 * dy0));
                                            let dot = Math.fround(Math.fround(dx0 * dx1) + Math.fround(dy0 * dy1));
                                            if (org.jbox2d.common.MathUtils.abs(cross) < org.jbox2d.common.Settings.angularSlop_$LI$() && dot > 0) {
                                                let dx2 = Math.fround(curr.x[lower] - curr.x[upper]);
                                                let dy2 = Math.fround(curr.y[lower] - curr.y[upper]);
                                                let norm2 = Math.fround(Math.sqrt(Math.fround(Math.fround(dx2 * dx2) + Math.fround(dy2 * dy2))));
                                                if (norm2 === 0.0) {
                                                    continue;
                                                }
                                                dx2 /= norm2;
                                                dy2 /= norm2;
                                                let thisArea = curr.getArea();
                                                let thisHeight = Math.fround(Math.fround(2.0 * thisArea) / norm2);
                                                let buffer2 = dx2;
                                                dx2 = dy2;
                                                dy2 = -buffer2;
                                                let newX1 = [Math.fround(curr.x[middle] + Math.fround(dx2 * thisHeight)), curr.x[lower], curr.x[middle]];
                                                let newY1 = [Math.fround(curr.y[middle] + Math.fround(dy2 * thisHeight)), curr.y[lower], curr.y[middle]];
                                                let newX2 = [newX1[0], curr.x[middle], curr.x[upper]];
                                                let newY2 = [newY1[0], curr.y[middle], curr.y[upper]];
                                                let p1 = new Polygon(newX1, newY1, 3);
                                                let p2 = new Polygon(newX2, newY2, 3);
                                                if (p1.isUsable()) {
                                                    p1.addTo(toAdd);
                                                    bd.createShape(toAdd);
                                                    ++extra;
                                                }
                                                else if (Polygon.B2_POLYGON_REPORT_ERRORS) {
                                                    console.error("Didn\'t add unusable polygon.  Dumping vertices:\n");
                                                    p1.print();
                                                }
                                                if (p2.isUsable()) {
                                                    p2.addTo(pdarray[i + extra]);
                                                    bd.createShape(pdarray[i + extra]);
                                                }
                                                else if (Polygon.B2_POLYGON_REPORT_ERRORS) {
                                                    console.error("Didn\'t add unusable polygon.  Dumping vertices:\n");
                                                    p2.print();
                                                }
                                                continue;
                                            }
                                        }
                                        ;
                                    }
                                }
                                if (decomposed[i].isUsable()) {
                                    decomposed[i].addTo(toAdd);
                                    bd.createShape(toAdd);
                                }
                                else if (Polygon.B2_POLYGON_REPORT_ERRORS) {
                                    console.info("Didn\'t add unusable polygon.  Dumping vertices:\n");
                                    decomposed[i].print();
                                }
                            }
                            ;
                        }
                        return;
                    }
                    static convexHull$org_jbox2d_common_Vec2_A$int(v, nVert) {
                        let cloudX = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(nVert);
                        let cloudY = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(nVert);
                        for (let i = 0; i < nVert; ++i) {
                            {
                                cloudX[i] = v[i].x;
                                cloudY[i] = v[i].y;
                            }
                            ;
                        }
                        let result = Polygon.convexHull$float_A$float_A$int(cloudX, cloudY, nVert);
                        return result;
                    }
                    static convexHull$float_A$float_A$int(cloudX, cloudY, nVert) {
                        let edgeList = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(nVert);
                        let numEdges = 0;
                        let minY = 3.4028235E38;
                        let minYIndex = nVert;
                        for (let i = 0; i < nVert; ++i) {
                            {
                                if (cloudY[i] < minY) {
                                    minY = cloudY[i];
                                    minYIndex = i;
                                }
                            }
                            ;
                        }
                        let startIndex = minYIndex;
                        let winIndex = -1;
                        let dx = -1.0;
                        let dy = 0.0;
                        while ((winIndex !== minYIndex)) {
                            {
                                let newdx = 0.0;
                                let newdy = 0.0;
                                let maxDot = -2.0;
                                for (let i = 0; i < nVert; ++i) {
                                    {
                                        if (i === startIndex)
                                            continue;
                                        newdx = Math.fround(cloudX[i] - cloudX[startIndex]);
                                        newdy = Math.fround(cloudY[i] - cloudY[startIndex]);
                                        let nrm = Math.fround(Math.sqrt(Math.fround(Math.fround(newdx * newdx) + Math.fround(newdy * newdy))));
                                        nrm = (nrm === 0.0) ? 1.0 : nrm;
                                        newdx /= nrm;
                                        newdy /= nrm;
                                        let newDot = Math.fround(Math.fround(newdx * dx) + Math.fround(newdy * dy));
                                        if (newDot > maxDot) {
                                            maxDot = newDot;
                                            winIndex = i;
                                        }
                                    }
                                    ;
                                }
                                edgeList[numEdges++] = winIndex;
                                dx = Math.fround(cloudX[winIndex] - cloudX[startIndex]);
                                dy = Math.fround(cloudY[winIndex] - cloudY[startIndex]);
                                let nrm = Math.fround(Math.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy))));
                                nrm = (nrm === 0.0) ? 1.0 : nrm;
                                dx /= nrm;
                                dy /= nrm;
                                startIndex = winIndex;
                            }
                        }
                        ;
                        let xres = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(numEdges);
                        let yres = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(numEdges);
                        for (let i = 0; i < numEdges; i++) {
                            {
                                xres[i] = cloudX[edgeList[i]];
                                yres[i] = cloudY[edgeList[i]];
                            }
                            ;
                        }
                        let returnVal = new Polygon(xres, yres, numEdges);
                        returnVal.mergeParallelEdges(org.jbox2d.common.Settings.angularSlop_$LI$());
                        return returnVal;
                    }
                    static convexHull(cloudX, cloudY, nVert) {
                        if (((cloudX != null && cloudX instanceof Array && (cloudX.length == 0 || cloudX[0] == null || (typeof cloudX[0] === 'number'))) || cloudX === null) && ((cloudY != null && cloudY instanceof Array && (cloudY.length == 0 || cloudY[0] == null || (typeof cloudY[0] === 'number'))) || cloudY === null) && ((typeof nVert === 'number') || nVert === null)) {
                            return org.jbox2d.util.nonconvex.Polygon.convexHull$float_A$float_A$int(cloudX, cloudY, nVert);
                        }
                        else if (((cloudX != null && cloudX instanceof Array && (cloudX.length == 0 || cloudX[0] == null || (cloudX[0] != null && cloudX[0] instanceof org.jbox2d.common.Vec2))) || cloudX === null) && ((typeof cloudY === 'number') || cloudY === null) && nVert === undefined) {
                            return org.jbox2d.util.nonconvex.Polygon.convexHull$org_jbox2d_common_Vec2_A$int(cloudX, cloudY);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static isRighter(sinA, cosA, sinB, cosB) {
                        if (sinA < 0) {
                            if (sinB > 0 || cosA <= cosB)
                                return true;
                            else
                                return false;
                        }
                        else {
                            if (sinB < 0 || cosA <= cosB)
                                return false;
                            else
                                return true;
                        }
                    }
                    /*private*/ static remainder(x, modulus) {
                        let rem = x % modulus;
                        while ((rem < 0)) {
                            {
                                rem += modulus;
                            }
                        }
                        ;
                        return rem;
                    }
                    static traceEdge(p) {
                        let nodes = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(p.nVertices * p.nVertices);
                        let nNodes = 0;
                        for (let i = 0; i < nodes.length; ++i) {
                            {
                                nodes[i] = new org.jbox2d.util.nonconvex.PolyNode();
                            }
                            ;
                        }
                        for (let i = 0; i < p.nVertices; ++i) {
                            {
                                let pos = new org.jbox2d.common.Vec2(p.x[i], p.y[i]);
                                nodes[i].position = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(pos);
                                ++nNodes;
                                let iplus = (i === p.nVertices - 1) ? 0 : i + 1;
                                let iminus = (i === 0) ? p.nVertices - 1 : i - 1;
                                nodes[i].addConnection(nodes[iplus]);
                                nodes[i].addConnection(nodes[iminus]);
                            }
                            ;
                        }
                        let dirty = true;
                        let counter = 0;
                        while ((dirty)) {
                            {
                                dirty = false;
                                for (let i = 0; i < nNodes; ++i) {
                                    {
                                        for (let j = 0; j < nodes[i].nConnected; ++j) {
                                            {
                                                for (let k = 0; k < nNodes; ++k) {
                                                    {
                                                        if (k === i || nodes[k] === nodes[i].connected[j])
                                                            continue;
                                                        for (let l = 0; l < nodes[k].nConnected; ++l) {
                                                            {
                                                                if (nodes[k].connected[l] === nodes[i].connected[j] || nodes[k].connected[l] === nodes[i])
                                                                    continue;
                                                                let intersectPt = new org.jbox2d.common.Vec2();
                                                                let crosses = Polygon.intersect(nodes[i].position, nodes[i].connected[j].position, nodes[k].position, nodes[k].connected[l].position, intersectPt);
                                                                if (crosses) {
                                                                    dirty = true;
                                                                    let connj = nodes[i].connected[j];
                                                                    let connl = nodes[k].connected[l];
                                                                    nodes[i].connected[j].removeConnection(nodes[i]);
                                                                    nodes[i].removeConnection(connj);
                                                                    nodes[k].connected[l].removeConnection(nodes[k]);
                                                                    nodes[k].removeConnection(connl);
                                                                    nodes[nNodes] = new org.jbox2d.util.nonconvex.PolyNode(intersectPt);
                                                                    nodes[nNodes].addConnection(nodes[i]);
                                                                    nodes[i].addConnection(nodes[nNodes]);
                                                                    nodes[nNodes].addConnection(nodes[k]);
                                                                    nodes[k].addConnection(nodes[nNodes]);
                                                                    nodes[nNodes].addConnection(connj);
                                                                    connj.addConnection(nodes[nNodes]);
                                                                    nodes[nNodes].addConnection(connl);
                                                                    connl.addConnection(nodes[nNodes]);
                                                                    ++nNodes;
                                                                    break;
                                                                }
                                                                if (dirty)
                                                                    break;
                                                            }
                                                            ;
                                                        }
                                                        if (dirty)
                                                            break;
                                                    }
                                                    ;
                                                }
                                                if (dirty)
                                                    break;
                                            }
                                            ;
                                        }
                                        if (dirty)
                                            break;
                                    }
                                    ;
                                }
                                ++counter;
                            }
                        }
                        ;
                        let foundDupe = true;
                        let nActive = nNodes;
                        while ((foundDupe)) {
                            {
                                foundDupe = false;
                                for (let i = 0; i < nNodes; ++i) {
                                    {
                                        if (nodes[i].nConnected === 0)
                                            continue;
                                        for (let j = i + 1; j < nNodes; ++j) {
                                            {
                                                if (nodes[j].nConnected === 0)
                                                    continue;
                                                let diff = nodes[i].position.sub(nodes[j].position);
                                                if (diff.lengthSquared() <= Polygon.COLLAPSE_DIST_SQR_$LI$()) {
                                                    if (nActive <= 3)
                                                        return new Polygon();
                                                    --nActive;
                                                    foundDupe = true;
                                                    let inode = nodes[i];
                                                    let jnode = nodes[j];
                                                    let njConn = jnode.nConnected;
                                                    for (let k = 0; k < njConn; ++k) {
                                                        {
                                                            let knode = jnode.connected[k];
                                                            if (knode !== inode) {
                                                                inode.addConnection(knode);
                                                                knode.addConnection(inode);
                                                            }
                                                            knode.removeConnection(jnode);
                                                        }
                                                        ;
                                                    }
                                                    jnode.nConnected = 0;
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                        }
                        ;
                        let minY = 3.4028235E38;
                        let maxX = -3.4028235E38;
                        let minYIndex = -1;
                        for (let i = 0; i < nNodes; ++i) {
                            {
                                if (nodes[i].position.y < minY && nodes[i].nConnected > 1) {
                                    minY = nodes[i].position.y;
                                    minYIndex = i;
                                    maxX = nodes[i].position.x;
                                }
                                else if (nodes[i].position.y === minY && nodes[i].position.x > maxX && nodes[i].nConnected > 1) {
                                    minYIndex = i;
                                    maxX = nodes[i].position.x;
                                }
                            }
                            ;
                        }
                        let origDir = new org.jbox2d.common.Vec2(1.0, 0.0);
                        let resultVecs = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(4 * nNodes);
                        let nResultVecs = 0;
                        let currentNode = nodes[minYIndex];
                        let startNode = currentNode;
                        let nextNode = currentNode.getRightestConnection$org_jbox2d_common_Vec2(origDir);
                        if (nextNode == null) {
                            startNode = nextNode;
                        }
                        resultVecs[0] = startNode.position;
                        ++nResultVecs;
                        while ((nextNode !== startNode)) {
                            {
                                if (nResultVecs > 4 * nNodes) {
                                }
                                resultVecs[nResultVecs++] = nextNode.position;
                                let oldNode = currentNode;
                                currentNode = nextNode;
                                nextNode = currentNode.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(oldNode);
                                if (nextNode == null)
                                    break;
                            }
                        }
                        ;
                        let xres = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(nResultVecs);
                        let yres = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(nResultVecs);
                        for (let i = 0; i < nResultVecs; ++i) {
                            {
                                xres[i] = resultVecs[i].x;
                                yres[i] = resultVecs[i].y;
                            }
                            ;
                        }
                        let retval = new Polygon(xres, yres, nResultVecs);
                        return retval;
                    }
                    print() {
                        this.printFormatted();
                    }
                    printFormatted() {
                        console.info("float xv[] = {");
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                console.info("%ff,");
                            }
                            ;
                        }
                        console.info("};\nfloat yv[] = {");
                        for (let i = 0; i < this.nVertices; ++i) {
                            {
                                console.info("%ff,");
                            }
                            ;
                        }
                        console.info("};\n");
                    }
                }
                Polygon.B2_POLYGON_REPORT_ERRORS = true;
                nonconvex.Polygon = Polygon;
                Polygon["__class"] = "org.jbox2d.util.nonconvex.Polygon";
                class PolyNode {
                    constructor(pos) {
                        this.connected = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(PolyNode.MAX_CONNECTED);
                        if (((pos != null && pos instanceof org.jbox2d.common.Vec2) || pos === null)) {
                            let __args = arguments;
                            if (this.nConnected === undefined)
                                this.nConnected = 0;
                            if (this.visited === undefined)
                                this.visited = false;
                            if (this.position === undefined)
                                this.position = null;
                            this.connected = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(PolyNode.MAX_CONNECTED);
                            if (this.nConnected === undefined)
                                this.nConnected = 0;
                            if (this.visited === undefined)
                                this.visited = false;
                            if (this.position === undefined)
                                this.position = null;
                            (() => {
                                this.position = pos;
                                this.nConnected = 0;
                                this.visited = false;
                            })();
                        }
                        else if (pos === undefined) {
                            let __args = arguments;
                            if (this.nConnected === undefined)
                                this.nConnected = 0;
                            if (this.visited === undefined)
                                this.visited = false;
                            if (this.position === undefined)
                                this.position = null;
                            this.connected = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(PolyNode.MAX_CONNECTED);
                            if (this.nConnected === undefined)
                                this.nConnected = 0;
                            if (this.visited === undefined)
                                this.visited = false;
                            if (this.position === undefined)
                                this.position = null;
                            (() => {
                                this.nConnected = 0;
                                this.visited = false;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    addConnection(toMe) {
                        for (let i = 0; i < this.nConnected; ++i) {
                            {
                                if (this.connected[i] === toMe)
                                    return;
                            }
                            ;
                        }
                        this.connected[this.nConnected] = toMe;
                        ++this.nConnected;
                    }
                    removeConnection(fromMe) {
                        let isFound = false;
                        let foundIndex = -1;
                        for (let i = 0; i < this.nConnected; ++i) {
                            {
                                if (fromMe === this.connected[i]) {
                                    isFound = true;
                                    foundIndex = i;
                                    break;
                                }
                            }
                            ;
                        }
                        --this.nConnected;
                        for (let i = foundIndex; i < this.nConnected; ++i) {
                            {
                                this.connected[i] = this.connected[i + 1];
                            }
                            ;
                        }
                    }
                    removeConnectionByIndex(index) {
                        --this.nConnected;
                        for (let i = index; i < this.nConnected; ++i) {
                            {
                                this.connected[i] = this.connected[i + 1];
                            }
                            ;
                        }
                    }
                    isConnectedTo(me) {
                        let isFound = false;
                        for (let i = 0; i < this.nConnected; ++i) {
                            {
                                if (me === this.connected[i]) {
                                    isFound = true;
                                    break;
                                }
                            }
                            ;
                        }
                        return isFound;
                    }
                    getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(incoming) {
                        if (this.nConnected === 0) {
                        }
                        if (this.nConnected === 1) {
                            return incoming;
                        }
                        let inDir = this.position.sub(incoming.position);
                        let inLength = inDir.normalize();
                        let result = null;
                        for (let i = 0; i < this.nConnected; ++i) {
                            {
                                if (this.connected[i] === incoming)
                                    continue;
                                let testDir = this.connected[i].position.sub(this.position);
                                let testLengthSqr = testDir.lengthSquared();
                                testDir.normalize();
                                let myCos = org.jbox2d.common.Vec2.dot(inDir, testDir);
                                let mySin = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(inDir, testDir);
                                if (result != null) {
                                    let resultDir = result.position.sub(this.position);
                                    resultDir.normalize();
                                    let resCos = org.jbox2d.common.Vec2.dot(inDir, resultDir);
                                    let resSin = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(inDir, resultDir);
                                    if (org.jbox2d.util.nonconvex.Polygon.isRighter(mySin, myCos, resSin, resCos)) {
                                        result = this.connected[i];
                                    }
                                }
                                else {
                                    result = this.connected[i];
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    getRightestConnection(incoming) {
                        if (((incoming != null && incoming instanceof org.jbox2d.util.nonconvex.PolyNode) || incoming === null)) {
                            return this.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(incoming);
                        }
                        else if (((incoming != null && incoming instanceof org.jbox2d.common.Vec2) || incoming === null)) {
                            return this.getRightestConnection$org_jbox2d_common_Vec2(incoming);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getRightestConnection$org_jbox2d_common_Vec2(incomingDir) {
                        let diff = this.position.sub(incomingDir);
                        let temp = new PolyNode(diff);
                        let res = this.getRightestConnection$org_jbox2d_util_nonconvex_PolyNode(temp);
                        return res;
                    }
                }
                PolyNode.MAX_CONNECTED = 32;
                nonconvex.PolyNode = PolyNode;
                PolyNode["__class"] = "org.jbox2d.util.nonconvex.PolyNode";
            })(nonconvex = util.nonconvex || (util.nonconvex = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class NullContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @param {*} cl
                     */
                    evaluate(cl) {
                    }
                    clone() {
                        return new NullContact();
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        console.info("NullContact.GetManifolds()");
                        return null;
                    }
                    getFirstManifold() {
                        console.info("NullContact.GetFirstManifold()");
                        return null;
                    }
                }
                contacts.NullContact = NullContact;
                NullContact["__class"] = "org.jbox2d.dynamics.contacts.NullContact";
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var controllers;
            (function (controllers) {
                /**
                 * @author eric
                 * @extends org.jbox2d.dynamics.controllers.Controller
                 * @class
                 */
                class BuoyancyController extends org.jbox2d.dynamics.controllers.Controller {
                    constructor(def) {
                        super(def);
                        /**
                         * The outer surface normal
                         */
                        this.normal = new org.jbox2d.common.Vec2();
                        /**
                         * Fluid velocity, for drag calculations
                         */
                        this.velocity = new org.jbox2d.common.Vec2();
                        /**
                         * Gravity vector, if the world's gravity is not used
                         */
                        this.gravity = new org.jbox2d.common.Vec2();
                        if (this.offset === undefined)
                            this.offset = 0;
                        if (this.density === undefined)
                            this.density = 0;
                        if (this.linearDrag === undefined)
                            this.linearDrag = 0;
                        if (this.angularDrag === undefined)
                            this.angularDrag = 0;
                        if (this.useDensity === undefined)
                            this.useDensity = false;
                        if (this.useWorldGravity === undefined)
                            this.useWorldGravity = false;
                        this.normal = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.normal);
                        this.offset = def.offset;
                        this.density = def.density;
                        this.velocity = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.velocity);
                        this.linearDrag = def.linearDrag;
                        this.angularDrag = def.angularDrag;
                        this.useDensity = def.useDensity;
                        this.useWorldGravity = def.useWorldGravity;
                        this.gravity = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.gravity);
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    step(step) {
                        if (this.m_bodyList == null)
                            return;
                        if (this.useWorldGravity) {
                            this.gravity = this.m_world.getGravity();
                        }
                        for (let i = this.m_bodyList; i != null; i = i.nextBody) {
                            {
                                let body = i.body;
                                if (body.isSleeping()) {
                                    continue;
                                }
                                let areac = new org.jbox2d.common.Vec2(0, 0);
                                let massc = new org.jbox2d.common.Vec2(0, 0);
                                let area = 0;
                                let mass = 0;
                                for (let shape = body.getShapeList(); shape != null; shape = shape.getNext()) {
                                    {
                                        let sc = new org.jbox2d.common.Vec2(0, 0);
                                        let sarea = shape.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(this.normal, this.offset, sc);
                                        area += sarea;
                                        areac.x += Math.fround(sarea * sc.x);
                                        areac.y += Math.fround(sarea * sc.y);
                                        let shapeDensity = 0;
                                        if (this.useDensity) {
                                            shapeDensity = shape.getDensity();
                                        }
                                        else {
                                            shapeDensity = 1;
                                        }
                                        mass += Math.fround(sarea * shapeDensity);
                                        massc.x += Math.fround(Math.fround(sarea * sc.x) * shapeDensity);
                                        massc.y += Math.fround(Math.fround(sarea * sc.y) * shapeDensity);
                                    }
                                    ;
                                }
                                areac.x /= area;
                                areac.y /= area;
                                massc.x /= mass;
                                massc.y /= mass;
                                if (area < org.jbox2d.common.Settings.EPSILON)
                                    continue;
                                let buoyancyForce = this.gravity.mul(Math.fround(-this.density * area));
                                body.applyForce(buoyancyForce, massc);
                                let dragForce = body.getLinearVelocityFromWorldPoint(areac).sub(this.velocity);
                                dragForce.mulLocal(Math.fround(-this.linearDrag * area));
                                body.applyForce(dragForce, areac);
                                body.applyTorque(Math.fround(Math.fround(Math.fround(Math.fround(-body.getInertia() / body.getMass()) * area) * body.getAngularVelocity()) * this.angularDrag));
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
                     */
                    draw(debugDraw) {
                        let r = 1000;
                        let p1 = this.normal.mul(this.offset).addLocal$org_jbox2d_common_Vec2(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(this.normal, r));
                        let p2 = this.normal.mul(this.offset).subLocal(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(this.normal, r));
                        let color = new org.jbox2d.common.Color3f(0, 0, Math.fround(255 * 0.8));
                        let vertices = [p1, p2, p2.sub(this.normal.mul(r)), p1.sub(this.normal.mul(r))];
                        debugDraw.drawSolidPolygon(vertices, 4, color);
                    }
                }
                controllers.BuoyancyController = BuoyancyController;
                BuoyancyController["__class"] = "org.jbox2d.dynamics.controllers.BuoyancyController";
            })(controllers = dynamics.controllers || (dynamics.controllers = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var controllers;
            (function (controllers) {
                /**
                 * @author eric
                 * @class
                 * @extends org.jbox2d.dynamics.controllers.ControllerDef
                 */
                class BuoyancyControllerDef extends org.jbox2d.dynamics.controllers.ControllerDef {
                    constructor() {
                        super();
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.offset === undefined)
                            this.offset = 0;
                        if (this.density === undefined)
                            this.density = 0;
                        if (this.velocity === undefined)
                            this.velocity = null;
                        if (this.linearDrag === undefined)
                            this.linearDrag = 0;
                        if (this.angularDrag === undefined)
                            this.angularDrag = 0;
                        if (this.useDensity === undefined)
                            this.useDensity = false;
                        if (this.useWorldGravity === undefined)
                            this.useWorldGravity = false;
                        if (this.gravity === undefined)
                            this.gravity = null;
                        this.normal = new org.jbox2d.common.Vec2(0, 1);
                        this.offset = 0;
                        this.density = 0;
                        this.velocity = new org.jbox2d.common.Vec2(0, 0);
                        this.linearDrag = 0;
                        this.angularDrag = 0;
                        this.useDensity = false;
                        this.useWorldGravity = true;
                        this.gravity = new org.jbox2d.common.Vec2(0, 0);
                    }
                    /**
                     * @see org.jbox2d.dynamics.controllers.ControllerDef#create()
                     * @return {org.jbox2d.dynamics.controllers.Controller}
                     */
                    create() {
                        return new org.jbox2d.dynamics.controllers.BuoyancyController(this);
                    }
                }
                controllers.BuoyancyControllerDef = BuoyancyControllerDef;
                BuoyancyControllerDef["__class"] = "org.jbox2d.dynamics.controllers.BuoyancyControllerDef";
            })(controllers = dynamics.controllers || (dynamics.controllers = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var ContactFilter;
            (function (ContactFilter) {
                function DEFAULT_FILTER_$LI$() { if (ContactFilter.DEFAULT_FILTER == null)
                    ContactFilter.DEFAULT_FILTER = new org.jbox2d.dynamics.DefaultContactFilter(); return ContactFilter.DEFAULT_FILTER; }
                ContactFilter.DEFAULT_FILTER_$LI$ = DEFAULT_FILTER_$LI$;
                ;
            })(ContactFilter = dynamics.ContactFilter || (dynamics.ContactFilter = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * A gear joint is used to connect two joints together. Either joint
                 * can be a revolute or prismatic joint. You specify a gear ratio
                 * to bind the motions together:
                 * coordinate1 + ratio * coordinate2 = constant
                 * The ratio can be negative or positive. If one joint is a revolute joint
                 * and the other joint is a prismatic joint, then the ratio will have units
                 * of length or units of 1/length.
                 * <BR><em>Warning</em>: The revolute and prismatic joints must be attached to
                 * fixed bodies (which must be body1 on those joints).
                 * @param {org.jbox2d.dynamics.joints.GearJointDef} def
                 * @class
                 * @extends org.jbox2d.dynamics.joints.Joint
                 */
                class GearJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        /*private*/ this.tlug = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })();
                        /*private*/ this.tlr = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })();
                        if (this.m_ground1 === undefined)
                            this.m_ground1 = null;
                        if (this.m_ground2 === undefined)
                            this.m_ground2 = null;
                        if (this.m_revolute1 === undefined)
                            this.m_revolute1 = null;
                        if (this.m_prismatic1 === undefined)
                            this.m_prismatic1 = null;
                        if (this.m_revolute2 === undefined)
                            this.m_revolute2 = null;
                        if (this.m_prismatic2 === undefined)
                            this.m_prismatic2 = null;
                        if (this.m_groundAnchor1 === undefined)
                            this.m_groundAnchor1 = null;
                        if (this.m_groundAnchor2 === undefined)
                            this.m_groundAnchor2 = null;
                        if (this.m_localAnchor1 === undefined)
                            this.m_localAnchor1 = null;
                        if (this.m_localAnchor2 === undefined)
                            this.m_localAnchor2 = null;
                        if (this.m_J === undefined)
                            this.m_J = null;
                        if (this.m_constant === undefined)
                            this.m_constant = 0;
                        if (this.m_ratio === undefined)
                            this.m_ratio = 0;
                        if (this.m_mass === undefined)
                            this.m_mass = 0;
                        if (this.m_force === undefined)
                            this.m_force = 0;
                        this.m_J = new org.jbox2d.dynamics.joints.Jacobian();
                        let type1 = def.joint1.getType();
                        let type2 = def.joint2.getType();
                        this.m_revolute1 = null;
                        this.m_prismatic1 = null;
                        this.m_revolute2 = null;
                        this.m_prismatic2 = null;
                        let coordinate1;
                        let coordinate2;
                        this.m_ground1 = def.joint1.getBody1();
                        this.m_body1 = def.joint1.getBody2();
                        if (type1 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                            this.m_revolute1 = def.joint1;
                            this.m_groundAnchor1 = this.m_revolute1.m_localAnchor1;
                            this.m_localAnchor1 = this.m_revolute1.m_localAnchor2;
                            coordinate1 = this.m_revolute1.getJointAngle();
                        }
                        else {
                            this.m_prismatic1 = def.joint1;
                            this.m_groundAnchor1 = this.m_prismatic1.m_localAnchor1;
                            this.m_localAnchor1 = this.m_prismatic1.m_localAnchor2;
                            coordinate1 = this.m_prismatic1.getJointTranslation();
                        }
                        this.m_ground2 = def.joint2.getBody1();
                        this.m_body2 = def.joint2.getBody2();
                        if (type2 === org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT) {
                            this.m_revolute2 = def.joint2;
                            this.m_groundAnchor2 = this.m_revolute2.m_localAnchor1;
                            this.m_localAnchor2 = this.m_revolute2.m_localAnchor2;
                            coordinate2 = this.m_revolute2.getJointAngle();
                        }
                        else {
                            this.m_prismatic2 = def.joint2;
                            this.m_groundAnchor2 = this.m_prismatic2.m_localAnchor1;
                            this.m_localAnchor2 = this.m_prismatic2.m_localAnchor2;
                            coordinate2 = this.m_prismatic2.getJointTranslation();
                        }
                        this.m_ratio = def.ratio;
                        this.m_constant = Math.fround(coordinate1 + Math.fround(this.m_ratio * coordinate2));
                        this.m_force = 0.0;
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        let g1 = this.m_ground1;
                        let g2 = this.m_ground2;
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let ug = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(this.tlug);
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(this.tlr);
                        let K = 0.0;
                        this.m_J.setZero();
                        if (this.m_revolute1 != null) {
                            this.m_J.angular1 = -1.0;
                            K += b1.m_invI;
                        }
                        else {
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(g1.getMemberXForm().R, this.m_prismatic1.m_localXAxis1, ug);
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r);
                            let crug = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, ug);
                            this.m_J.linear1.set$org_jbox2d_common_Vec2(ug);
                            this.m_J.linear1.negateLocal();
                            this.m_J.angular1 = -crug;
                            K += Math.fround(b1.m_invMass + Math.fround(Math.fround(b1.m_invI * crug) * crug));
                        }
                        if (this.m_revolute2 != null) {
                            this.m_J.angular2 = -this.m_ratio;
                            K += Math.fround(Math.fround(this.m_ratio * this.m_ratio) * b2.m_invI);
                        }
                        else {
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(g2.getMemberXForm().R, this.m_prismatic2.m_localXAxis1, ug);
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r);
                            let crug = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, ug);
                            this.m_J.linear2.set$org_jbox2d_common_Vec2(ug);
                            this.m_J.linear2.mulLocal(-this.m_ratio);
                            this.m_J.angular2 = Math.fround(-this.m_ratio * crug);
                            K += Math.fround(Math.fround(this.m_ratio * this.m_ratio) * (Math.fround(b2.m_invMass + Math.fround(Math.fround(b2.m_invI * crug) * crug))));
                        }
                        this.m_mass = Math.fround(1.0 / K);
                        if (step.warmStarting) {
                            let P = Math.fround(step.dt * this.m_force);
                            b1.m_linearVelocity.x += Math.fround(Math.fround(b1.m_invMass * P) * this.m_J.linear1.x);
                            b1.m_linearVelocity.y += Math.fround(Math.fround(b1.m_invMass * P) * this.m_J.linear1.y);
                            b1.m_angularVelocity += Math.fround(Math.fround(b1.m_invI * P) * this.m_J.angular1);
                            b2.m_linearVelocity.x += Math.fround(Math.fround(b2.m_invMass * P) * this.m_J.linear2.x);
                            b2.m_linearVelocity.y += Math.fround(Math.fround(b2.m_invMass * P) * this.m_J.linear2.y);
                            b2.m_angularVelocity += Math.fround(Math.fround(b2.m_invI * P) * this.m_J.angular2);
                        }
                        else {
                            this.m_force = 0.0;
                        }
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let Cdot = this.m_J.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
                        let force = Math.fround(Math.fround(-step.inv_dt * this.m_mass) * Cdot);
                        this.m_force += force;
                        let P = Math.fround(step.dt * force);
                        b1.m_linearVelocity.x += Math.fround(Math.fround(b1.m_invMass * P) * this.m_J.linear1.x);
                        b1.m_linearVelocity.y += Math.fround(Math.fround(b1.m_invMass * P) * this.m_J.linear1.y);
                        b1.m_angularVelocity += Math.fround(Math.fround(b1.m_invI * P) * this.m_J.angular1);
                        b2.m_linearVelocity.x += Math.fround(Math.fround(b2.m_invMass * P) * this.m_J.linear2.x);
                        b2.m_linearVelocity.y += Math.fround(Math.fround(b2.m_invMass * P) * this.m_J.linear2.y);
                        b2.m_angularVelocity += Math.fround(Math.fround(b2.m_invI * P) * this.m_J.angular2);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        let linearError = 0.0;
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let coordinate1;
                        let coordinate2;
                        if (this.m_revolute1 != null) {
                            coordinate1 = this.m_revolute1.getJointAngle();
                        }
                        else {
                            coordinate1 = this.m_prismatic1.getJointTranslation();
                        }
                        if (this.m_revolute2 != null) {
                            coordinate2 = this.m_revolute2.getJointAngle();
                        }
                        else {
                            coordinate2 = this.m_prismatic2.getJointTranslation();
                        }
                        let C = Math.fround(this.m_constant - (Math.fround(coordinate1 + Math.fround(this.m_ratio * coordinate2))));
                        let impulse = Math.fround(-this.m_mass * C);
                        b1.m_sweep.c.x += Math.fround(Math.fround(b1.m_invMass * impulse) * this.m_J.linear1.x);
                        b1.m_sweep.c.y += Math.fround(Math.fround(b1.m_invMass * impulse) * this.m_J.linear1.y);
                        b1.m_sweep.a += Math.fround(Math.fround(b1.m_invI * impulse) * this.m_J.angular1);
                        b2.m_sweep.c.x += Math.fround(Math.fround(b2.m_invMass * impulse) * this.m_J.linear2.x);
                        b2.m_sweep.c.y += Math.fround(Math.fround(b2.m_invMass * impulse) * this.m_J.linear2.y);
                        b2.m_sweep.a += Math.fround(Math.fround(b2.m_invI * impulse) * this.m_J.angular2);
                        b1.synchronizeTransform();
                        b2.synchronizeTransform();
                        return linearError < org.jbox2d.common.Settings.linearSlop_$LI$();
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_body1.getWorldLocation(this.m_localAnchor1);
                    }
                    getAnchor1ToOut(out) {
                        this.m_body1.getWorldLocationToOut(this.m_localAnchor1, out);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return this.m_body2.getWorldLocation(this.m_localAnchor2);
                    }
                    getAnchor2ToOut(out) {
                        this.m_body2.getWorldLocationToOut(this.m_localAnchor2, out);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        return new org.jbox2d.common.Vec2(Math.fround(this.m_force * this.m_J.linear2.x), Math.fround(this.m_force * this.m_J.linear2.y));
                    }
                    getReactionForceToOut(out) {
                        out.x = Math.fround(this.m_force * this.m_J.linear2.x);
                        out.y = Math.fround(this.m_force * this.m_J.linear2.y);
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        let r = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body2.getMemberXForm().R, this.m_localAnchor2.sub(this.m_body2.getMemberLocalCenter()));
                        let F = new org.jbox2d.common.Vec2(Math.fround(this.m_force * this.m_J.linear2.x), Math.fround(this.m_force * this.m_J.linear2.y));
                        let T = Math.fround(Math.fround(this.m_force * this.m_J.angular2) - org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, F));
                        return T;
                    }
                    getRatio() {
                        return this.m_ratio;
                    }
                }
                joints.GearJoint = GearJoint;
                GearJoint["__class"] = "org.jbox2d.dynamics.joints.GearJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * Definition for a {@link ConstantVolumeJoint}, which connects a group a bodies together
                 * so they maintain a constant volume within them.
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class ConstantVolumeJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.bodies === undefined)
                            this.bodies = null;
                        if (this.frequencyHz === undefined)
                            this.frequencyHz = 0;
                        if (this.dampingRatio === undefined)
                            this.dampingRatio = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT;
                        this.bodies = [];
                        this.collideConnected = false;
                        this.frequencyHz = 0.0;
                        this.dampingRatio = 0.0;
                    }
                    addBody(b) {
                        let tmp = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.bodies.length + 1);
                        /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                            while (--size >= 0)
                                dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        else {
                            let tmp = srcPts.slice(srcOff, srcOff + size);
                            for (let i = 0; i < size; i++)
                                dstPts[dstOff++] = tmp[i];
                        } })(this.bodies, 0, tmp, 0, this.bodies.length);
                        tmp[this.bodies.length] = b;
                        this.bodies = tmp;
                        if (tmp.length === 1) {
                            this.body1 = b;
                        }
                        if (tmp.length === 2) {
                            this.body2 = b;
                        }
                    }
                }
                joints.ConstantVolumeJointDef = ConstantVolumeJointDef;
                ConstantVolumeJointDef["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * Definition for a distance joint.  A distance joint
                 * keeps two points on two bodies at a constant distance
                 * from each other.
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class DistanceJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.localAnchor1 === undefined)
                            this.localAnchor1 = null;
                        if (this.localAnchor2 === undefined)
                            this.localAnchor2 = null;
                        if (this.length === undefined)
                            this.length = 0;
                        if (this.frequencyHz === undefined)
                            this.frequencyHz = 0;
                        if (this.dampingRatio === undefined)
                            this.dampingRatio = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT;
                        this.localAnchor1 = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.localAnchor2 = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.length = 1.0;
                        this.frequencyHz = 0.0;
                        this.dampingRatio = 0.0;
                    }
                    /**
                     * Initialize the bodies, anchors, and length using the world
                     * anchors.
                     * @param {org.jbox2d.dynamics.Body} b1 First body
                     * @param {org.jbox2d.dynamics.Body} b2 Second body
                     * @param {org.jbox2d.common.Vec2} anchor1 World anchor on first body
                     * @param {org.jbox2d.common.Vec2} anchor2 World anchor on second body
                     */
                    initialize(b1, b2, anchor1, anchor2) {
                        this.body1 = b1;
                        this.body2 = b2;
                        this.localAnchor1.set$org_jbox2d_common_Vec2(this.body1.getLocalPoint(anchor1));
                        this.localAnchor2.set$org_jbox2d_common_Vec2(this.body2.getLocalPoint(anchor2));
                        let d = anchor2.sub(anchor1);
                        this.length = d.length();
                    }
                }
                joints.DistanceJointDef = DistanceJointDef;
                DistanceJointDef["__class"] = "org.jbox2d.dynamics.joints.DistanceJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 *
                 * Gear joint definition. This definition requires two existing
                 * revolute or prismatic joints (any combination will work).
                 * The provided joints must attach a dynamic body to a static body.<BR><BR>
                 * A gear joint is used to connect two joints together. Either joint
                 * can be a revolute or prismatic joint. You specify a gear ratio
                 * to bind the motions together:
                 * coordinate1 + ratio * coordinate2 = constant
                 * The ratio can be negative or positive. If one joint is a revolute joint
                 * and the other joint is a prismatic joint, then the ratio will have units
                 * of length or units of 1/length.
                 * <BR><em>Warning</em>: The revolute and prismatic joints must be attached to
                 * fixed bodies (which must be body1 on those joints).
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class GearJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.joint1 === undefined)
                            this.joint1 = null;
                        if (this.joint2 === undefined)
                            this.joint2 = null;
                        if (this.ratio === undefined)
                            this.ratio = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.GEAR_JOINT;
                        this.joint1 = null;
                        this.joint2 = null;
                        this.ratio = 1.0;
                    }
                }
                joints.GearJointDef = GearJointDef;
                GearJointDef["__class"] = "org.jbox2d.dynamics.joints.GearJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * This joint is used to add force to an object to accelerate to a position,
                 * normally used with the mouse.
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class MouseJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.target === undefined)
                            this.target = null;
                        if (this.maxForce === undefined)
                            this.maxForce = 0;
                        if (this.frequencyHz === undefined)
                            this.frequencyHz = 0;
                        if (this.dampingRatio === undefined)
                            this.dampingRatio = 0;
                        if (this.timeStep === undefined)
                            this.timeStep = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT;
                        this.target = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.maxForce = 0.0;
                        this.frequencyHz = 5.0;
                        this.dampingRatio = 0.7;
                        this.timeStep = Math.fround(1.0 / 60.0);
                    }
                }
                joints.MouseJointDef = MouseJointDef;
                MouseJointDef["__class"] = "org.jbox2d.dynamics.joints.MouseJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * A prismatic joint definition. This joint provides one degree of freedom: translation
                 * along an axis fixed in body1. Relative rotation is prevented. You can
                 * use a joint limit to restrict the range of motion and a joint motor to
                 * drive the motion or to model joint friction.
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class PrismaticJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.localAnchor1 === undefined)
                            this.localAnchor1 = null;
                        if (this.localAnchor2 === undefined)
                            this.localAnchor2 = null;
                        if (this.localAxis1 === undefined)
                            this.localAxis1 = null;
                        if (this.referenceAngle === undefined)
                            this.referenceAngle = 0;
                        if (this.enableLimit === undefined)
                            this.enableLimit = false;
                        if (this.lowerTranslation === undefined)
                            this.lowerTranslation = 0;
                        if (this.upperTranslation === undefined)
                            this.upperTranslation = 0;
                        if (this.enableMotor === undefined)
                            this.enableMotor = false;
                        if (this.maxMotorForce === undefined)
                            this.maxMotorForce = 0;
                        if (this.motorSpeed === undefined)
                            this.motorSpeed = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.PRISMATIC_JOINT;
                        this.localAnchor1 = new org.jbox2d.common.Vec2();
                        this.localAnchor2 = new org.jbox2d.common.Vec2();
                        this.localAxis1 = new org.jbox2d.common.Vec2();
                        this.referenceAngle = 0.0;
                        this.enableLimit = false;
                        this.lowerTranslation = 0.0;
                        this.upperTranslation = 0.0;
                        this.enableMotor = false;
                        this.maxMotorForce = 0.0;
                        this.motorSpeed = 0.0;
                    }
                    initialize(b1, b2, anchor, axis) {
                        this.body1 = b1;
                        this.body2 = b2;
                        this.body1.getLocalPointToOut(anchor, this.localAnchor1);
                        this.body2.getLocalPointToOut(anchor, this.localAnchor2);
                        this.body1.getLocalVectorToOut(axis, this.localAxis1);
                        this.referenceAngle = Math.fround(this.body2.getAngle() - this.body1.getAngle());
                    }
                }
                joints.PrismaticJointDef = PrismaticJointDef;
                PrismaticJointDef["__class"] = "org.jbox2d.dynamics.joints.PrismaticJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * The pulley joint is connected to two bodies and two fixed ground points.
                 * The pulley supports a ratio such that:
                 * length1 + ratio * length2 = constant
                 * Yes, the force transmitted is scaled by the ratio.
                 * The pulley also enforces a maximum length limit on both sides. This is
                 * useful to prevent one side of the pulley hitting the top.
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class PulleyJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.groundAnchor1 === undefined)
                            this.groundAnchor1 = null;
                        if (this.groundAnchor2 === undefined)
                            this.groundAnchor2 = null;
                        if (this.localAnchor1 === undefined)
                            this.localAnchor1 = null;
                        if (this.localAnchor2 === undefined)
                            this.localAnchor2 = null;
                        if (this.length1 === undefined)
                            this.length1 = 0;
                        if (this.maxLength1 === undefined)
                            this.maxLength1 = 0;
                        if (this.length2 === undefined)
                            this.length2 = 0;
                        if (this.maxLength2 === undefined)
                            this.maxLength2 = 0;
                        if (this.ratio === undefined)
                            this.ratio = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT;
                        this.groundAnchor1 = new org.jbox2d.common.Vec2(-1.0, 1.0);
                        this.groundAnchor2 = new org.jbox2d.common.Vec2(1.0, 1.0);
                        this.localAnchor1 = new org.jbox2d.common.Vec2(-1.0, 0.0);
                        this.localAnchor2 = new org.jbox2d.common.Vec2(1.0, 0.0);
                        this.length1 = 0.0;
                        this.maxLength1 = 0.0;
                        this.length2 = 0.0;
                        this.maxLength2 = 0.0;
                        this.ratio = 1.0;
                        this.collideConnected = true;
                    }
                    initialize(b1, b2, ga1, ga2, anchor1, anchor2, r) {
                        this.body1 = b1;
                        this.body2 = b2;
                        this.groundAnchor1 = ga1;
                        this.groundAnchor2 = ga2;
                        this.localAnchor1 = this.body1.getLocalPoint(anchor1);
                        this.localAnchor2 = this.body2.getLocalPoint(anchor2);
                        let d1 = anchor1.sub(ga1);
                        this.length1 = d1.length();
                        let d2 = anchor2.sub(ga2);
                        this.length2 = d2.length();
                        this.ratio = r;
                        let C = Math.fround(this.length1 + Math.fround(this.ratio * this.length2));
                        this.maxLength1 = Math.fround(C - Math.fround(this.ratio * org.jbox2d.dynamics.joints.PulleyJoint.MIN_PULLEY_LENGTH));
                        this.maxLength2 = Math.fround((Math.fround(C - org.jbox2d.dynamics.joints.PulleyJoint.MIN_PULLEY_LENGTH)) / this.ratio);
                    }
                }
                joints.PulleyJointDef = PulleyJointDef;
                PulleyJointDef["__class"] = "org.jbox2d.dynamics.joints.PulleyJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * Revolute joint definition. This requires defining an
                 * anchor point where the bodies are joined. The definition
                 * uses local anchor points so that the initial configuration
                 * can violate the constraint slightly. You also need to
                 * specify the initial relative angle for joint limits. This
                 * helps when saving and loading a game.
                 * The local anchor points are measured from the body's origin
                 * rather than the center of mass because:<br/>
                 * <ul>
                 * <li>you might not know where the center of mass will be.</li>
                 * <li>if you add/remove shapes from a body and recompute the mass,
                 * the joints will be broken.</li></ul>
                 * @class
                 * @extends org.jbox2d.dynamics.joints.JointDef
                 */
                class RevoluteJointDef extends org.jbox2d.dynamics.joints.JointDef {
                    constructor() {
                        super();
                        if (this.localAnchor1 === undefined)
                            this.localAnchor1 = null;
                        if (this.localAnchor2 === undefined)
                            this.localAnchor2 = null;
                        if (this.referenceAngle === undefined)
                            this.referenceAngle = 0;
                        if (this.enableLimit === undefined)
                            this.enableLimit = false;
                        if (this.lowerAngle === undefined)
                            this.lowerAngle = 0;
                        if (this.upperAngle === undefined)
                            this.upperAngle = 0;
                        if (this.enableMotor === undefined)
                            this.enableMotor = false;
                        if (this.motorSpeed === undefined)
                            this.motorSpeed = 0;
                        if (this.maxMotorTorque === undefined)
                            this.maxMotorTorque = 0;
                        this.type = org.jbox2d.dynamics.joints.JointType.REVOLUTE_JOINT;
                        this.localAnchor1 = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.localAnchor2 = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.referenceAngle = 0.0;
                        this.lowerAngle = 0.0;
                        this.upperAngle = 0.0;
                        this.maxMotorTorque = 0.0;
                        this.motorSpeed = 0.0;
                        this.enableLimit = false;
                        this.enableMotor = false;
                    }
                    initialize(b1, b2, anchor) {
                        this.body1 = b1;
                        this.body2 = b2;
                        this.localAnchor1 = this.body1.getLocalPoint(anchor);
                        this.localAnchor2 = this.body2.getLocalPoint(anchor);
                        this.referenceAngle = Math.fround(this.body2.getAngle() - this.body1.getAngle());
                    }
                }
                joints.RevoluteJointDef = RevoluteJointDef;
                RevoluteJointDef["__class"] = "org.jbox2d.dynamics.joints.RevoluteJointDef";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var arrays;
            (function (arrays) {
                class BooleanArray extends org.jbox2d.pooling.arrays.DynamicTLArray {
                    /**
                     *
                     * @param {number} argLength
                     * @return {Array}
                     */
                    getInitializedArray(argLength) {
                        let ray = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(argLength);
                        for (let i = 0; i < argLength; i++) {
                            {
                                ray[i] = false;
                            }
                            ;
                        }
                        return ray;
                    }
                }
                arrays.BooleanArray = BooleanArray;
                BooleanArray["__class"] = "org.jbox2d.pooling.arrays.BooleanArray";
            })(arrays = pooling.arrays || (pooling.arrays = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var arrays;
            (function (arrays) {
                class IntegerArray extends org.jbox2d.pooling.arrays.DynamicTLArray {
                    /**
                     *
                     * @param {number} argLength
                     * @return {Array}
                     */
                    getInitializedArray(argLength) {
                        return (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(argLength);
                    }
                }
                arrays.IntegerArray = IntegerArray;
                IntegerArray["__class"] = "org.jbox2d.pooling.arrays.IntegerArray";
            })(arrays = pooling.arrays || (pooling.arrays = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var arrays;
            (function (arrays) {
                class Vec2Array extends org.jbox2d.pooling.arrays.DynamicTLArray {
                    /**
                     *
                     * @param {number} argLength
                     * @return {Array}
                     */
                    getInitializedArray(argLength) {
                        let ray = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(argLength);
                        for (let i = 0; i < ray.length; i++) {
                            {
                                ray[i] = new org.jbox2d.common.Vec2();
                            }
                            ;
                        }
                        return ray;
                    }
                }
                arrays.Vec2Array = Vec2Array;
                Vec2Array["__class"] = "org.jbox2d.pooling.arrays.Vec2Array";
            })(arrays = pooling.arrays || (pooling.arrays = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var stacks;
            (function (stacks) {
                class ContactSolverStack extends org.jbox2d.pooling.stacks.DynamicTLStack {
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.ContactSolver}
                     */
                    newObjectInstance() {
                        return new org.jbox2d.dynamics.contacts.ContactSolver();
                    }
                }
                stacks.ContactSolverStack = ContactSolverStack;
                ContactSolverStack["__class"] = "org.jbox2d.pooling.stacks.ContactSolverStack";
            })(stacks = pooling.stacks || (pooling.stacks = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var stacks;
            (function (stacks) {
                class IslandStack extends org.jbox2d.pooling.stacks.DynamicTLStack {
                    /**
                     *
                     * @return {org.jbox2d.dynamics.Island}
                     */
                    newObjectInstance() {
                        return new org.jbox2d.dynamics.Island();
                    }
                }
                stacks.IslandStack = IslandStack;
                IslandStack["__class"] = "org.jbox2d.pooling.stacks.IslandStack";
            })(stacks = pooling.stacks || (pooling.stacks = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var pooling;
        (function (pooling) {
            var stacks;
            (function (stacks) {
                class TimeStepStack extends org.jbox2d.pooling.stacks.DynamicTLStack {
                    /**
                     *
                     * @return {org.jbox2d.dynamics.TimeStep}
                     */
                    newObjectInstance() {
                        return new org.jbox2d.dynamics.TimeStep();
                    }
                }
                stacks.TimeStepStack = TimeStepStack;
                TimeStepStack["__class"] = "org.jbox2d.pooling.stacks.TimeStepStack";
            })(stacks = pooling.stacks || (pooling.stacks = {}));
        })(pooling = jbox2d.pooling || (jbox2d.pooling = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * A shape is used for collision detection. Shapes are created in World.
                 * You can use shape for collision detection before they are attached to the world.
                 * <BR><BR><em>Warning</em>: you cannot reuse shapes on different bodies, they must
                 * be re-created or copied.
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def
                 * @class
                 */
                class Shape {
                    constructor(def) {
                        if (this.uid === undefined)
                            this.uid = 0;
                        if (this.m_type === undefined)
                            this.m_type = null;
                        if (this.m_next === undefined)
                            this.m_next = null;
                        if (this.m_body === undefined)
                            this.m_body = null;
                        if (this.m_sweepRadius === undefined)
                            this.m_sweepRadius = 0;
                        if (this.m_density === undefined)
                            this.m_density = 0;
                        if (this.m_friction === undefined)
                            this.m_friction = 0;
                        if (this.m_restitution === undefined)
                            this.m_restitution = 0;
                        if (this.m_proxyId === undefined)
                            this.m_proxyId = 0;
                        if (this.m_filter === undefined)
                            this.m_filter = null;
                        if (this.m_isSensor === undefined)
                            this.m_isSensor = false;
                        if (this.m_userData === undefined)
                            this.m_userData = null;
                        this.uid = Shape.uidcount++;
                        this.m_userData = def.userData;
                        this.m_friction = def.friction;
                        this.m_restitution = def.restitution;
                        this.m_density = def.density;
                        this.m_body = null;
                        this.m_sweepRadius = 0.0;
                        this.m_next = null;
                        this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
                        this.m_filter = new org.jbox2d.collision.FilterData();
                        this.m_filter.categoryBits = def.filter.categoryBits;
                        this.m_filter.maskBits = def.filter.maskBits;
                        this.m_filter.groupIndex = def.filter.groupIndex;
                        this.m_isSensor = def.isSensor;
                    }
                    /**
                     * Get the coefficient of friction.
                     * @return {number}
                     */
                    getFriction() {
                        return this.m_friction;
                    }
                    /**
                     * Set the coefficient of friction.
                     * @param {number} friction
                     */
                    setFriction(friction) {
                        this.m_friction = friction;
                    }
                    /**
                     * Get the coefficient of restitution.
                     * @return {number}
                     */
                    getRestitution() {
                        return this.m_restitution;
                    }
                    /**
                     * Set the coefficient of restitution.
                     * @param {number} restitution
                     */
                    setRestitution(restitution) {
                        this.m_restitution = restitution;
                    }
                    /**
                     * Set the collision filtering data.
                     * @param {org.jbox2d.collision.FilterData} filter
                     */
                    setFilterData(filter) {
                        this.m_filter.set(filter);
                    }
                    /**
                     * Get the collision filtering data.
                     * @return {org.jbox2d.collision.FilterData}
                     */
                    getFilterData() {
                        return this.m_filter;
                    }
                    /**
                     * Get the type of this shape. You can use this to down cast to the concrete shape.
                     * @return {org.jbox2d.collision.shapes.ShapeType} the shape type.
                     */
                    getType() {
                        return this.m_type;
                    }
                    /**
                     * Is this shape a sensor (non-solid)?
                     * @return {boolean} the true if the shape is a sensor.
                     */
                    isSensor() {
                        return this.m_isSensor;
                    }
                    /**
                     * Get the user data that was assigned in the shape definition. Use this to
                     * store your application specific data.
                     * @return {*}
                     */
                    getUserData() {
                        return this.m_userData;
                    }
                    /**
                     * Set the user data associated with the object.
                     * @param {*} o User data to set
                     */
                    setUserData(o) {
                        this.m_userData = o;
                    }
                    /**
                     * Get the parent body of this shape. This is NULL if the shape is not attached.
                     * @return {org.jbox2d.dynamics.Body} the parent body.
                     */
                    getBody() {
                        return this.m_body;
                    }
                    /**
                     * Get the next shape in the parent body's shape list.
                     * @return {org.jbox2d.collision.shapes.Shape} the next shape.
                     */
                    getNext() {
                        return this.m_next;
                    }
                    /**
                     * Get the sweep radius of the shape.
                     * @return {number} the sweep radius
                     */
                    getSweepRadius() {
                        return this.m_sweepRadius;
                    }
                    static tlAabb_$LI$() { if (Shape.tlAabb == null)
                        Shape.tlAabb = (() => { let __o = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return Shape.tlAabb; }
                    ;
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.BroadPhase} broadPhase
                     * @param {org.jbox2d.common.XForm} transform1
                     * @param {org.jbox2d.common.XForm} transform2
                     * @return {boolean}
                     */
                    synchronize(broadPhase, transform1, transform2) {
                        if (this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                            return false;
                        }
                        let aabb = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(Shape.tlAabb_$LI$());
                        this.computeSweptAABB(aabb, transform1, transform2);
                        if (broadPhase.inRange(aabb)) {
                            broadPhase.moveProxy(this.m_proxyId, aabb);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.BroadPhase} broadPhase
                     * @param {org.jbox2d.common.XForm} transform
                     */
                    refilterProxy(broadPhase, transform) {
                        if (this.m_proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                            return;
                        }
                        broadPhase.destroyProxy(this.m_proxyId);
                        let aabb = new org.jbox2d.collision.AABB();
                        this.computeAABB(aabb, transform);
                        let inRange = broadPhase.inRange(aabb);
                        if (inRange) {
                            this.m_proxyId = broadPhase.createProxy(aabb, this);
                        }
                        else {
                            this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
                        }
                    }
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.shapes.ShapeDef} def
                     * @return {org.jbox2d.collision.shapes.Shape}
                     */
                    static create(def) {
                        if (def.type === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                            return new org.jbox2d.collision.shapes.CircleShape(def);
                        }
                        else if (def.type === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                            return new org.jbox2d.collision.shapes.PolygonShape(def);
                        }
                        else if (def.type === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                            return new org.jbox2d.collision.shapes.PointShape(def);
                        }
                        return null;
                    }
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.shapes.Shape} s
                     */
                    static destroy(s) {
                        if (s.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                            let edge = s;
                            if (edge.m_nextEdge != null) {
                                edge.m_nextEdge.m_prevEdge = null;
                            }
                            if (edge.m_prevEdge != null) {
                                edge.m_prevEdge.m_nextEdge = null;
                            }
                        }
                        s.destructor();
                    }
                    /**
                     * Internal
                     */
                    destructor() {
                    }
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.BroadPhase} broadPhase
                     * @param {org.jbox2d.common.XForm} transform
                     */
                    createProxy(broadPhase, transform) {
                        let aabb = new org.jbox2d.collision.AABB();
                        this.computeAABB(aabb, transform);
                        let inRange = broadPhase.inRange(aabb);
                        if (inRange) {
                            this.m_proxyId = broadPhase.createProxy(aabb, this);
                        }
                        else {
                            this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
                        }
                    }
                    /**
                     * Internal
                     * @param {org.jbox2d.collision.BroadPhase} broadPhase
                     */
                    destroyProxy(broadPhase) {
                        if (this.m_proxyId !== org.jbox2d.collision.PairManager.NULL_PROXY_$LI$()) {
                            broadPhase.destroyProxy(this.m_proxyId);
                            this.m_proxyId = org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
                        }
                    }
                    computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, c) {
                        return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, this.m_body.getXForm(), c);
                    }
                    computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, form, c) {
                        return 0;
                    }
                    /**
                     * @param {org.jbox2d.common.Vec2} normal
                     * @param {number} offset
                     * @param {org.jbox2d.common.XForm} form
                     * @param {org.jbox2d.common.Vec2} c
                     * @return
                     * @return {number}
                     */
                    computeSubmergedArea(normal, offset, form, c) {
                        if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((form != null && form instanceof org.jbox2d.common.XForm) || form === null) && ((c != null && c instanceof org.jbox2d.common.Vec2) || c === null)) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, form, c);
                        }
                        else if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((form != null && form instanceof org.jbox2d.common.Vec2) || form === null) && c === undefined) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, form);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * @return {number} shape density
                     */
                    getDensity() {
                        return this.m_density;
                    }
                    /**
                     * @return {org.jbox2d.collision.shapes.Shape[]} a Set<Shape> of all shapes in contact with this one
                     */
                    getShapesInContact() {
                        let curr = this.m_body.getContactList();
                        let touching = ([]);
                        while ((curr != null)) {
                            {
                                if (curr.contact.m_shape1 === this) {
                                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                        s.push(e);
                                        return true;
                                    }
                                    else {
                                        return false;
                                    } })(touching, curr.contact.m_shape2);
                                }
                                else if (curr.contact.m_shape2 === this) {
                                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                        s.push(e);
                                        return true;
                                    }
                                    else {
                                        return false;
                                    } })(touching, curr.contact.m_shape1);
                                }
                                curr = curr.next;
                            }
                        }
                        ;
                        return touching;
                    }
                    /**
                     * @return {org.jbox2d.dynamics.contacts.Contact[]} a Set<Contact> of all (active) contacts involving this shape
                     */
                    getContacts() {
                        let curr = this.m_body.getContactList();
                        let contacts = ([]);
                        while ((curr != null)) {
                            {
                                if (curr.contact.getManifoldCount() > 0) {
                                    if (curr.contact.m_shape1 === this) {
                                        /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                            s.push(e);
                                            return true;
                                        }
                                        else {
                                            return false;
                                        } })(contacts, curr.contact);
                                    }
                                    else if (curr.contact.m_shape2 === this) {
                                        /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                            s.push(e);
                                            return true;
                                        }
                                        else {
                                            return false;
                                        } })(contacts, curr.contact);
                                    }
                                }
                                curr = curr.next;
                            }
                        }
                        ;
                        return contacts;
                    }
                }
                /**
                 * Used to generate uids - not initialized on applet reload,
                 * but that's okay since these just have to be unique.
                 */
                Shape.uidcount = 0;
                shapes.Shape = Shape;
                Shape["__class"] = "org.jbox2d.collision.shapes.Shape";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var common;
        (function (common) {
            class OBBViewportTransform {
                constructor() {
                    this.box = new org.jbox2d.collision.OBB();
                    /*private*/ this.yFlip = false;
                    /*private*/ this.yFlipMat = new org.jbox2d.common.Mat22(1, 0, 0, -1);
                    /*private*/ this.yFlipMatInv = this.yFlipMat.invert();
                    this.box.R.setIdentity();
                }
                set(vpt) {
                    this.box.center.set$org_jbox2d_common_Vec2(vpt.box.center);
                    this.box.extents.set$org_jbox2d_common_Vec2(vpt.box.extents);
                    this.box.R.set$org_jbox2d_common_Mat22(vpt.box.R);
                    this.yFlip = vpt.yFlip;
                }
                /**
                 * @see IViewportTransform#setCamera(float, float, float)
                 * @param {number} x
                 * @param {number} y
                 * @param {number} scale
                 */
                setCamera(x, y, scale) {
                    this.box.center.set$float$float(x, y);
                    org.jbox2d.common.Mat22.createScaleTransform$float$org_jbox2d_common_Mat22(scale, this.box.R);
                }
                /**
                 * @see IViewportTransform#getExtents()
                 * @return {org.jbox2d.common.Vec2}
                 */
                getExtents() {
                    return this.box.extents;
                }
                setExtents$org_jbox2d_common_Vec2(argExtents) {
                    this.box.extents.set$org_jbox2d_common_Vec2(argExtents);
                }
                setExtents$float$float(argHalfWidth, argHalfHeight) {
                    this.box.extents.set$float$float(argHalfWidth, argHalfHeight);
                }
                /**
                 * @see IViewportTransform#setExtents(float, float)
                 * @param {number} argHalfWidth
                 * @param {number} argHalfHeight
                 */
                setExtents(argHalfWidth, argHalfHeight) {
                    if (((typeof argHalfWidth === 'number') || argHalfWidth === null) && ((typeof argHalfHeight === 'number') || argHalfHeight === null)) {
                        return this.setExtents$float$float(argHalfWidth, argHalfHeight);
                    }
                    else if (((argHalfWidth != null && argHalfWidth instanceof org.jbox2d.common.Vec2) || argHalfWidth === null) && argHalfHeight === undefined) {
                        return this.setExtents$org_jbox2d_common_Vec2(argHalfWidth);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * @see IViewportTransform#getCenter()
                 * @return {org.jbox2d.common.Vec2}
                 */
                getCenter() {
                    return this.box.center;
                }
                setCenter$org_jbox2d_common_Vec2(argPos) {
                    this.box.center.set$org_jbox2d_common_Vec2(argPos);
                }
                setCenter$float$float(x, y) {
                    this.box.center.set$float$float(x, y);
                }
                /**
                 * @see IViewportTransform#setCenter(float, float)
                 * @param {number} x
                 * @param {number} y
                 */
                setCenter(x, y) {
                    if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                        return this.setCenter$float$float(x, y);
                    }
                    else if (((x != null && x instanceof org.jbox2d.common.Vec2) || x === null) && y === undefined) {
                        return this.setCenter$org_jbox2d_common_Vec2(x);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * gets the transform of the viewport, transforms around the center.
                 * Not a copy.
                 * @return
                 * @return {org.jbox2d.common.Mat22}
                 */
                getTransform() {
                    return this.box.R;
                }
                /**
                 * Sets the transform of the viewport.  Transforms about the center.
                 * @param {org.jbox2d.common.Mat22} transform
                 */
                setTransform(transform) {
                    this.box.R.set$org_jbox2d_common_Mat22(transform);
                }
                /**
                 * Lerps to the given transform
                 * @param {org.jbox2d.common.Mat22} transform
                 * @param {number} amt
                 */
                lerpTransform(transform, amt) {
                    this.box.R.col1.x += Math.fround((Math.fround(transform.col1.x - this.box.R.col1.x)) * amt);
                    this.box.R.col1.y += Math.fround((Math.fround(transform.col1.y - this.box.R.col1.y)) * amt);
                    this.box.R.col2.x += Math.fround((Math.fround(transform.col2.x - this.box.R.col2.x)) * amt);
                    this.box.R.col2.y += Math.fround((Math.fround(transform.col2.y - this.box.R.col2.y)) * amt);
                }
                /**
                 * Multiplies the obb transform by the given transform
                 * @param {org.jbox2d.common.Mat22} argTransform
                 */
                mulByTransform(argTransform) {
                    this.box.R.mulLocal(argTransform);
                }
                /**
                 * @see IViewportTransform#isYFlip()
                 * @return {boolean}
                 */
                isYFlip() {
                    return this.yFlip;
                }
                /**
                 * @see IViewportTransform#setYFlip(boolean)
                 * @param {boolean} yFlip
                 */
                setYFlip(yFlip) {
                    this.yFlip = yFlip;
                }
                static tlInv_$LI$() { if (OBBViewportTransform.tlInv == null)
                    OBBViewportTransform.tlInv = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return OBBViewportTransform.tlInv; }
                ;
                /**
                 * @see IViewportTransform#vectorInverseTransform(Vec2, Vec2)
                 * @param {org.jbox2d.common.Vec2} argScreen
                 * @param {org.jbox2d.common.Vec2} argWorld
                 */
                vectorInverseTransform(argScreen, argWorld) {
                    let inv = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(OBBViewportTransform.tlInv_$LI$());
                    inv.set$org_jbox2d_common_Mat22(this.box.R);
                    inv.invertLocal();
                    inv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argWorld);
                    if (this.yFlip) {
                        this.yFlipMatInv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
                    }
                }
                /**
                 * @see IViewportTransform#vectorTransform(Vec2, Vec2)
                 * @param {org.jbox2d.common.Vec2} argWorld
                 * @param {org.jbox2d.common.Vec2} argScreen
                 */
                vectorTransform(argWorld, argScreen) {
                    this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argScreen);
                    if (this.yFlip) {
                        this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
                    }
                }
                /**
                 * @see IViewportTransform#getWorldToScreen(Vec2, Vec2)
                 * @param {org.jbox2d.common.Vec2} argWorld
                 * @param {org.jbox2d.common.Vec2} argScreen
                 */
                getWorldToScreen(argWorld, argScreen) {
                    argScreen.set$org_jbox2d_common_Vec2(argWorld);
                    argScreen.subLocal(this.box.center);
                    this.box.R.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
                    if (this.yFlip) {
                        this.yFlipMat.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argScreen, argScreen);
                    }
                    argScreen.addLocal$org_jbox2d_common_Vec2(this.box.extents);
                }
                /**
                 * @see IViewportTransform#getScreenToWorld(Vec2, Vec2)
                 * @param {org.jbox2d.common.Vec2} argScreen
                 * @param {org.jbox2d.common.Vec2} argWorld
                 */
                getScreenToWorld(argScreen, argWorld) {
                    argWorld.set$org_jbox2d_common_Vec2(argScreen);
                    argWorld.subLocal(this.box.extents);
                    let inv = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(OBBViewportTransform.tlInv_$LI$());
                    this.box.R.invertToOut(inv);
                    inv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
                    if (this.yFlip) {
                        this.yFlipMatInv.mulToOut$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(argWorld, argWorld);
                    }
                    argWorld.addLocal$org_jbox2d_common_Vec2(this.box.center);
                }
            }
            common.OBBViewportTransform = OBBViewportTransform;
            OBBViewportTransform["__class"] = "org.jbox2d.common.OBBViewportTransform";
            OBBViewportTransform["__interfaces"] = ["org.jbox2d.common.IViewportTransform"];
        })(common = jbox2d.common || (jbox2d.common = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            class Segment {
                constructor() {
                    /**
                     * The starting point
                     */
                    this.p1 = new org.jbox2d.common.Vec2();
                    /**
                     * The ending point
                     */
                    this.p2 = new org.jbox2d.common.Vec2();
                }
                toString() {
                    return "p1: " + this.p1 + "; p2: " + this.p2;
                }
                static tlR_$LI$() { if (Segment.tlR == null)
                    Segment.tlR = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlR; }
                ;
                static tlD_$LI$() { if (Segment.tlD == null)
                    Segment.tlD = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlD; }
                ;
                static tlN_$LI$() { if (Segment.tlN == null)
                    Segment.tlN = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlN; }
                ;
                static tlB_$LI$() { if (Segment.tlB == null)
                    Segment.tlB = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Segment.tlB; }
                ;
                testSegment(out, segment, maxLambda) {
                    let s = segment.p1;
                    let r = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Segment.tlR_$LI$()).set$org_jbox2d_common_Vec2(segment.p2);
                    r.subLocal(s);
                    let d = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Segment.tlD_$LI$()).set$org_jbox2d_common_Vec2(this.p2);
                    d.subLocal(this.p1);
                    let n = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Segment.tlN_$LI$());
                    org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(d, 1.0, n);
                    let b = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Segment.tlB_$LI$());
                    let k_slop = Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON);
                    let denom = -org.jbox2d.common.Vec2.dot(r, n);
                    if (denom > k_slop) {
                        b.set$org_jbox2d_common_Vec2(s);
                        b.subLocal(this.p1);
                        let a = org.jbox2d.common.Vec2.dot(b, n);
                        if (0.0 <= a && a <= Math.fround(maxLambda * denom)) {
                            let mu2 = Math.fround(Math.fround(-r.x * b.y) + Math.fround(r.y * b.x));
                            if (Math.fround(-k_slop * denom) <= mu2 && mu2 <= Math.fround(denom * (Math.fround(1.0 + k_slop)))) {
                                a /= denom;
                                n.normalize();
                                out.lambda = a;
                                out.normal.set$org_jbox2d_common_Vec2(n);
                                return true;
                            }
                        }
                    }
                    return false;
                }
            }
            collision.Segment = Segment;
            Segment["__class"] = "org.jbox2d.collision.Segment";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Delegate of World - for internal use.
             * @class
             */
            class ContactManager {
                constructor() {
                    if (this.m_world === undefined)
                        this.m_world = null;
                    if (this.m_nullContact === undefined)
                        this.m_nullContact = null;
                    if (this.m_destroyImmediate === undefined)
                        this.m_destroyImmediate = false;
                    this.m_nullContact = new org.jbox2d.dynamics.contacts.NullContact();
                    this.m_destroyImmediate = false;
                }
                pairAdded(proxyUserData1, proxyUserData2) {
                    let shape1 = proxyUserData1;
                    let shape2 = proxyUserData2;
                    let body1 = shape1.getBody();
                    let body2 = shape2.getBody();
                    if (body1.isStatic() && body2.isStatic()) {
                        return this.m_nullContact;
                    }
                    if (shape1.getBody() === shape2.getBody()) {
                        return this.m_nullContact;
                    }
                    if (body2.isConnected(body1)) {
                        return this.m_nullContact;
                    }
                    if (this.m_world.m_contactFilter != null && this.m_world.m_contactFilter.shouldCollide(shape1, shape2) === false) {
                        return this.m_nullContact;
                    }
                    let c = org.jbox2d.dynamics.contacts.Contact.createContact(shape1, shape2);
                    if (c == null) {
                        return this.m_nullContact;
                    }
                    shape1 = c.getShape1();
                    shape2 = c.getShape2();
                    body1 = shape1.getBody();
                    body2 = shape2.getBody();
                    c.m_prev = null;
                    c.m_next = this.m_world.m_contactList;
                    if (this.m_world.m_contactList != null) {
                        this.m_world.m_contactList.m_prev = c;
                    }
                    this.m_world.m_contactList = c;
                    c.m_node1.contact = c;
                    c.m_node1.other = body2;
                    c.m_node1.prev = null;
                    c.m_node1.next = body1.m_contactList;
                    if (body1.m_contactList != null) {
                        body1.m_contactList.prev = c.m_node1;
                    }
                    body1.m_contactList = c.m_node1;
                    c.m_node2.contact = c;
                    c.m_node2.other = body1;
                    c.m_node2.prev = null;
                    c.m_node2.next = body2.m_contactList;
                    if (body2.m_contactList != null) {
                        body2.m_contactList.prev = c.m_node2;
                    }
                    body2.m_contactList = c.m_node2;
                    ++this.m_world.m_contactCount;
                    return c;
                }
                pairRemoved(proxyUserData1, proxyUserData2, pairUserData) {
                    if (pairUserData == null) {
                        return;
                    }
                    let c = pairUserData;
                    if (c === this.m_nullContact) {
                        return;
                    }
                    this.destroy(c);
                }
                static tlV1_$LI$() { if (ContactManager.tlV1 == null)
                    ContactManager.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return ContactManager.tlV1; }
                ;
                static tlCp_$LI$() { if (ContactManager.tlCp == null)
                    ContactManager.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return ContactManager.tlCp; }
                ;
                destroy(c) {
                    let v1 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(ContactManager.tlV1_$LI$());
                    let cp = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(ContactManager.tlCp_$LI$());
                    let shape1 = c.getShape1();
                    let shape2 = c.getShape2();
                    let manifoldCount = c.getManifoldCount();
                    if (manifoldCount > 0 && (this.m_world.m_contactListener != null)) {
                        let b1 = shape1.getBody();
                        let b2 = shape2.getBody();
                        let manifolds = c.getManifolds();
                        cp.shape1 = c.getShape1();
                        cp.shape2 = c.getShape2();
                        cp.friction = c.m_friction;
                        cp.restitution = c.m_restitution;
                        for (let i = 0; i < manifoldCount; ++i) {
                            {
                                let manifold = manifolds[i];
                                cp.normal.set$org_jbox2d_common_Vec2(manifold.normal);
                                for (let j = 0; j < manifold.pointCount; ++j) {
                                    {
                                        let mp = manifold.points[j];
                                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                        cp.velocity.subLocal(v1);
                                        cp.separation = mp.separation;
                                        cp.id.set(mp.id);
                                        this.m_world.m_contactListener.remove(cp);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    if (c.m_prev != null) {
                        c.m_prev.m_next = c.m_next;
                    }
                    if (c.m_next != null) {
                        c.m_next.m_prev = c.m_prev;
                    }
                    if (c === this.m_world.m_contactList) {
                        this.m_world.m_contactList = c.m_next;
                    }
                    let body1 = shape1.getBody();
                    let body2 = shape2.getBody();
                    if (c.m_node1.prev != null) {
                        c.m_node1.prev.next = c.m_node1.next;
                    }
                    if (c.m_node1.next != null) {
                        c.m_node1.next.prev = c.m_node1.prev;
                    }
                    if (c.m_node1 === body1.m_contactList) {
                        body1.m_contactList = c.m_node1.next;
                    }
                    if (c.m_node2.prev != null) {
                        c.m_node2.prev.next = c.m_node2.next;
                    }
                    if (c.m_node2.next != null) {
                        c.m_node2.next.prev = c.m_node2.prev;
                    }
                    if (c.m_node2 === body2.m_contactList) {
                        body2.m_contactList = c.m_node2.next;
                    }
                    org.jbox2d.dynamics.contacts.Contact.destroy(c);
                    --this.m_world.m_contactCount;
                }
                collide() {
                    for (let c = this.m_world.m_contactList; c != null; c = c.getNext()) {
                        {
                            let body1 = c.getShape1().getBody();
                            let body2 = c.getShape2().getBody();
                            if (body1.isSleeping() && body2.isSleeping()) {
                                continue;
                            }
                            c.update(this.m_world.m_contactListener);
                        }
                        ;
                    }
                }
            }
            dynamics.ContactManager = ContactManager;
            ContactManager["__class"] = "org.jbox2d.dynamics.ContactManager";
            ContactManager["__interfaces"] = ["org.jbox2d.collision.PairCallback"];
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class CircleContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(shape1, shape2) {
                        if (((shape1 != null && shape1 instanceof org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                            let __args = arguments;
                            super(shape1, shape2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifold.pointCount = 0;
                                this.m_manifold.points[0].normalImpulse = 0.0;
                                this.m_manifold.points[0].tangentImpulse = 0.0;
                                this.m_manifold.points[0].localPoint1.setZero();
                                this.m_manifold.points[0].localPoint2.setZero();
                            })();
                        }
                        else if (shape1 === undefined && shape2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                this.m_manifoldCount = 0;
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    create(shape1, shape2) {
                        return new CircleContact(shape1, shape2);
                    }
                    static Destroy(contact) {
                        contact.destructor();
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.CircleContact}
                     */
                    clone() {
                        return this;
                    }
                    destructor() {
                    }
                    static tlm0_$LI$() { if (CircleContact.tlm0 == null)
                        CircleContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return CircleContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (CircleContact.tlV1 == null)
                        CircleContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (CircleContact.tlCp == null)
                        CircleContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return CircleContact.tlCp; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollideCircle().collideCircles(this.m_manifold, this.m_shape1, b1.m_xf, this.m_shape2, b2.m_xf);
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            this.m_manifoldCount = 1;
                            let mp = this.m_manifold.points[0];
                            if (m0.pointCount === 0) {
                                mp.normalImpulse = 0.0;
                                mp.tangentImpulse = 0.0;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.add(cp);
                                }
                            }
                            else {
                                let mp0 = m0.points[0];
                                mp.normalImpulse = mp0.normalImpulse;
                                mp.tangentImpulse = mp0.tangentImpulse;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.persist(cp);
                                }
                            }
                        }
                        else {
                            this.m_manifoldCount = 0;
                            if (m0.pointCount > 0 && (listener != null)) {
                                let mp0 = m0.points[0];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(m0.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                        }
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                }
                contacts.CircleContact = CircleContact;
                CircleContact["__class"] = "org.jbox2d.dynamics.contacts.CircleContact";
                CircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class EdgeAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(s1, s2) {
                        if (((s1 != null && s1 instanceof org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                            let __args = arguments;
                            super(s1, s2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else if (s1 === undefined && s2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.Contact}
                     */
                    clone() {
                        return this;
                    }
                    static Destroy(contact) {
                        contact.destructor();
                    }
                    destructor() {
                    }
                    static tlm0_$LI$() { if (EdgeAndCircleContact.tlm0 == null)
                        EdgeAndCircleContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return EdgeAndCircleContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (EdgeAndCircleContact.tlV1 == null)
                        EdgeAndCircleContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeAndCircleContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (EdgeAndCircleContact.tlCp == null)
                        EdgeAndCircleContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return EdgeAndCircleContact.tlCp; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeAndCircleContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeAndCircleContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeAndCircleContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollideCircle().collideEdgeAndCircle(this.m_manifold, this.m_shape1, b1.getMemberXForm(), this.m_shape2, b2.getMemberXForm());
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            this.m_manifoldCount = 1;
                            let mp = this.m_manifold.points[0];
                            if (m0.pointCount === 0) {
                                mp.normalImpulse = 0.0;
                                mp.tangentImpulse = 0.0;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.add(cp);
                                }
                            }
                            else {
                                let mp0 = m0.points[0];
                                mp.normalImpulse = mp0.normalImpulse;
                                mp.tangentImpulse = mp0.tangentImpulse;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.persist(cp);
                                }
                            }
                        }
                        else {
                            this.m_manifoldCount = 0;
                            if (m0.pointCount > 0 && (listener != null)) {
                                let mp0 = m0.points[0];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                        }
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                    create(s1, s2) {
                        return new EdgeAndCircleContact(s1, s2);
                    }
                }
                contacts.EdgeAndCircleContact = EdgeAndCircleContact;
                EdgeAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.EdgeAndCircleContact";
                EdgeAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class PointAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(shape1, shape2) {
                        if (((shape1 != null && shape1 instanceof org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                            let __args = arguments;
                            super(shape1, shape2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifold.pointCount = 0;
                                this.m_manifold.points[0].normalImpulse = 0.0;
                                this.m_manifold.points[0].tangentImpulse = 0.0;
                                this.m_manifold.points[0].localPoint1.setZero();
                                this.m_manifold.points[0].localPoint2.setZero();
                            })();
                        }
                        else if (shape1 === undefined && shape2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    create(shape1, shape2) {
                        return new PointAndCircleContact(shape1, shape2);
                    }
                    static Destroy(contact) {
                        contact.destructor();
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.PointAndCircleContact}
                     */
                    clone() {
                        return this;
                    }
                    destructor() {
                    }
                    static tlm0_$LI$() { if (PointAndCircleContact.tlm0 == null)
                        PointAndCircleContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PointAndCircleContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (PointAndCircleContact.tlV1 == null)
                        PointAndCircleContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointAndCircleContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (PointAndCircleContact.tlCp == null)
                        PointAndCircleContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PointAndCircleContact.tlCp; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndCircleContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndCircleContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndCircleContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollideCircle().collidePointAndCircle(this.m_manifold, this.m_shape1, b1.m_xf, this.m_shape2, b2.m_xf);
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            this.m_manifoldCount = 1;
                            let mp = this.m_manifold.points[0];
                            if (m0.pointCount === 0) {
                                mp.normalImpulse = 0.0;
                                mp.tangentImpulse = 0.0;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.add(cp);
                                }
                            }
                            else {
                                let mp0 = m0.points[0];
                                mp.normalImpulse = mp0.normalImpulse;
                                mp.tangentImpulse = mp0.tangentImpulse;
                                if (listener != null) {
                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                    cp.velocity.subLocal(v1);
                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                    cp.separation = mp.separation;
                                    cp.id.set(mp.id);
                                    listener.persist(cp);
                                }
                            }
                        }
                        else {
                            this.m_manifoldCount = 0;
                            if (m0.pointCount > 0 && (listener != null)) {
                                let mp0 = m0.points[0];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                        }
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                }
                contacts.PointAndCircleContact = PointAndCircleContact;
                PointAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.PointAndCircleContact";
                PointAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class PolyContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(s1, s2) {
                        if (((s1 != null && s1 instanceof org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                            let __args = arguments;
                            super(s1, s2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                this.m_manifoldCount = 0;
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                            })();
                        }
                        else if (s1 === undefined && s2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                this.m_manifoldCount = 0;
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.Contact}
                     */
                    clone() {
                        let newC = new PolyContact(this.m_shape1, this.m_shape2);
                        if (this.m_manifold != null) {
                            newC.m_manifold.set(this.m_manifold);
                        }
                        newC.m_manifoldCount = this.m_manifoldCount;
                        newC.m_world = this.m_world;
                        newC.m_toi = this.m_toi;
                        newC.m_prev = this.m_prev;
                        newC.m_next = this.m_next;
                        newC.m_node1.set(this.m_node1);
                        newC.m_node2.set(this.m_node2);
                        newC.m_friction = this.m_friction;
                        newC.m_restitution = this.m_restitution;
                        newC.m_flags = this.m_flags;
                        return newC;
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                    create(shape1, shape2) {
                        return new PolyContact(shape1, shape2);
                    }
                    dumpManifoldPoints() {
                        for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                            {
                                let mp = this.m_manifold.points[i];
                                console.info("Manifold point dump: " + mp.normalImpulse + " " + mp.tangentImpulse);
                            }
                            ;
                        }
                    }
                    static tlm0_$LI$() { if (PolyContact.tlm0 == null)
                        PolyContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (PolyContact.tlV1 == null)
                        PolyContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (PolyContact.tlCp == null)
                        PolyContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyContact.tlCp; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolygons(this.m_manifold, this.m_shape1, b1.getMemberXForm(), this.m_shape2, b2.getMemberXForm());
                        let persisted = [false, false];
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                                {
                                    let mp = this.m_manifold.points[i];
                                    mp.normalImpulse = 0.0;
                                    mp.tangentImpulse = 0.0;
                                    let found = false;
                                    let id = mp.id;
                                    for (let j = 0; j < m0.pointCount; ++j) {
                                        {
                                            if (persisted[j] === true) {
                                                continue;
                                            }
                                            let mp0 = m0.points[j];
                                            if (mp0.id.isEqual(id)) {
                                                persisted[j] = true;
                                                mp.normalImpulse = mp0.normalImpulse;
                                                mp.tangentImpulse = mp0.tangentImpulse;
                                                found = true;
                                                if (listener != null) {
                                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                                    cp.velocity.subLocal(v1);
                                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                                    cp.separation = mp.separation;
                                                    cp.id.set(id);
                                                    listener.persist(cp);
                                                }
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    if (found === false && listener != null) {
                                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                        cp.velocity.subLocal(v1);
                                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                        cp.separation = mp.separation;
                                        cp.id.set(id);
                                        listener.add(cp);
                                    }
                                }
                                ;
                            }
                            this.m_manifoldCount = 1;
                        }
                        else {
                            this.m_manifoldCount = 0;
                        }
                        if (listener == null) {
                            return;
                        }
                        for (let i = 0; i < m0.pointCount; ++i) {
                            {
                                if (persisted[i]) {
                                    continue;
                                }
                                let mp0 = m0.points[i];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                            ;
                        }
                    }
                }
                contacts.PolyContact = PolyContact;
                PolyContact["__class"] = "org.jbox2d.dynamics.contacts.PolyContact";
                PolyContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class DistanceJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        if (this.m_localAnchor1 === undefined)
                            this.m_localAnchor1 = null;
                        if (this.m_localAnchor2 === undefined)
                            this.m_localAnchor2 = null;
                        if (this.m_u === undefined)
                            this.m_u = null;
                        if (this.m_impulse === undefined)
                            this.m_impulse = 0;
                        if (this.m_mass === undefined)
                            this.m_mass = 0;
                        if (this.m_length === undefined)
                            this.m_length = 0;
                        if (this.m_frequencyHz === undefined)
                            this.m_frequencyHz = 0;
                        if (this.m_dampingRatio === undefined)
                            this.m_dampingRatio = 0;
                        if (this.m_gamma === undefined)
                            this.m_gamma = 0;
                        if (this.m_bias === undefined)
                            this.m_bias = 0;
                        this.m_localAnchor1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor1);
                        this.m_localAnchor2 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor2);
                        this.m_length = def.length;
                        this.m_impulse = 0.0;
                        this.m_u = new org.jbox2d.common.Vec2();
                        this.m_frequencyHz = def.frequencyHz;
                        this.m_dampingRatio = def.dampingRatio;
                        this.m_gamma = 0.0;
                        this.m_bias = 0.0;
                        this.m_inv_dt = 0.0;
                    }
                    setFrequency(hz) {
                        this.m_frequencyHz = hz;
                    }
                    getFrequency() {
                        return this.m_frequencyHz;
                    }
                    setDampingRatio(damp) {
                        this.m_dampingRatio = damp;
                    }
                    getDampingRatio() {
                        return this.m_dampingRatio;
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_body1.getWorldLocation(this.m_localAnchor1);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return this.m_body2.getWorldLocation(this.m_localAnchor2);
                    }
                    static tlReactionForce_$LI$() { if (DistanceJoint.tlReactionForce == null)
                        DistanceJoint.tlReactionForce = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlReactionForce; }
                    ;
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        let reactionForce = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlReactionForce_$LI$());
                        reactionForce.x = Math.fround(this.m_impulse * this.m_u.x);
                        reactionForce.y = Math.fround(this.m_impulse * this.m_u.y);
                        return reactionForce;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return 0.0;
                    }
                    static tlr1_$LI$() { if (DistanceJoint.tlr1 == null)
                        DistanceJoint.tlr1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlr1; }
                    ;
                    static tlr2_$LI$() { if (DistanceJoint.tlr2 == null)
                        DistanceJoint.tlr2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlr2; }
                    ;
                    static tlP_$LI$() { if (DistanceJoint.tlP == null)
                        DistanceJoint.tlP = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlP; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        this.m_inv_dt = step.inv_dt;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr2_$LI$());
                        let P = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlP_$LI$());
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
                        this.m_u.x = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.x + r2.x) - b1.m_sweep.c.x) - r1.x);
                        this.m_u.y = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.y + r2.y) - b1.m_sweep.c.y) - r1.y);
                        let length = this.m_u.length();
                        if (length > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                            this.m_u.x *= Math.fround(1.0 / length);
                            this.m_u.y *= Math.fround(1.0 / length);
                        }
                        else {
                            this.m_u.set$float$float(0.0, 0.0);
                        }
                        let cr1u = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_u);
                        let cr2u = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_u);
                        let invMass = Math.fround(Math.fround(Math.fround(b1.m_invMass + Math.fround(Math.fround(b1.m_invI * cr1u) * cr1u)) + b2.m_invMass) + Math.fround(Math.fround(b2.m_invI * cr2u) * cr2u));
                        this.m_mass = Math.fround(1.0 / invMass);
                        if (this.m_frequencyHz > 0.0) {
                            let C = Math.fround(length - this.m_length);
                            let omega = Math.fround(Math.fround(2.0 * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_frequencyHz);
                            let d = Math.fround(Math.fround(Math.fround(2.0 * this.m_mass) * this.m_dampingRatio) * omega);
                            let k = Math.fround(Math.fround(this.m_mass * omega) * omega);
                            this.m_gamma = Math.fround(1.0 / (Math.fround(step.dt * (Math.fround(d + Math.fround(step.dt * k))))));
                            this.m_bias = Math.fround(Math.fround(Math.fround(C * step.dt) * k) * this.m_gamma);
                            this.m_mass = Math.fround(1.0 / (Math.fround(invMass + this.m_gamma)));
                        }
                        if (step.warmStarting) {
                            this.m_impulse *= step.dtRatio;
                            P.set$org_jbox2d_common_Vec2(this.m_u);
                            P.mulLocal(this.m_impulse);
                            b1.m_linearVelocity.x -= Math.fround(b1.m_invMass * P.x);
                            b1.m_linearVelocity.y -= Math.fround(b1.m_invMass * P.y);
                            b1.m_angularVelocity -= Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P));
                            b2.m_linearVelocity.x += Math.fround(b2.m_invMass * P.x);
                            b2.m_linearVelocity.y += Math.fround(b2.m_invMass * P.y);
                            b2.m_angularVelocity += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P));
                        }
                        else {
                            this.m_impulse = 0.0;
                        }
                    }
                    static tld_$LI$() { if (DistanceJoint.tld == null)
                        DistanceJoint.tld = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tld; }
                    ;
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        if (this.m_frequencyHz > 0.0) {
                            return true;
                        }
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tld_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr2_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr1_$LI$());
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.getMemberXForm().R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.getMemberXForm().R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
                        d.x = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.x + r2.x) - b1.m_sweep.c.x) - r1.x);
                        d.y = Math.fround(Math.fround(Math.fround(b2.m_sweep.c.y + r2.y) - b1.m_sweep.c.y) - r1.y);
                        let length = d.normalize();
                        let C = Math.fround(length - this.m_length);
                        C = org.jbox2d.common.MathUtils.clamp$float$float$float(C, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                        let impulse = Math.fround(-this.m_mass * C);
                        this.m_u.set$org_jbox2d_common_Vec2(d);
                        let Px = Math.fround(impulse * this.m_u.x);
                        let Py = Math.fround(impulse * this.m_u.y);
                        b1.m_sweep.c.x -= Math.fround(b1.m_invMass * Px);
                        b1.m_sweep.c.y -= Math.fround(b1.m_invMass * Py);
                        b1.m_sweep.a -= Math.fround(b1.m_invI * (Math.fround(Math.fround(r1.x * Py) - Math.fround(r1.y * Px))));
                        b2.m_sweep.c.x += Math.fround(b2.m_invMass * Px);
                        b2.m_sweep.c.y += Math.fround(b2.m_invMass * Py);
                        b2.m_sweep.a += Math.fround(b2.m_invI * (Math.fround(Math.fround(r2.x * Py) - Math.fround(r2.y * Px))));
                        b1.synchronizeTransform();
                        b2.synchronizeTransform();
                        return org.jbox2d.common.MathUtils.abs(C) < org.jbox2d.common.Settings.linearSlop_$LI$();
                    }
                    static tlv1_$LI$() { if (DistanceJoint.tlv1 == null)
                        DistanceJoint.tlv1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlv1; }
                    ;
                    static tlv2_$LI$() { if (DistanceJoint.tlv2 == null)
                        DistanceJoint.tlv2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return DistanceJoint.tlv2; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlv1_$LI$());
                        let v2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlv2_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(DistanceJoint.tlr2_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
                        v1.addLocal$org_jbox2d_common_Vec2(b1.m_linearVelocity);
                        v2.addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
                        let Cdot = org.jbox2d.common.Vec2.dot(this.m_u, v2.subLocal(v1));
                        let impulse = Math.fround(-this.m_mass * (Math.fround(Math.fround(Cdot + this.m_bias) + Math.fround(this.m_gamma * this.m_impulse))));
                        this.m_impulse += impulse;
                        let Px = Math.fround(impulse * this.m_u.x);
                        let Py = Math.fround(impulse * this.m_u.y);
                        b1.m_linearVelocity.x -= Math.fround(b1.m_invMass * Px);
                        b1.m_linearVelocity.y -= Math.fround(b1.m_invMass * Py);
                        b1.m_angularVelocity -= Math.fround(b1.m_invI * (Math.fround(Math.fround(r1.x * Py) - Math.fround(r1.y * Px))));
                        b2.m_linearVelocity.x += Math.fround(b2.m_invMass * Px);
                        b2.m_linearVelocity.y += Math.fround(b2.m_invMass * Py);
                        b2.m_angularVelocity += Math.fround(b2.m_invI * (Math.fround(Math.fround(r2.x * Py) - Math.fround(r2.y * Px))));
                    }
                }
                joints.DistanceJoint = DistanceJoint;
                DistanceJoint["__class"] = "org.jbox2d.dynamics.joints.DistanceJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class MouseJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        if (this.m_localAnchor === undefined)
                            this.m_localAnchor = null;
                        if (this.m_target === undefined)
                            this.m_target = null;
                        if (this.m_force === undefined)
                            this.m_force = null;
                        if (this.m_mass === undefined)
                            this.m_mass = null;
                        if (this.m_C === undefined)
                            this.m_C = null;
                        if (this.m_maxForce === undefined)
                            this.m_maxForce = 0;
                        if (this.m_beta === undefined)
                            this.m_beta = 0;
                        if (this.m_gamma === undefined)
                            this.m_gamma = 0;
                        this.m_force = new org.jbox2d.common.Vec2();
                        this.m_target = new org.jbox2d.common.Vec2();
                        this.m_C = new org.jbox2d.common.Vec2();
                        this.m_mass = new org.jbox2d.common.Mat22();
                        this.m_target.set$org_jbox2d_common_Vec2(def.target);
                        this.m_localAnchor = org.jbox2d.common.XForm.mulTrans(this.m_body2.m_xf, this.m_target);
                        this.m_maxForce = def.maxForce;
                        let mass = this.m_body2.m_mass;
                        let omega = Math.fround(Math.fround(2.0 * org.jbox2d.common.Settings.pi_$LI$()) * def.frequencyHz);
                        let d = Math.fround(Math.fround(Math.fround(2.0 * mass) * def.dampingRatio) * omega);
                        let k = Math.fround(Math.fround(mass * omega) * omega);
                        this.m_gamma = Math.fround(1.0 / (Math.fround(d + Math.fround(def.timeStep * k))));
                        this.m_beta = Math.fround(Math.fround(def.timeStep * k) / (Math.fround(d + Math.fround(def.timeStep * k))));
                    }
                    /**
                     * Use this to update the target point.
                     * @param {org.jbox2d.common.Vec2} target
                     */
                    setTarget(target) {
                        if (this.m_body2.isSleeping()) {
                            this.m_body2.wakeUp();
                        }
                        this.m_target.set$org_jbox2d_common_Vec2(target);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_target;
                    }
                    static tlanchor2_$LI$() { if (MouseJoint.tlanchor2 == null)
                        MouseJoint.tlanchor2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlanchor2; }
                    ;
                    /**
                     * this comes from a pooled value
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        let anchor2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlanchor2_$LI$());
                        this.m_body2.getWorldLocationToOut(this.m_localAnchor, anchor2);
                        return anchor2;
                    }
                    static tlr_$LI$() { if (MouseJoint.tlr == null)
                        MouseJoint.tlr = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlr; }
                    ;
                    static tlK1_$LI$() { if (MouseJoint.tlK1 == null)
                        MouseJoint.tlK1 = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return MouseJoint.tlK1; }
                    ;
                    static tlK2_$LI$() { if (MouseJoint.tlK2 == null)
                        MouseJoint.tlK2 = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return MouseJoint.tlK2; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        let b = this.m_body2;
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlr_$LI$());
                        let K1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlK1_$LI$());
                        let K2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlK2_$LI$());
                        r.set$org_jbox2d_common_Vec2(this.m_localAnchor);
                        r.subLocal(b.getMemberLocalCenter());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_xf.R, r, r);
                        let invMass = b.m_invMass;
                        let invI = b.m_invI;
                        K1.set$float$float$float$float(invMass, 0.0, 0.0, invMass);
                        K2.set$float$float$float$float(Math.fround(Math.fround(invI * r.y) * r.y), Math.fround(Math.fround(-invI * r.x) * r.y), Math.fround(Math.fround(-invI * r.x) * r.y), Math.fround(Math.fround(invI * r.x) * r.x));
                        K1.addLocal(K2);
                        K1.col1.x += this.m_gamma;
                        K1.col2.y += this.m_gamma;
                        K1.invertToOut(this.m_mass);
                        this.m_C.set$float$float(Math.fround(Math.fround(b.m_sweep.c.x + r.x) - this.m_target.x), Math.fround(Math.fround(b.m_sweep.c.y + r.y) - this.m_target.y));
                        b.m_angularVelocity *= 0.98;
                        let Px = Math.fround(step.dt * this.m_force.x);
                        let Py = Math.fround(step.dt * this.m_force.y);
                        b.m_linearVelocity.x += Math.fround(invMass * Px);
                        b.m_linearVelocity.y += Math.fround(invMass * Py);
                        b.m_angularVelocity += Math.fround(invI * (Math.fround(Math.fround(r.x * Py) - Math.fround(r.y * Px))));
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        return true;
                    }
                    static tlCdot_$LI$() { if (MouseJoint.tlCdot == null)
                        MouseJoint.tlCdot = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlCdot; }
                    ;
                    static tlforce_$LI$() { if (MouseJoint.tlforce == null)
                        MouseJoint.tlforce = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlforce; }
                    ;
                    static tloldForce_$LI$() { if (MouseJoint.tloldForce == null)
                        MouseJoint.tloldForce = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tloldForce; }
                    ;
                    static tlP_$LI$() { if (MouseJoint.tlP == null)
                        MouseJoint.tlP = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return MouseJoint.tlP; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b = this.m_body2;
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlr_$LI$());
                        let Cdot = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlCdot_$LI$());
                        let force = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlforce_$LI$());
                        let oldForce = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tloldForce_$LI$());
                        let P = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(MouseJoint.tlP_$LI$());
                        r.set$org_jbox2d_common_Vec2(this.m_localAnchor);
                        r.subLocal(b.getMemberLocalCenter());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_xf.R, r, r);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b.m_angularVelocity, r, Cdot);
                        Cdot.addLocal$org_jbox2d_common_Vec2(b.m_linearVelocity);
                        force.set$float$float(Math.fround(Math.fround(Cdot.x + Math.fround((Math.fround(this.m_beta * step.inv_dt)) * this.m_C.x)) + Math.fround(Math.fround(this.m_gamma * step.dt) * this.m_force.x)), Math.fround(Math.fround(Cdot.y + Math.fround((Math.fround(this.m_beta * step.inv_dt)) * this.m_C.y)) + Math.fround(Math.fround(this.m_gamma * step.dt) * this.m_force.y)));
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_mass, force, force);
                        force.mulLocal(-step.inv_dt);
                        oldForce.set$org_jbox2d_common_Vec2(this.m_force);
                        this.m_force.addLocal$org_jbox2d_common_Vec2(force);
                        let forceMagnitude = this.m_force.length();
                        if (forceMagnitude > this.m_maxForce) {
                            this.m_force.mulLocal(Math.fround(this.m_maxForce / forceMagnitude));
                        }
                        force.set$float$float(Math.fround(this.m_force.x - oldForce.x), Math.fround(this.m_force.y - oldForce.y));
                        P.x = Math.fround(step.dt * force.x);
                        P.y = Math.fround(step.dt * force.y);
                        b.m_angularVelocity += Math.fround(b.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r, P));
                        b.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P.mulLocal(b.m_invMass));
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        return this.m_force;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return 0.0;
                    }
                }
                joints.MouseJoint = MouseJoint;
                MouseJoint["__class"] = "org.jbox2d.dynamics.joints.MouseJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                /**
                 * A prismatic joint. This joint provides one degree of freedom: translation
                 * along an axis fixed in body1. Relative rotation is prevented. You can
                 * use a joint limit to restrict the range of motion and a joint motor to
                 * drive the motion or to model joint friction.
                 * @param {org.jbox2d.dynamics.joints.PrismaticJointDef} def
                 * @class
                 * @extends org.jbox2d.dynamics.joints.Joint
                 */
                class PrismaticJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        if (this.m_localAnchor1 === undefined)
                            this.m_localAnchor1 = null;
                        if (this.m_localAnchor2 === undefined)
                            this.m_localAnchor2 = null;
                        if (this.m_localXAxis1 === undefined)
                            this.m_localXAxis1 = null;
                        if (this.m_localYAxis1 === undefined)
                            this.m_localYAxis1 = null;
                        if (this.m_refAngle === undefined)
                            this.m_refAngle = 0;
                        if (this.m_linearJacobian === undefined)
                            this.m_linearJacobian = null;
                        if (this.m_linearMass === undefined)
                            this.m_linearMass = 0;
                        if (this.m_force === undefined)
                            this.m_force = 0;
                        if (this.m_angularMass === undefined)
                            this.m_angularMass = 0;
                        if (this.m_torque === undefined)
                            this.m_torque = 0;
                        if (this.m_motorJacobian === undefined)
                            this.m_motorJacobian = null;
                        if (this.m_motorMass === undefined)
                            this.m_motorMass = 0;
                        if (this.m_motorForce === undefined)
                            this.m_motorForce = 0;
                        if (this.m_limitForce === undefined)
                            this.m_limitForce = 0;
                        if (this.m_limitPositionImpulse === undefined)
                            this.m_limitPositionImpulse = 0;
                        if (this.m_lowerTranslation === undefined)
                            this.m_lowerTranslation = 0;
                        if (this.m_upperTranslation === undefined)
                            this.m_upperTranslation = 0;
                        if (this.m_maxMotorForce === undefined)
                            this.m_maxMotorForce = 0;
                        if (this.m_motorSpeed === undefined)
                            this.m_motorSpeed = 0;
                        if (this.m_enableLimit === undefined)
                            this.m_enableLimit = false;
                        if (this.m_enableMotor === undefined)
                            this.m_enableMotor = false;
                        if (this.m_limitState === undefined)
                            this.m_limitState = null;
                        if (this.m_lastWarmStartingForce === undefined)
                            this.m_lastWarmStartingForce = 0;
                        if (this.m_lastWarmStartingTorque === undefined)
                            this.m_lastWarmStartingTorque = 0;
                        this.m_localAnchor1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor1);
                        this.m_localAnchor2 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor2);
                        this.m_localXAxis1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAxis1);
                        this.m_localYAxis1 = org.jbox2d.common.Vec2.cross$float$org_jbox2d_common_Vec2(1.0, this.m_localXAxis1);
                        this.m_refAngle = def.referenceAngle;
                        this.m_linearJacobian = new org.jbox2d.dynamics.joints.Jacobian();
                        this.m_linearMass = 0.0;
                        this.m_force = 0.0;
                        this.m_angularMass = 0.0;
                        this.m_torque = 0.0;
                        this.m_motorJacobian = new org.jbox2d.dynamics.joints.Jacobian();
                        this.m_motorMass = 0.0;
                        this.m_motorForce = 0.0;
                        this.m_limitForce = 0.0;
                        this.m_limitPositionImpulse = 0.0;
                        this.m_lowerTranslation = def.lowerTranslation;
                        this.m_upperTranslation = def.upperTranslation;
                        this.m_maxMotorForce = def.maxMotorForce;
                        this.m_motorSpeed = def.motorSpeed;
                        this.m_enableLimit = def.enableLimit;
                        this.m_enableMotor = def.enableMotor;
                    }
                    static tlr1_$LI$() { if (PrismaticJoint.tlr1 == null)
                        PrismaticJoint.tlr1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr1; }
                    ;
                    static tlr2_$LI$() { if (PrismaticJoint.tlr2 == null)
                        PrismaticJoint.tlr2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr2; }
                    ;
                    static tlax1_$LI$() { if (PrismaticJoint.tlax1 == null)
                        PrismaticJoint.tlax1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlax1; }
                    ;
                    static tlay1_$LI$() { if (PrismaticJoint.tlay1 == null)
                        PrismaticJoint.tlay1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlay1; }
                    ;
                    static tle_$LI$() { if (PrismaticJoint.tle == null)
                        PrismaticJoint.tle = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tle; }
                    ;
                    static tlax1Neg_$LI$() { if (PrismaticJoint.tlax1Neg == null)
                        PrismaticJoint.tlax1Neg = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlax1Neg; }
                    ;
                    static tlay1Neg_$LI$() { if (PrismaticJoint.tlay1Neg == null)
                        PrismaticJoint.tlay1Neg = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlay1Neg; }
                    ;
                    static tld_$LI$() { if (PrismaticJoint.tld == null)
                        PrismaticJoint.tld = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tld; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr2_$LI$());
                        let ax1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlax1_$LI$());
                        let ay1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlay1_$LI$());
                        let e = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tle_$LI$());
                        let ax1Neg = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlax1Neg_$LI$());
                        let ay1Neg = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlay1Neg_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tld_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
                        let invMass1 = b1.m_invMass;
                        let invMass2 = b2.m_invMass;
                        let invI1 = b1.m_invI;
                        let invI2 = b2.m_invI;
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localYAxis1, ay1);
                        e.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                        e.addLocal$org_jbox2d_common_Vec2(r2).subLocal(b1.m_sweep.c);
                        org.jbox2d.common.Vec2.negateToOut(ay1, ay1Neg);
                        this.m_linearJacobian.set(ay1Neg, -org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e, ay1), ay1, org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, ay1));
                        this.m_linearMass = Math.fround(Math.fround(Math.fround(invMass1 + Math.fround(Math.fround(invI1 * this.m_linearJacobian.angular1) * this.m_linearJacobian.angular1)) + invMass2) + Math.fround(Math.fround(invI2 * this.m_linearJacobian.angular2) * this.m_linearJacobian.angular2));
                        this.m_linearMass = Math.fround(1.0 / this.m_linearMass);
                        this.m_angularMass = Math.fround(invI1 + invI2);
                        if (this.m_angularMass > org.jbox2d.common.Settings.EPSILON) {
                            this.m_angularMass = Math.fround(1.0 / this.m_angularMass);
                        }
                        if (this.m_enableLimit || this.m_enableMotor) {
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localXAxis1, ax1);
                            org.jbox2d.common.Vec2.negateToOut(ax1, ax1Neg);
                            this.m_motorJacobian.set(ax1Neg, -org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e, ax1), ax1, org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, ax1));
                            this.m_motorMass = Math.fround(Math.fround(Math.fround(invMass1 + Math.fround(Math.fround(invI1 * this.m_motorJacobian.angular1) * this.m_motorJacobian.angular1)) + invMass2) + Math.fround(Math.fround(invI2 * this.m_motorJacobian.angular2) * this.m_motorJacobian.angular2));
                            this.m_motorMass = Math.fround(1.0 / this.m_motorMass);
                            if (this.m_enableLimit) {
                                d.set$org_jbox2d_common_Vec2(e);
                                d.subLocal(r1);
                                let jointTranslation = org.jbox2d.common.Vec2.dot(ax1, d);
                                if (org.jbox2d.common.MathUtils.abs(Math.fround(this.m_upperTranslation - this.m_lowerTranslation)) < Math.fround(2.0 * org.jbox2d.common.Settings.linearSlop_$LI$())) {
                                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS;
                                }
                                else if (jointTranslation <= this.m_lowerTranslation) {
                                    if (this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                        this.m_limitForce = 0.0;
                                    }
                                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT;
                                }
                                else if (jointTranslation >= this.m_upperTranslation) {
                                    if (this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                        this.m_limitForce = 0.0;
                                    }
                                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                                }
                                else {
                                    this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                                    this.m_limitForce = 0.0;
                                }
                            }
                        }
                        if (this.m_enableMotor === false) {
                            this.m_motorForce = 0.0;
                        }
                        if (this.m_enableLimit === false) {
                            this.m_limitForce = 0.0;
                        }
                        if (step.warmStarting) {
                            let L1 = Math.fround(step.dt * (Math.fround(Math.fround(Math.fround(this.m_force * this.m_linearJacobian.angular1) - this.m_torque) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.angular1))));
                            let L2 = Math.fround(step.dt * (Math.fround(Math.fround(Math.fround(this.m_force * this.m_linearJacobian.angular2) + this.m_torque) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.angular2))));
                            b1.m_linearVelocity.x += Math.fround(Math.fround(invMass1 * step.dt) * (Math.fround(Math.fround(this.m_force * this.m_linearJacobian.linear1.x) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear1.x))));
                            b1.m_linearVelocity.y += Math.fround(Math.fround(invMass1 * step.dt) * (Math.fround(Math.fround(this.m_force * this.m_linearJacobian.linear1.y) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear1.y))));
                            b1.m_angularVelocity += Math.fround(invI1 * L1);
                            b2.m_linearVelocity.x += Math.fround(Math.fround(invMass2 * step.dt) * (Math.fround(Math.fround(this.m_force * this.m_linearJacobian.linear2.x) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear2.x))));
                            b2.m_linearVelocity.y += Math.fround(Math.fround(invMass2 * step.dt) * (Math.fround(Math.fround(this.m_force * this.m_linearJacobian.linear2.y) + Math.fround((Math.fround(this.m_motorForce + this.m_limitForce)) * this.m_motorJacobian.linear2.y))));
                            b2.m_angularVelocity += Math.fround(invI2 * L2);
                        }
                        else {
                            this.m_force = 0.0;
                            this.m_torque = 0.0;
                            this.m_limitForce = 0.0;
                            this.m_motorForce = 0.0;
                        }
                        this.m_limitPositionImpulse = 0.0;
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let invMass1 = b1.m_invMass;
                        let invMass2 = b2.m_invMass;
                        let invI1 = b1.m_invI;
                        let invI2 = b2.m_invI;
                        let linearCdot = this.m_linearJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
                        let force = Math.fround(Math.fround(-step.inv_dt * this.m_linearMass) * linearCdot);
                        if (step.warmStarting) {
                            this.m_force += (force);
                            this.m_lastWarmStartingForce = this.m_force;
                        }
                        else {
                            this.m_force = this.m_lastWarmStartingForce;
                        }
                        let P = Math.fround(step.dt * force);
                        b1.m_linearVelocity.x += Math.fround((Math.fround(invMass1 * P)) * this.m_linearJacobian.linear1.x);
                        b1.m_linearVelocity.y += Math.fround((Math.fround(invMass1 * P)) * this.m_linearJacobian.linear1.y);
                        b1.m_angularVelocity += Math.fround(Math.fround(invI1 * P) * this.m_linearJacobian.angular1);
                        b2.m_linearVelocity.x += Math.fround((Math.fround(invMass2 * P)) * this.m_linearJacobian.linear2.x);
                        b2.m_linearVelocity.y += Math.fround((Math.fround(invMass2 * P)) * this.m_linearJacobian.linear2.y);
                        b2.m_angularVelocity += Math.fround(Math.fround(invI2 * P) * this.m_linearJacobian.angular2);
                        let angularCdot = Math.fround(b2.m_angularVelocity - b1.m_angularVelocity);
                        let torque = Math.fround(Math.fround(-step.inv_dt * this.m_angularMass) * angularCdot);
                        this.m_torque += torque;
                        if (step.warmStarting) {
                            this.m_torque += torque;
                            this.m_lastWarmStartingTorque = this.m_torque;
                        }
                        else {
                            this.m_torque = this.m_lastWarmStartingTorque;
                        }
                        let L = Math.fround(step.dt * torque);
                        b1.m_angularVelocity -= Math.fround(invI1 * L);
                        b2.m_angularVelocity += Math.fround(invI2 * L);
                        if (this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                            let motorCdot = Math.fround(this.m_motorJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity) - this.m_motorSpeed);
                            let motorForce = Math.fround(Math.fround(-step.inv_dt * this.m_motorMass) * motorCdot);
                            let oldMotorForce = this.m_motorForce;
                            this.m_motorForce = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(this.m_motorForce + motorForce), -this.m_maxMotorForce, this.m_maxMotorForce);
                            motorForce = Math.fround(this.m_motorForce - oldMotorForce);
                            let P2 = Math.fround(step.dt * motorForce);
                            b1.m_linearVelocity.x += Math.fround((Math.fround(invMass1 * P2)) * this.m_motorJacobian.linear1.x);
                            b1.m_linearVelocity.y += Math.fround((Math.fround(invMass1 * P2)) * this.m_motorJacobian.linear1.y);
                            b1.m_angularVelocity += Math.fround(Math.fround(invI1 * P2) * this.m_motorJacobian.angular1);
                            b2.m_linearVelocity.x += Math.fround((Math.fround(invMass2 * P2)) * this.m_motorJacobian.linear2.x);
                            b2.m_linearVelocity.y += Math.fround((Math.fround(invMass2 * P2)) * this.m_motorJacobian.linear2.y);
                            b2.m_angularVelocity += Math.fround(Math.fround(invI2 * P2) * this.m_motorJacobian.angular2);
                        }
                        if (this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                            let limitCdot = this.m_motorJacobian.compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity);
                            let limitForce = Math.fround(Math.fround(-step.inv_dt * this.m_motorMass) * limitCdot);
                            if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                                this.m_limitForce += limitForce;
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                let oldLimitForce = this.m_limitForce;
                                this.m_limitForce = org.jbox2d.common.MathUtils.max$float$float(Math.fround(this.m_limitForce + limitForce), 0.0);
                                limitForce = Math.fround(this.m_limitForce - oldLimitForce);
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                let oldLimitForce = this.m_limitForce;
                                this.m_limitForce = org.jbox2d.common.MathUtils.min(Math.fround(this.m_limitForce + limitForce), 0.0);
                                limitForce = Math.fround(this.m_limitForce - oldLimitForce);
                            }
                            let P2 = Math.fround(step.dt * limitForce);
                            b1.m_linearVelocity.x += Math.fround((Math.fround(invMass1 * P2)) * this.m_motorJacobian.linear1.x);
                            b1.m_linearVelocity.y += Math.fround((Math.fround(invMass1 * P2)) * this.m_motorJacobian.linear1.y);
                            b1.m_angularVelocity += Math.fround(Math.fround(invI1 * P2) * this.m_motorJacobian.angular1);
                            b2.m_linearVelocity.x += Math.fround((Math.fround(invMass2 * P2)) * this.m_motorJacobian.linear2.x);
                            b2.m_linearVelocity.y += Math.fround((Math.fround(invMass2 * P2)) * this.m_motorJacobian.linear2.y);
                            b2.m_angularVelocity += Math.fround(Math.fround(invI2 * P2) * this.m_motorJacobian.angular2);
                        }
                    }
                    static tltemp_$LI$() { if (PrismaticJoint.tltemp == null)
                        PrismaticJoint.tltemp = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tltemp; }
                    ;
                    static tlp1_$LI$() { if (PrismaticJoint.tlp1 == null)
                        PrismaticJoint.tlp1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp1; }
                    ;
                    static tlp2_$LI$() { if (PrismaticJoint.tlp2 == null)
                        PrismaticJoint.tlp2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp2; }
                    ;
                    static tlr1z_$LI$() { if (PrismaticJoint.tlr1z == null)
                        PrismaticJoint.tlr1z = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr1z; }
                    ;
                    static tlr2z_$LI$() { if (PrismaticJoint.tlr2z == null)
                        PrismaticJoint.tlr2z = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlr2z; }
                    ;
                    static tlp1z_$LI$() { if (PrismaticJoint.tlp1z == null)
                        PrismaticJoint.tlp1z = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp1z; }
                    ;
                    static tlp2z_$LI$() { if (PrismaticJoint.tlp2z == null)
                        PrismaticJoint.tlp2z = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlp2z; }
                    ;
                    static tldz_$LI$() { if (PrismaticJoint.tldz == null)
                        PrismaticJoint.tldz = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tldz; }
                    ;
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let temp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tltemp_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp2_$LI$());
                        let r1z = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr1z_$LI$());
                        let r2z = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr2z_$LI$());
                        let p1z = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp1z_$LI$());
                        let p2z = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp2z_$LI$());
                        let dz = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tldz_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr2_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tld_$LI$());
                        let ax1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlax1_$LI$());
                        let ay1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlay1_$LI$());
                        let invMass1 = b1.m_invMass;
                        let invMass2 = b2.m_invMass;
                        let invI1 = b1.m_invI;
                        let invI2 = b2.m_invI;
                        temp.set$org_jbox2d_common_Vec2(this.m_localAnchor1);
                        temp.subLocal(b1.getMemberLocalCenter());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, temp, r1);
                        temp.set$org_jbox2d_common_Vec2(this.m_localAnchor2);
                        temp.subLocal(b2.getMemberLocalCenter());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, temp, r2);
                        p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                        p1.addLocal$org_jbox2d_common_Vec2(r1);
                        p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                        p2.addLocal$org_jbox2d_common_Vec2(r2);
                        d.set$org_jbox2d_common_Vec2(p2);
                        d.subLocal(p1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localYAxis1, ay1);
                        let linearC = org.jbox2d.common.Vec2.dot(ay1, d);
                        linearC = org.jbox2d.common.MathUtils.clamp$float$float$float(linearC, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                        let linearImpulse = Math.fround(-this.m_linearMass * linearC);
                        b1.m_sweep.c.x += Math.fround((Math.fround(invMass1 * linearImpulse)) * this.m_linearJacobian.linear1.x);
                        b1.m_sweep.c.y += Math.fround((Math.fround(invMass1 * linearImpulse)) * this.m_linearJacobian.linear1.y);
                        b1.m_sweep.a += Math.fround(Math.fround(invI1 * linearImpulse) * this.m_linearJacobian.angular1);
                        b2.m_sweep.c.x += Math.fround((Math.fround(invMass2 * linearImpulse)) * this.m_linearJacobian.linear2.x);
                        b2.m_sweep.c.y += Math.fround((Math.fround(invMass2 * linearImpulse)) * this.m_linearJacobian.linear2.y);
                        b2.m_sweep.a += Math.fround(Math.fround(invI2 * linearImpulse) * this.m_linearJacobian.angular2);
                        let positionError = org.jbox2d.common.MathUtils.abs(linearC);
                        let angularC = Math.fround(Math.fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_refAngle);
                        angularC = org.jbox2d.common.MathUtils.clamp$float$float$float(angularC, -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                        let angularImpulse = Math.fround(-this.m_angularMass * angularC);
                        b1.m_sweep.a -= Math.fround(b1.m_invI * angularImpulse);
                        b2.m_sweep.a += Math.fround(b2.m_invI * angularImpulse);
                        b1.synchronizeTransform();
                        b2.synchronizeTransform();
                        let angularError = org.jbox2d.common.MathUtils.abs(angularC);
                        if (this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                            temp.set$org_jbox2d_common_Vec2(this.m_localAnchor1);
                            temp.subLocal(b1.getMemberLocalCenter());
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, temp, r1z);
                            temp.set$org_jbox2d_common_Vec2(this.m_localAnchor2);
                            temp.subLocal(b2.getMemberLocalCenter());
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, temp, r2z);
                            p1z.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                            p1z.addLocal$org_jbox2d_common_Vec2(r1z);
                            p2z.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                            p2z.addLocal$org_jbox2d_common_Vec2(r2z);
                            dz.set$org_jbox2d_common_Vec2(p2z);
                            dz.subLocal(p1z);
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localXAxis1, ax1);
                            let translation = org.jbox2d.common.Vec2.dot(ax1, dz);
                            let limitImpulse = 0.0;
                            if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                                let limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(translation, -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, org.jbox2d.common.MathUtils.abs(angularC));
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                let limitC = Math.fround(translation - this.m_lowerTranslation);
                                positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, -limitC);
                                limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(limitC + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                let oldLimitImpulse = this.m_limitPositionImpulse;
                                this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.max$float$float(Math.fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                                limitImpulse = Math.fround(this.m_limitPositionImpulse - oldLimitImpulse);
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                let limitC = Math.fround(translation - this.m_upperTranslation);
                                positionError = org.jbox2d.common.MathUtils.max$float$float(positionError, limitC);
                                limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(limitC - org.jbox2d.common.Settings.linearSlop_$LI$()), 0.0, org.jbox2d.common.Settings.maxLinearCorrection_$LI$());
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                let oldLimitImpulse = this.m_limitPositionImpulse;
                                this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.min(Math.fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                                limitImpulse = Math.fround(this.m_limitPositionImpulse - oldLimitImpulse);
                            }
                            b1.m_sweep.c.x += Math.fround((Math.fround(invMass1 * limitImpulse)) * this.m_motorJacobian.linear1.x);
                            b1.m_sweep.c.y += Math.fround((Math.fround(invMass1 * limitImpulse)) * this.m_motorJacobian.linear1.y);
                            b1.m_sweep.a += Math.fround(Math.fround(invI1 * limitImpulse) * this.m_motorJacobian.angular1);
                            b2.m_sweep.c.x += Math.fround((Math.fround(invMass2 * limitImpulse)) * this.m_motorJacobian.linear2.x);
                            b2.m_sweep.c.y += Math.fround((Math.fround(invMass2 * limitImpulse)) * this.m_motorJacobian.linear2.y);
                            b2.m_sweep.a += Math.fround(Math.fround(invI2 * limitImpulse) * this.m_motorJacobian.angular2);
                            b1.synchronizeTransform();
                            b2.synchronizeTransform();
                        }
                        return positionError <= org.jbox2d.common.Settings.linearSlop_$LI$() && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_body1.getWorldLocation(this.m_localAnchor1);
                    }
                    getAnchor1ToOut(out) {
                        this.m_body1.getWorldLocationToOut(this.m_localAnchor1, out);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return this.m_body2.getWorldLocation(this.m_localAnchor2);
                    }
                    getAnchor2ToOut(out) {
                        this.m_body2.getWorldLocationToOut(this.m_localAnchor2, out);
                    }
                    static tlaxis_$LI$() { if (PrismaticJoint.tlaxis == null)
                        PrismaticJoint.tlaxis = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlaxis; }
                    ;
                    getJointTranslation() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let axis = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlaxis_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp2_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tld_$LI$());
                        b1.getWorldLocationToOut(this.m_localAnchor1, p1);
                        b2.getWorldLocationToOut(this.m_localAnchor2, p2);
                        d.set$org_jbox2d_common_Vec2(p2);
                        d.subLocal(p1);
                        b1.getWorldDirectionToOut(this.m_localXAxis1, axis);
                        let translation = org.jbox2d.common.Vec2.dot(d, axis);
                        return translation;
                    }
                    static tlw1xAxis_$LI$() { if (PrismaticJoint.tlw1xAxis == null)
                        PrismaticJoint.tlw1xAxis = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw1xAxis; }
                    ;
                    static tlv22_$LI$() { if (PrismaticJoint.tlv22 == null)
                        PrismaticJoint.tlv22 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlv22; }
                    ;
                    static tlw2xR2_$LI$() { if (PrismaticJoint.tlw2xR2 == null)
                        PrismaticJoint.tlw2xR2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw2xR2; }
                    ;
                    static tlw1xR1_$LI$() { if (PrismaticJoint.tlw1xR1 == null)
                        PrismaticJoint.tlw1xR1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlw1xR1; }
                    ;
                    getJointSpeed() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlr2_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlp2_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tld_$LI$());
                        let axis = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlaxis_$LI$());
                        let w1xAxis = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlw1xAxis_$LI$());
                        let v22 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlv22_$LI$());
                        let w2xR2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlw2xR2_$LI$());
                        let w1xR1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlw1xR1_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, this.m_localAnchor1.sub(b1.getMemberLocalCenter()), r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, this.m_localAnchor2.sub(b2.getMemberLocalCenter()), r2);
                        p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                        p1.addLocal$org_jbox2d_common_Vec2(r1);
                        p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                        p2.addLocal$org_jbox2d_common_Vec2(r2);
                        d.set$org_jbox2d_common_Vec2(p2);
                        d.subLocal(p1);
                        b1.getWorldDirectionToOut(this.m_localXAxis1, axis);
                        let v1 = b1.m_linearVelocity;
                        let v2 = b2.m_linearVelocity;
                        let w1 = b1.m_angularVelocity;
                        let w2 = b2.m_angularVelocity;
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w1, axis, w1xAxis);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w2, r2, w2xR2);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(w1, r1, w1xR1);
                        v22.set$org_jbox2d_common_Vec2(v2);
                        let speed = Math.fround(org.jbox2d.common.Vec2.dot(d, w1xAxis) + org.jbox2d.common.Vec2.dot(axis, v22.addLocal$org_jbox2d_common_Vec2(w2xR2).subLocal(v1).subLocal(w1xR1)));
                        return speed;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return this.m_torque;
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        let ax1 = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localXAxis1);
                        let ay1 = org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localYAxis1);
                        return new org.jbox2d.common.Vec2(Math.fround(Math.fround(this.m_limitForce * ax1.x) + Math.fround(this.m_force * ay1.x)), Math.fround(Math.fround(this.m_limitForce * ax1.y) + Math.fround(this.m_force * ay1.y)));
                    }
                    static tlreactionAx1_$LI$() { if (PrismaticJoint.tlreactionAx1 == null)
                        PrismaticJoint.tlreactionAx1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PrismaticJoint.tlreactionAx1; }
                    ;
                    getReactionForceToOut(out) {
                        let reactionAx1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PrismaticJoint.tlreactionAx1_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localXAxis1, reactionAx1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_body1.m_xf.R, this.m_localYAxis1, out);
                        out.x = Math.fround(Math.fround(this.m_limitForce * reactionAx1.x) + Math.fround(this.m_force * out.x));
                        out.y = Math.fround(Math.fround(this.m_limitForce * reactionAx1.y) + Math.fround(this.m_force * out.y));
                    }
                    /**
                     * Is the joint limit enabled?
                     * @return {boolean}
                     */
                    isLimitEnabled() {
                        return this.m_enableLimit;
                    }
                    /**
                     * Enable/disable the joint limit.
                     * @param {boolean} flag
                     */
                    enableLimit(flag) {
                        this.m_enableLimit = flag;
                    }
                    /**
                     * Get the lower joint limit, usually in meters.
                     * @return {number}
                     */
                    getLowerLimit() {
                        return this.m_lowerTranslation;
                    }
                    /**
                     * Get the upper joint limit, usually in meters.
                     * @return {number}
                     */
                    getUpperLimit() {
                        return this.m_upperTranslation;
                    }
                    /**
                     * Set the joint limits, usually in meters.
                     * @param {number} lower
                     * @param {number} upper
                     */
                    setLimits(lower, upper) {
                        this.m_lowerTranslation = lower;
                        this.m_upperTranslation = upper;
                    }
                    /**
                     * Is the joint motor enabled?
                     * @return {boolean}
                     */
                    isMotorEnabled() {
                        return this.m_enableMotor;
                    }
                    /**
                     * Enable/disable the joint motor.
                     * @param {boolean} flag
                     */
                    enableMotor(flag) {
                        this.m_enableMotor = flag;
                    }
                    /**
                     * Set the motor speed, usually in meters per second.
                     * @param {number} speed
                     */
                    setMotorSpeed(speed) {
                        this.m_motorSpeed = speed;
                    }
                    /**
                     * Get the motor speed, usually in meters per second.
                     * @return {number}
                     */
                    getMotorSpeed() {
                        return this.m_motorSpeed;
                    }
                    /**
                     * Set the maximum motor torque, usually in N.
                     * @param {number} force
                     */
                    setMaxMotorForce(force) {
                        this.m_maxMotorForce = force;
                    }
                    /**
                     * Get the current motor torque, usually in N.
                     * @return {number}
                     */
                    getMotorForce() {
                        return this.m_motorForce;
                    }
                }
                joints.PrismaticJoint = PrismaticJoint;
                PrismaticJoint["__class"] = "org.jbox2d.dynamics.joints.PrismaticJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class PulleyJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        if (this.m_ground === undefined)
                            this.m_ground = null;
                        if (this.m_groundAnchor1 === undefined)
                            this.m_groundAnchor1 = null;
                        if (this.m_groundAnchor2 === undefined)
                            this.m_groundAnchor2 = null;
                        if (this.m_localAnchor1 === undefined)
                            this.m_localAnchor1 = null;
                        if (this.m_localAnchor2 === undefined)
                            this.m_localAnchor2 = null;
                        if (this.m_u1 === undefined)
                            this.m_u1 = null;
                        if (this.m_u2 === undefined)
                            this.m_u2 = null;
                        if (this.m_constant === undefined)
                            this.m_constant = 0;
                        if (this.m_ratio === undefined)
                            this.m_ratio = 0;
                        if (this.m_maxLength1 === undefined)
                            this.m_maxLength1 = 0;
                        if (this.m_maxLength2 === undefined)
                            this.m_maxLength2 = 0;
                        if (this.m_pulleyMass === undefined)
                            this.m_pulleyMass = 0;
                        if (this.m_limitMass1 === undefined)
                            this.m_limitMass1 = 0;
                        if (this.m_limitMass2 === undefined)
                            this.m_limitMass2 = 0;
                        if (this.m_force === undefined)
                            this.m_force = 0;
                        if (this.m_limitForce1 === undefined)
                            this.m_limitForce1 = 0;
                        if (this.m_limitForce2 === undefined)
                            this.m_limitForce2 = 0;
                        if (this.m_positionImpulse === undefined)
                            this.m_positionImpulse = 0;
                        if (this.m_limitPositionImpulse1 === undefined)
                            this.m_limitPositionImpulse1 = 0;
                        if (this.m_limitPositionImpulse2 === undefined)
                            this.m_limitPositionImpulse2 = 0;
                        if (this.m_state === undefined)
                            this.m_state = null;
                        if (this.m_limitState1 === undefined)
                            this.m_limitState1 = null;
                        if (this.m_limitState2 === undefined)
                            this.m_limitState2 = null;
                        this.m_ground = this.m_body1.m_world.getGroundBody();
                        this.m_groundAnchor1 = def.groundAnchor1.sub(this.m_ground.m_xf.position);
                        this.m_groundAnchor2 = def.groundAnchor2.sub(this.m_ground.m_xf.position);
                        this.m_localAnchor1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor1);
                        this.m_localAnchor2 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor2);
                        this.m_u1 = new org.jbox2d.common.Vec2();
                        this.m_u2 = new org.jbox2d.common.Vec2();
                        this.m_ratio = def.ratio;
                        this.m_constant = Math.fround(def.length1 + Math.fround(this.m_ratio * def.length2));
                        this.m_maxLength1 = org.jbox2d.common.MathUtils.min(def.maxLength1, Math.fround(this.m_constant - Math.fround(this.m_ratio * PulleyJoint.MIN_PULLEY_LENGTH)));
                        this.m_maxLength2 = org.jbox2d.common.MathUtils.min(def.maxLength2, Math.fround((Math.fround(this.m_constant - PulleyJoint.MIN_PULLEY_LENGTH)) / this.m_ratio));
                        this.m_force = 0.0;
                        this.m_limitForce1 = 0.0;
                        this.m_limitForce2 = 0.0;
                    }
                    static tlr1_$LI$() { if (PulleyJoint.tlr1 == null)
                        PulleyJoint.tlr1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlr1; }
                    ;
                    static tlr2_$LI$() { if (PulleyJoint.tlr2 == null)
                        PulleyJoint.tlr2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlr2; }
                    ;
                    static tlp1_$LI$() { if (PulleyJoint.tlp1 == null)
                        PulleyJoint.tlp1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlp1; }
                    ;
                    static tlp2_$LI$() { if (PulleyJoint.tlp2 == null)
                        PulleyJoint.tlp2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlp2; }
                    ;
                    static tls1_$LI$() { if (PulleyJoint.tls1 == null)
                        PulleyJoint.tls1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tls1; }
                    ;
                    static tls2_$LI$() { if (PulleyJoint.tls2 == null)
                        PulleyJoint.tls2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tls2; }
                    ;
                    static tlP1_$LI$() { if (PulleyJoint.tlP1 == null)
                        PulleyJoint.tlP1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlP1; }
                    ;
                    static tlP2_$LI$() { if (PulleyJoint.tlP2 == null)
                        PulleyJoint.tlP2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlP2; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr2_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlp2_$LI$());
                        let s1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tls1_$LI$());
                        let s2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tls2_$LI$());
                        let P1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP1_$LI$());
                        let P2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP2_$LI$());
                        r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                        r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                        r1.subLocal(this.m_localAnchor1).negateLocal();
                        r2.subLocal(this.m_localAnchor2).negateLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                        p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                        p1.addLocal$org_jbox2d_common_Vec2(r1);
                        p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                        p2.addLocal$org_jbox2d_common_Vec2(r2);
                        s1.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
                        s1.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor1);
                        s2.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
                        s2.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor2);
                        this.m_u1.set$org_jbox2d_common_Vec2(p1);
                        this.m_u1.subLocal(s1);
                        this.m_u2.set$org_jbox2d_common_Vec2(p2);
                        this.m_u2.subLocal(s2);
                        let length1 = this.m_u1.length();
                        let length2 = this.m_u2.length();
                        if (length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                            this.m_u1.mulLocal(Math.fround(1.0 / length1));
                        }
                        else {
                            this.m_u1.setZero();
                        }
                        if (length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                            this.m_u2.mulLocal(Math.fround(1.0 / length2));
                        }
                        else {
                            this.m_u2.setZero();
                        }
                        let C = Math.fround(Math.fround(this.m_constant - length1) - Math.fround(this.m_ratio * length2));
                        if (C > 0.0) {
                            this.m_state = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                            this.m_force = 0.0;
                        }
                        else {
                            this.m_state = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                            this.m_positionImpulse = 0.0;
                        }
                        if (length1 < this.m_maxLength1) {
                            this.m_limitState1 = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                            this.m_limitForce1 = 0.0;
                        }
                        else {
                            this.m_limitState1 = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                            this.m_limitPositionImpulse1 = 0.0;
                        }
                        if (length2 < this.m_maxLength2) {
                            this.m_limitState2 = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                            this.m_limitForce2 = 0.0;
                        }
                        else {
                            this.m_limitState2 = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                            this.m_limitPositionImpulse2 = 0.0;
                        }
                        let cr1u1 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_u1);
                        let cr2u2 = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_u2);
                        this.m_limitMass1 = Math.fround(b1.m_invMass + Math.fround(Math.fround(b1.m_invI * cr1u1) * cr1u1));
                        this.m_limitMass2 = Math.fround(b2.m_invMass + Math.fround(Math.fround(b2.m_invI * cr2u2) * cr2u2));
                        this.m_pulleyMass = Math.fround(this.m_limitMass1 + Math.fround(Math.fround(this.m_ratio * this.m_ratio) * this.m_limitMass2));
                        this.m_limitMass1 = Math.fround(1.0 / this.m_limitMass1);
                        this.m_limitMass2 = Math.fround(1.0 / this.m_limitMass2);
                        this.m_pulleyMass = Math.fround(1.0 / this.m_pulleyMass);
                        if (step.warmStarting) {
                            P1.set$org_jbox2d_common_Vec2(this.m_u1);
                            P1.mulLocal(Math.fround(step.dt * (Math.fround(-this.m_force - this.m_limitForce1))));
                            P2.set$org_jbox2d_common_Vec2(this.m_u2);
                            P2.mulLocal(Math.fround(step.dt * (Math.fround(Math.fround(-this.m_ratio * this.m_force) - this.m_limitForce2))));
                            b1.m_angularVelocity += Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                            b2.m_angularVelocity += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                            b1.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P1.mulLocal(b1.m_invMass));
                            b2.m_linearVelocity.addLocal$org_jbox2d_common_Vec2(P2.mulLocal(b2.m_invMass));
                        }
                        else {
                            this.m_force = 0.0;
                            this.m_limitForce1 = 0.0;
                            this.m_limitForce2 = 0.0;
                        }
                    }
                    static tlv1_$LI$() { if (PulleyJoint.tlv1 == null)
                        PulleyJoint.tlv1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlv1; }
                    ;
                    static tlv2_$LI$() { if (PulleyJoint.tlv2 == null)
                        PulleyJoint.tlv2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PulleyJoint.tlv2; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlv1_$LI$());
                        let v2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlv2_$LI$());
                        let P1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP1_$LI$());
                        let P2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP2_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr2_$LI$());
                        r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                        r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                        r1.subLocal(this.m_localAnchor1).negateLocal();
                        r2.subLocal(this.m_localAnchor2).negateLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                        if (this.m_state === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
                            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
                            v1.add(b1.m_linearVelocity);
                            v2.add(b2.m_linearVelocity);
                            let Cdot = Math.fround(-org.jbox2d.common.Vec2.dot(this.m_u1, v1) - Math.fround(this.m_ratio * org.jbox2d.common.Vec2.dot(this.m_u2, v2)));
                            let force = Math.fround(Math.fround(-step.inv_dt * this.m_pulleyMass) * Cdot);
                            let oldForce = this.m_force;
                            this.m_force = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_force + force));
                            force = Math.fround(this.m_force - oldForce);
                            P1.set$org_jbox2d_common_Vec2(this.m_u1);
                            P1.mulLocal(Math.fround(-step.dt * force));
                            P2.set$org_jbox2d_common_Vec2(this.m_u2);
                            P2.mulLocal(Math.fround(Math.fround(-step.dt * this.m_ratio) * force));
                            b1.m_linearVelocity.x += Math.fround(b1.m_invMass * P1.x);
                            b1.m_linearVelocity.y += Math.fround(b1.m_invMass * P1.y);
                            b1.m_angularVelocity += Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                            b2.m_linearVelocity.x += Math.fround(b2.m_invMass * P2.x);
                            b2.m_linearVelocity.y += Math.fround(b2.m_invMass * P2.y);
                            b2.m_angularVelocity += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                        }
                        if (this.m_limitState1 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, v1);
                            v1.addLocal$org_jbox2d_common_Vec2(b1.m_linearVelocity);
                            let Cdot = -org.jbox2d.common.Vec2.dot(this.m_u1, v1);
                            let force = Math.fround(Math.fround(-step.inv_dt * this.m_limitMass1) * Cdot);
                            let oldForce = this.m_limitForce1;
                            this.m_limitForce1 = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_limitForce1 + force));
                            force = Math.fround(this.m_limitForce1 - oldForce);
                            P1.set$org_jbox2d_common_Vec2(this.m_u1);
                            P1.mulLocal(Math.fround(-step.dt * force));
                            b1.m_linearVelocity.x += Math.fround(b1.m_invMass * P1.x);
                            b1.m_linearVelocity.y += Math.fround(b1.m_invMass * P1.y);
                            b1.m_angularVelocity += Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                        }
                        if (this.m_limitState2 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, v2);
                            v2.addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
                            let Cdot = -org.jbox2d.common.Vec2.dot(this.m_u2, v2);
                            let force = Math.fround(Math.fround(-step.inv_dt * this.m_limitMass2) * Cdot);
                            let oldForce = this.m_limitForce2;
                            this.m_limitForce2 = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_limitForce2 + force));
                            force = Math.fround(this.m_limitForce2 - oldForce);
                            P2.set$org_jbox2d_common_Vec2(this.m_u2);
                            P2.mulLocal(Math.fround(-step.dt * force));
                            b2.m_linearVelocity.x += Math.fround(b2.m_invMass * P2.x);
                            b2.m_linearVelocity.y += Math.fround(b2.m_invMass * P2.y);
                            b2.m_angularVelocity += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlr2_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlp2_$LI$());
                        let s1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tls1_$LI$());
                        let s2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tls2_$LI$());
                        let P1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP1_$LI$());
                        let P2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PulleyJoint.tlP2_$LI$());
                        s1.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
                        s1.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor1);
                        s2.set$org_jbox2d_common_Vec2(this.m_ground.m_xf.position);
                        s2.addLocal$org_jbox2d_common_Vec2(this.m_groundAnchor2);
                        let linearError = 0.0;
                        if (this.m_state === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                            r1.subLocal(this.m_localAnchor1).negateLocal();
                            r2.subLocal(this.m_localAnchor2).negateLocal();
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                            p1.addLocal$org_jbox2d_common_Vec2(r1);
                            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                            p2.addLocal$org_jbox2d_common_Vec2(r2);
                            this.m_u1.set$float$float(Math.fround(p1.x - s1.x), Math.fround(p1.y - s1.y));
                            this.m_u2.set$float$float(Math.fround(p2.x - s2.x), Math.fround(p2.y - s2.y));
                            let length1 = this.m_u1.length();
                            let length2 = this.m_u2.length();
                            if (length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                this.m_u1.mulLocal(Math.fround(1.0 / length1));
                            }
                            else {
                                this.m_u1.setZero();
                            }
                            if (length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                this.m_u2.mulLocal(Math.fround(1.0 / length2));
                            }
                            else {
                                this.m_u2.setZero();
                            }
                            let C = Math.fround(Math.fround(this.m_constant - length1) - Math.fround(this.m_ratio * length2));
                            linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                            C = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                            let impulse = Math.fround(-this.m_pulleyMass * C);
                            let oldImpulse = this.m_positionImpulse;
                            this.m_positionImpulse = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_positionImpulse + impulse));
                            impulse = Math.fround(this.m_positionImpulse - oldImpulse);
                            P1.set$org_jbox2d_common_Vec2(this.m_u1);
                            P1.mulLocal(-impulse);
                            P2.set$org_jbox2d_common_Vec2(this.m_u2);
                            P2.mulLocal(Math.fround(-this.m_ratio * impulse));
                            b1.m_sweep.c.x += Math.fround(b1.m_invMass * P1.x);
                            b1.m_sweep.c.y += Math.fround(b1.m_invMass * P1.y);
                            b1.m_sweep.a += Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                            b2.m_sweep.c.x += Math.fround(b2.m_invMass * P2.x);
                            b2.m_sweep.c.y += Math.fround(b2.m_invMass * P2.y);
                            b2.m_sweep.a += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                            b1.synchronizeTransform();
                            b2.synchronizeTransform();
                        }
                        if (this.m_limitState1 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                            r1.subLocal(this.m_localAnchor1).negateLocal();
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                            p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                            p1.addLocal$org_jbox2d_common_Vec2(r1);
                            this.m_u1.set$float$float(Math.fround(p1.x - s1.x), Math.fround(p1.y - s1.y));
                            let length1 = this.m_u1.length();
                            if (length1 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                this.m_u1.mulLocal(Math.fround(1.0 / length1));
                            }
                            else {
                                this.m_u1.setZero();
                            }
                            let C = Math.fround(this.m_maxLength1 - length1);
                            linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                            C = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                            let impulse = Math.fround(-this.m_limitMass1 * C);
                            let oldLimitPositionImpulse = this.m_limitPositionImpulse1;
                            this.m_limitPositionImpulse1 = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_limitPositionImpulse1 + impulse));
                            impulse = Math.fround(this.m_limitPositionImpulse1 - oldLimitPositionImpulse);
                            P1.set$org_jbox2d_common_Vec2(this.m_u1);
                            P1.mulLocal(-impulse);
                            b1.m_sweep.c.x += Math.fround(b1.m_invMass * P1.x);
                            b1.m_sweep.c.y += Math.fround(b1.m_invMass * P1.y);
                            b1.m_sweep.a += Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P1));
                            b1.synchronizeTransform();
                        }
                        if (this.m_limitState2 === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                            r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                            r2.subLocal(this.m_localAnchor2).negateLocal();
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                            p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                            p2.addLocal$org_jbox2d_common_Vec2(r2);
                            this.m_u2.set$float$float(Math.fround(p2.x - s2.x), Math.fround(p2.y - s2.y));
                            let length2 = this.m_u2.length();
                            if (length2 > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                this.m_u2.mulLocal(Math.fround(1.0 / length2));
                            }
                            else {
                                this.m_u2.setZero();
                            }
                            let C = Math.fround(this.m_maxLength2 - length2);
                            linearError = org.jbox2d.common.MathUtils.max$float$float(linearError, -C);
                            C = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(C + org.jbox2d.common.Settings.linearSlop_$LI$()), -org.jbox2d.common.Settings.maxLinearCorrection_$LI$(), 0.0);
                            let impulse = Math.fround(-this.m_limitMass2 * C);
                            let oldLimitPositionImpulse = this.m_limitPositionImpulse2;
                            this.m_limitPositionImpulse2 = org.jbox2d.common.MathUtils.max$float$float(0.0, Math.fround(this.m_limitPositionImpulse2 + impulse));
                            impulse = Math.fround(this.m_limitPositionImpulse2 - oldLimitPositionImpulse);
                            P2.set$org_jbox2d_common_Vec2(this.m_u2);
                            P2.mulLocal(-impulse);
                            b2.m_sweep.c.x += Math.fround(b2.m_invMass * P2.x);
                            b2.m_sweep.c.y += Math.fround(b2.m_invMass * P2.y);
                            b2.m_sweep.a += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P2));
                            b2.synchronizeTransform();
                        }
                        return linearError < org.jbox2d.common.Settings.linearSlop_$LI$();
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_body1.getWorldLocation(this.m_localAnchor1);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return this.m_body2.getWorldLocation(this.m_localAnchor2);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        let F = this.m_u2.mul(this.m_force);
                        return F;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return 0.0;
                    }
                    getGroundAnchor1() {
                        return this.m_ground.m_xf.position.add(this.m_groundAnchor1);
                    }
                    getGroundAnchor2() {
                        return this.m_ground.m_xf.position.add(this.m_groundAnchor2);
                    }
                    getLength1() {
                        let p = this.m_body1.getWorldLocation(this.m_localAnchor1);
                        let s = this.m_ground.m_xf.position.add(this.m_groundAnchor1);
                        let d = p.subLocal(s);
                        return d.length();
                    }
                    getLength2() {
                        let p = this.m_body2.getWorldLocation(this.m_localAnchor2);
                        let s = this.m_ground.m_xf.position.add(this.m_groundAnchor2);
                        let d = p.subLocal(s);
                        return d.length();
                    }
                    getRatio() {
                        return this.m_ratio;
                    }
                }
                PulleyJoint.MIN_PULLEY_LENGTH = 2.0;
                joints.PulleyJoint = PulleyJoint;
                PulleyJoint["__class"] = "org.jbox2d.dynamics.joints.PulleyJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class RevoluteJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        this.m_lastWarmStartingPivotForce = new org.jbox2d.common.Vec2(0.0, 0.0);
                        if (this.m_localAnchor1 === undefined)
                            this.m_localAnchor1 = null;
                        if (this.m_localAnchor2 === undefined)
                            this.m_localAnchor2 = null;
                        if (this.m_pivotForce === undefined)
                            this.m_pivotForce = null;
                        if (this.m_motorForce === undefined)
                            this.m_motorForce = 0;
                        if (this.m_limitForce === undefined)
                            this.m_limitForce = 0;
                        if (this.m_limitPositionImpulse === undefined)
                            this.m_limitPositionImpulse = 0;
                        if (this.m_pivotMass === undefined)
                            this.m_pivotMass = null;
                        if (this.m_motorMass === undefined)
                            this.m_motorMass = 0;
                        if (this.m_enableMotor === undefined)
                            this.m_enableMotor = false;
                        if (this.m_maxMotorTorque === undefined)
                            this.m_maxMotorTorque = 0;
                        if (this.m_motorSpeed === undefined)
                            this.m_motorSpeed = 0;
                        if (this.m_enableLimit === undefined)
                            this.m_enableLimit = false;
                        if (this.m_referenceAngle === undefined)
                            this.m_referenceAngle = 0;
                        if (this.m_lowerAngle === undefined)
                            this.m_lowerAngle = 0;
                        if (this.m_upperAngle === undefined)
                            this.m_upperAngle = 0;
                        if (this.m_limitState === undefined)
                            this.m_limitState = null;
                        this.m_localAnchor1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor1);
                        this.m_localAnchor2 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(def.localAnchor2);
                        this.m_referenceAngle = def.referenceAngle;
                        this.m_pivotForce = new org.jbox2d.common.Vec2(0.0, 0.0);
                        this.m_motorForce = 0.0;
                        this.m_limitForce = 0.0;
                        this.m_limitPositionImpulse = 0.0;
                        this.m_pivotMass = new org.jbox2d.common.Mat22();
                        this.m_lowerAngle = def.lowerAngle;
                        this.m_upperAngle = def.upperAngle;
                        this.m_maxMotorTorque = def.maxMotorTorque;
                        this.m_motorSpeed = def.motorSpeed;
                        this.m_enableLimit = def.enableLimit;
                        this.m_enableMotor = def.enableMotor;
                    }
                    static tlr1_$LI$() { if (RevoluteJoint.tlr1 == null)
                        RevoluteJoint.tlr1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlr1; }
                    ;
                    static tlr2_$LI$() { if (RevoluteJoint.tlr2 == null)
                        RevoluteJoint.tlr2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlr2; }
                    ;
                    static tlK1_$LI$() { if (RevoluteJoint.tlK1 == null)
                        RevoluteJoint.tlK1 = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK1; }
                    ;
                    static tlK2_$LI$() { if (RevoluteJoint.tlK2 == null)
                        RevoluteJoint.tlK2 = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK2; }
                    ;
                    static tlK3_$LI$() { if (RevoluteJoint.tlK3 == null)
                        RevoluteJoint.tlK3 = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return RevoluteJoint.tlK3; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr2_$LI$());
                        let K1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK1_$LI$());
                        let K2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK2_$LI$());
                        let K3 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK3_$LI$());
                        r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                        r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                        r1.subLocal(this.m_localAnchor1).negateLocal();
                        r2.subLocal(this.m_localAnchor2).negateLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                        let invMass1 = b1.m_invMass;
                        let invMass2 = b2.m_invMass;
                        let invI1 = b1.m_invI;
                        let invI2 = b2.m_invI;
                        K1.col1.x = Math.fround(invMass1 + invMass2);
                        K1.col2.x = 0.0;
                        K1.col1.y = 0.0;
                        K1.col2.y = Math.fround(invMass1 + invMass2);
                        K2.col1.x = Math.fround(Math.fround(invI1 * r1.y) * r1.y);
                        K2.col2.x = Math.fround(Math.fround(-invI1 * r1.x) * r1.y);
                        K2.col1.y = Math.fround(Math.fround(-invI1 * r1.x) * r1.y);
                        K2.col2.y = Math.fround(Math.fround(invI1 * r1.x) * r1.x);
                        K3.col1.x = Math.fround(Math.fround(invI2 * r2.y) * r2.y);
                        K3.col2.x = Math.fround(Math.fround(-invI2 * r2.x) * r2.y);
                        K3.col1.y = Math.fround(Math.fround(-invI2 * r2.x) * r2.y);
                        K3.col2.y = Math.fround(Math.fround(invI2 * r2.x) * r2.x);
                        K1.addLocal(K2).addLocal(K3);
                        K1.invertToOut(this.m_pivotMass);
                        this.m_motorMass = Math.fround(1.0 / (Math.fround(invI1 + invI2)));
                        if (this.m_enableMotor === false) {
                            this.m_motorForce = 0.0;
                        }
                        if (this.m_enableLimit) {
                            let jointAngle = Math.fround(Math.fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
                            if (org.jbox2d.common.MathUtils.abs(Math.fround(this.m_upperAngle - this.m_lowerAngle)) < Math.fround(2.0 * org.jbox2d.common.Settings.angularSlop_$LI$())) {
                                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS;
                            }
                            else if (jointAngle <= this.m_lowerAngle) {
                                if (this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                    this.m_limitForce = 0.0;
                                }
                                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT;
                            }
                            else if (jointAngle >= this.m_upperAngle) {
                                if (this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                    this.m_limitForce = 0.0;
                                }
                                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT;
                            }
                            else {
                                this.m_limitState = org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT;
                                this.m_limitForce = 0.0;
                            }
                        }
                        else {
                            this.m_limitForce = 0.0;
                        }
                        if (step.warmStarting) {
                            b1.m_linearVelocity.x -= Math.fround(Math.fround(step.dt * invMass1) * this.m_pivotForce.x);
                            b1.m_linearVelocity.y -= Math.fround(Math.fround(step.dt * invMass1) * this.m_pivotForce.y);
                            b1.m_angularVelocity -= Math.fround(Math.fround(step.dt * invI1) * (Math.fround(Math.fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, this.m_pivotForce) + this.m_motorForce) + this.m_limitForce)));
                            b2.m_linearVelocity.x += Math.fround(Math.fround(step.dt * invMass2) * this.m_pivotForce.x);
                            b2.m_linearVelocity.y += Math.fround(Math.fround(step.dt * invMass2) * this.m_pivotForce.y);
                            b2.m_angularVelocity += Math.fround(Math.fround(step.dt * invI2) * (Math.fround(Math.fround(org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, this.m_pivotForce) + this.m_motorForce) + this.m_limitForce)));
                        }
                        else {
                            this.m_pivotForce.setZero();
                            this.m_motorForce = 0.0;
                            this.m_limitForce = 0.0;
                        }
                        this.m_limitPositionImpulse = 0.0;
                    }
                    static tltemp_$LI$() { if (RevoluteJoint.tltemp == null)
                        RevoluteJoint.tltemp = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tltemp; }
                    ;
                    static tlpivotCdot_$LI$() { if (RevoluteJoint.tlpivotCdot == null)
                        RevoluteJoint.tlpivotCdot = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlpivotCdot; }
                    ;
                    static tlpivotForce_$LI$() { if (RevoluteJoint.tlpivotForce == null)
                        RevoluteJoint.tlpivotForce = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlpivotForce; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let temp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tltemp_$LI$());
                        let pivotCdot = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlpivotCdot_$LI$());
                        let pivotForce = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlpivotForce_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr2_$LI$());
                        r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                        r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                        r1.subLocal(this.m_localAnchor1).negateLocal();
                        r2.subLocal(this.m_localAnchor2).negateLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_angularVelocity, r1, temp);
                        org.jbox2d.common.Vec2.crossToOut$float$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_angularVelocity, r2, pivotCdot);
                        pivotCdot.subLocal(b1.m_linearVelocity).subLocal(temp).addLocal$org_jbox2d_common_Vec2(b2.m_linearVelocity);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_pivotMass, pivotCdot, pivotForce);
                        pivotForce.mulLocal(-step.inv_dt);
                        if (step.warmStarting) {
                            this.m_pivotForce.addLocal$org_jbox2d_common_Vec2(pivotForce);
                            this.m_lastWarmStartingPivotForce.set$org_jbox2d_common_Vec2(this.m_pivotForce);
                        }
                        else {
                            this.m_pivotForce.set$org_jbox2d_common_Vec2(this.m_lastWarmStartingPivotForce);
                        }
                        let P = pivotForce.mulLocal(step.dt);
                        b1.m_linearVelocity.x -= Math.fround(b1.m_invMass * P.x);
                        b1.m_linearVelocity.y -= Math.fround(b1.m_invMass * P.y);
                        b1.m_angularVelocity -= Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, P));
                        b2.m_linearVelocity.x += Math.fround(b2.m_invMass * P.x);
                        b2.m_linearVelocity.y += Math.fround(b2.m_invMass * P.y);
                        b2.m_angularVelocity += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, P));
                        if (this.m_enableMotor && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                            let motorCdot = Math.fround(Math.fround(b2.m_angularVelocity - b1.m_angularVelocity) - this.m_motorSpeed);
                            let motorForce = Math.fround(Math.fround(-step.inv_dt * this.m_motorMass) * motorCdot);
                            let oldMotorForce = this.m_motorForce;
                            this.m_motorForce = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(this.m_motorForce + motorForce), -this.m_maxMotorTorque, this.m_maxMotorTorque);
                            motorForce = Math.fround(this.m_motorForce - oldMotorForce);
                            if (!step.warmStarting) {
                                this.m_motorForce = oldMotorForce;
                            }
                            let P2 = Math.fround(step.dt * motorForce);
                            b1.m_angularVelocity -= Math.fround(b1.m_invI * P2);
                            b2.m_angularVelocity += Math.fround(b2.m_invI * P2);
                        }
                        if (this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                            let limitCdot = Math.fround(b2.m_angularVelocity - b1.m_angularVelocity);
                            let limitForce = Math.fround(Math.fround(-step.inv_dt * this.m_motorMass) * limitCdot);
                            if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                                this.m_limitForce += limitForce;
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                let oldLimitForce = this.m_limitForce;
                                this.m_limitForce = org.jbox2d.common.MathUtils.max$float$float(Math.fround(this.m_limitForce + limitForce), 0.0);
                                limitForce = Math.fround(this.m_limitForce - oldLimitForce);
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                let oldLimitForce = this.m_limitForce;
                                this.m_limitForce = org.jbox2d.common.MathUtils.min(Math.fround(this.m_limitForce + limitForce), 0.0);
                                limitForce = Math.fround(this.m_limitForce - oldLimitForce);
                            }
                            let P2 = Math.fround(step.dt * limitForce);
                            b1.m_angularVelocity -= Math.fround(b1.m_invI * P2);
                            b2.m_angularVelocity += Math.fround(b2.m_invI * P2);
                        }
                    }
                    static tlp1_$LI$() { if (RevoluteJoint.tlp1 == null)
                        RevoluteJoint.tlp1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlp1; }
                    ;
                    static tlp2_$LI$() { if (RevoluteJoint.tlp2 == null)
                        RevoluteJoint.tlp2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlp2; }
                    ;
                    static tlptpC_$LI$() { if (RevoluteJoint.tlptpC == null)
                        RevoluteJoint.tlptpC = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlptpC; }
                    ;
                    static tlimpulse_$LI$() { if (RevoluteJoint.tlimpulse == null)
                        RevoluteJoint.tlimpulse = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return RevoluteJoint.tlimpulse; }
                    ;
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlp1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlp2_$LI$());
                        let ptpC = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlptpC_$LI$());
                        let impulse = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlimpulse_$LI$());
                        let r1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr1_$LI$());
                        let r2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlr2_$LI$());
                        let K1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK1_$LI$());
                        let K2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK2_$LI$());
                        let K3 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(RevoluteJoint.tlK3_$LI$());
                        let positionError = 0.0;
                        r1.set$org_jbox2d_common_Vec2(b1.getMemberLocalCenter());
                        r2.set$org_jbox2d_common_Vec2(b2.getMemberLocalCenter());
                        r1.subLocal(this.m_localAnchor1).negateLocal();
                        r2.subLocal(this.m_localAnchor2).negateLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b1.m_xf.R, r1, r1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(b2.m_xf.R, r2, r2);
                        p1.set$org_jbox2d_common_Vec2(b1.m_sweep.c);
                        p1.addLocal$org_jbox2d_common_Vec2(r1);
                        p2.set$org_jbox2d_common_Vec2(b2.m_sweep.c);
                        p2.addLocal$org_jbox2d_common_Vec2(r2);
                        ptpC.set$org_jbox2d_common_Vec2(p2);
                        ptpC.subLocal(p1);
                        positionError = ptpC.length();
                        let invMass1 = b1.m_invMass;
                        let invMass2 = b2.m_invMass;
                        let invI1 = b1.m_invI;
                        let invI2 = b2.m_invI;
                        K1.col1.x = Math.fround(invMass1 + invMass2);
                        K1.col2.x = 0.0;
                        K1.col1.y = 0.0;
                        K1.col2.y = Math.fround(invMass1 + invMass2);
                        K2.col1.x = Math.fround(Math.fround(invI1 * r1.y) * r1.y);
                        K2.col2.x = Math.fround(Math.fround(-invI1 * r1.x) * r1.y);
                        K2.col1.y = Math.fround(Math.fround(-invI1 * r1.x) * r1.y);
                        K2.col2.y = Math.fround(Math.fround(invI1 * r1.x) * r1.x);
                        K3.col1.x = Math.fround(Math.fround(invI2 * r2.y) * r2.y);
                        K3.col2.x = Math.fround(Math.fround(-invI2 * r2.x) * r2.y);
                        K3.col1.y = Math.fround(Math.fround(-invI2 * r2.x) * r2.y);
                        K3.col2.y = Math.fround(Math.fround(invI2 * r2.x) * r2.x);
                        let K = K1.addLocal(K2).addLocal(K3);
                        K.solveToOut(ptpC.negateLocal(), impulse);
                        b1.m_sweep.c.x -= Math.fround(b1.m_invMass * impulse.x);
                        b1.m_sweep.c.y -= Math.fround(b1.m_invMass * impulse.y);
                        b1.m_sweep.a -= Math.fround(b1.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r1, impulse));
                        b2.m_sweep.c.x += Math.fround(b2.m_invMass * impulse.x);
                        b2.m_sweep.c.y += Math.fround(b2.m_invMass * impulse.y);
                        b2.m_sweep.a += Math.fround(b2.m_invI * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(r2, impulse));
                        b1.synchronizeTransform();
                        b2.synchronizeTransform();
                        let angularError = 0.0;
                        if (this.m_enableLimit && this.m_limitState !== org.jbox2d.dynamics.joints.LimitState.INACTIVE_LIMIT) {
                            let angle = Math.fround(Math.fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
                            let limitImpulse = 0.0;
                            if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.EQUAL_LIMITS) {
                                let limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(angle, -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                angularError = org.jbox2d.common.MathUtils.abs(limitC);
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_LOWER_LIMIT) {
                                let limitC = Math.fround(angle - this.m_lowerAngle);
                                angularError = org.jbox2d.common.MathUtils.max$float$float(0.0, -limitC);
                                limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(limitC + org.jbox2d.common.Settings.angularSlop_$LI$()), -org.jbox2d.common.Settings.maxAngularCorrection_$LI$(), 0.0);
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                let oldLimitImpulse = this.m_limitPositionImpulse;
                                this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.max$float$float(Math.fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                                limitImpulse = Math.fround(this.m_limitPositionImpulse - oldLimitImpulse);
                            }
                            else if (this.m_limitState === org.jbox2d.dynamics.joints.LimitState.AT_UPPER_LIMIT) {
                                let limitC = Math.fround(angle - this.m_upperAngle);
                                angularError = org.jbox2d.common.MathUtils.max$float$float(0.0, limitC);
                                limitC = org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(limitC - org.jbox2d.common.Settings.angularSlop_$LI$()), 0.0, org.jbox2d.common.Settings.maxAngularCorrection_$LI$());
                                limitImpulse = Math.fround(-this.m_motorMass * limitC);
                                let oldLimitImpulse = this.m_limitPositionImpulse;
                                this.m_limitPositionImpulse = org.jbox2d.common.MathUtils.min(Math.fround(this.m_limitPositionImpulse + limitImpulse), 0.0);
                                limitImpulse = Math.fround(this.m_limitPositionImpulse - oldLimitImpulse);
                            }
                            b1.m_sweep.a -= Math.fround(b1.m_invI * limitImpulse);
                            b2.m_sweep.a += Math.fround(b2.m_invI * limitImpulse);
                            b1.synchronizeTransform();
                            b2.synchronizeTransform();
                        }
                        return positionError <= org.jbox2d.common.Settings.linearSlop_$LI$() && angularError <= org.jbox2d.common.Settings.angularSlop_$LI$();
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return this.m_body1.getWorldLocation(this.m_localAnchor1);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return this.m_body2.getWorldLocation(this.m_localAnchor2);
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        return this.m_pivotForce;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return this.m_limitForce;
                    }
                    getJointAngle() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        return Math.fround(Math.fround(b2.m_sweep.a - b1.m_sweep.a) - this.m_referenceAngle);
                    }
                    getJointSpeed() {
                        let b1 = this.m_body1;
                        let b2 = this.m_body2;
                        return Math.fround(b2.m_angularVelocity - b1.m_angularVelocity);
                    }
                    isMotorEnabled() {
                        return this.m_enableMotor;
                    }
                    enableMotor(flag) {
                        this.m_enableMotor = flag;
                    }
                    getMotorTorque() {
                        return this.m_motorForce;
                    }
                    setMotorSpeed(speed) {
                        this.m_motorSpeed = speed;
                    }
                    setMaxMotorTorque(torque) {
                        this.m_maxMotorTorque = torque;
                    }
                    isLimitEnabled() {
                        return this.m_enableLimit;
                    }
                    enableLimit(flag) {
                        this.m_enableLimit = flag;
                    }
                    getLowerLimit() {
                        return this.m_lowerAngle;
                    }
                    getUpperLimit() {
                        return this.m_upperAngle;
                    }
                    setLimits(lower, upper) {
                        this.m_lowerAngle = lower;
                        this.m_upperAngle = upper;
                    }
                }
                joints.RevoluteJoint = RevoluteJoint;
                RevoluteJoint["__class"] = "org.jbox2d.dynamics.joints.RevoluteJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * Handles conservative advancement to compute time of impact between shapes.
             * @class
             */
            class TOI {
                static tlxf1_$LI$() { if (TOI.tlxf1 == null)
                    TOI.tlxf1 = (() => { let __o = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return TOI.tlxf1; }
                ;
                static tlxf2_$LI$() { if (TOI.tlxf2 == null)
                    TOI.tlxf2 = (() => { let __o = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return TOI.tlxf2; }
                ;
                static tlP1_$LI$() { if (TOI.tlP1 == null)
                    TOI.tlP1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return TOI.tlP1; }
                ;
                static tlP2_$LI$() { if (TOI.tlP2 == null)
                    TOI.tlP2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return TOI.tlP2; }
                ;
                /**
                 * Compute the time when two shapes begin to touch or touch at a closer distance.
                 * <BR><BR><em>Warning</em>: the sweeps must have the same time interval.
                 * @return {number} the fraction between [0,1] in which the shapes first touch.
                 * fraction=0 means the shapes begin touching/overlapped, and fraction=1 means the shapes don't touch.
                 * @param {org.jbox2d.collision.shapes.Shape} shape1
                 * @param {org.jbox2d.common.Sweep} sweep1
                 * @param {org.jbox2d.collision.shapes.Shape} shape2
                 * @param {org.jbox2d.common.Sweep} sweep2
                 */
                static timeOfImpact(shape1, sweep1, shape2, sweep2) {
                    let xf1 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(TOI.tlxf1_$LI$());
                    let xf2 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(TOI.tlxf2_$LI$());
                    let p1 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(TOI.tlP1_$LI$());
                    let p2 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(TOI.tlP2_$LI$());
                    let r1 = shape1.getSweepRadius();
                    let r2 = shape2.getSweepRadius();
                    let t0 = sweep1.t0;
                    let vx = Math.fround((Math.fround(sweep1.c.x - sweep1.c0.x)) - (Math.fround(sweep2.c.x - sweep2.c0.x)));
                    let vy = Math.fround((Math.fround(sweep1.c.y - sweep1.c0.y)) - (Math.fround(sweep2.c.y - sweep2.c0.y)));
                    let omega1 = Math.fround(sweep1.a - sweep1.a0);
                    let omega2 = Math.fround(sweep2.a - sweep2.a0);
                    let alpha = 0.0;
                    let k_maxIterations = 20;
                    let iter = 0;
                    let distance = 0.0;
                    let targetDistance = 0.0;
                    while ((true)) {
                        {
                            let t = Math.fround(Math.fround((Math.fround(1.0 - alpha)) * t0) + alpha);
                            sweep1.getXForm(xf1, t);
                            sweep2.getXForm(xf2, t);
                            distance = org.jbox2d.pooling.SingletonPool.getDistance().distance(p1, p2, shape1, xf1, shape2, xf2);
                            if (iter === 0) {
                                if (distance > Math.fround(2.0 * org.jbox2d.common.Settings.toiSlop_$LI$())) {
                                    targetDistance = Math.fround(1.5 * org.jbox2d.common.Settings.toiSlop_$LI$());
                                }
                                else {
                                    targetDistance = org.jbox2d.common.MathUtils.max$float$float(Math.fround(0.05 * org.jbox2d.common.Settings.toiSlop_$LI$()), Math.fround(distance - Math.fround(0.5 * org.jbox2d.common.Settings.toiSlop_$LI$())));
                                }
                            }
                            if (Math.fround(distance - targetDistance) < Math.fround(0.05 * org.jbox2d.common.Settings.toiSlop_$LI$()) || iter === k_maxIterations) {
                                break;
                            }
                            let normalx = Math.fround(p2.x - p1.x);
                            let normaly = Math.fround(p2.y - p1.y);
                            let lenSqrd = Math.fround(Math.fround(normalx * normalx) + Math.fround(normaly * normaly));
                            if (lenSqrd >= Math.fround(org.jbox2d.common.Settings.EPSILON * org.jbox2d.common.Settings.EPSILON)) {
                                let length = org.jbox2d.common.MathUtils.sqrt(lenSqrd);
                                let invLength = Math.fround(1.0 / length);
                                normalx *= invLength;
                                normaly *= invLength;
                            }
                            let approachVelocityBound = Math.fround(Math.fround((Math.fround(Math.fround(normalx * vx) + Math.fround(normaly * vy))) + Math.fround(org.jbox2d.common.MathUtils.abs(omega1) * r1)) + Math.fround(org.jbox2d.common.MathUtils.abs(omega2) * r2));
                            if (org.jbox2d.common.MathUtils.abs(approachVelocityBound) < org.jbox2d.common.Settings.EPSILON) {
                                alpha = 1.0;
                                break;
                            }
                            let dAlpha = Math.fround((Math.fround(distance - targetDistance)) / approachVelocityBound);
                            let newAlpha = Math.fround(alpha + dAlpha);
                            if (newAlpha < 0.0 || 1.0 < newAlpha) {
                                alpha = 1.0;
                                break;
                            }
                            if (newAlpha < Math.fround((Math.fround(1.0 + Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON))) * alpha)) {
                                break;
                            }
                            alpha = newAlpha;
                            ++iter;
                        }
                    }
                    ;
                    return alpha;
                }
            }
            collision.TOI = TOI;
            TOI["__class"] = "org.jbox2d.collision.TOI";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Should not be called by user, as it will not
             * be properly added to the world.  Instead,
             * create a BodyDef object and pass it
             * to World.createDynamicBody or World.createStaticBody.
             *
             * @param {org.jbox2d.dynamics.BodyDef} bd Body definition
             * @param {org.jbox2d.dynamics.World} world World to create body in
             * @class
             */
            class Body {
                constructor(bd, world) {
                    if (((bd != null && bd instanceof org.jbox2d.dynamics.BodyDef) || bd === null) && ((world != null && world instanceof org.jbox2d.dynamics.World) || world === null)) {
                        let __args = arguments;
                        if (this.m_uniqueID === undefined)
                            this.m_uniqueID = 0;
                        if (this.m_flags === undefined)
                            this.m_flags = 0;
                        if (this.m_type === undefined)
                            this.m_type = 0;
                        if (this.m_controllerList === undefined)
                            this.m_controllerList = null;
                        if (this.m_xf === undefined)
                            this.m_xf = null;
                        if (this.m_sweep === undefined)
                            this.m_sweep = null;
                        if (this.m_linearVelocity === undefined)
                            this.m_linearVelocity = null;
                        if (this.m_angularVelocity === undefined)
                            this.m_angularVelocity = 0;
                        if (this.m_force === undefined)
                            this.m_force = null;
                        if (this.m_torque === undefined)
                            this.m_torque = 0;
                        if (this.m_world === undefined)
                            this.m_world = null;
                        if (this.m_prev === undefined)
                            this.m_prev = null;
                        if (this.m_next === undefined)
                            this.m_next = null;
                        if (this.m_shapeList === undefined)
                            this.m_shapeList = null;
                        if (this.m_shapeCount === undefined)
                            this.m_shapeCount = 0;
                        if (this.m_jointList === undefined)
                            this.m_jointList = null;
                        if (this.m_contactList === undefined)
                            this.m_contactList = null;
                        if (this.m_mass === undefined)
                            this.m_mass = 0;
                        if (this.m_invMass === undefined)
                            this.m_invMass = 0;
                        if (this.m_I === undefined)
                            this.m_I = 0;
                        if (this.m_invI === undefined)
                            this.m_invI = 0;
                        if (this.m_linearDamping === undefined)
                            this.m_linearDamping = 0;
                        if (this.m_angularDamping === undefined)
                            this.m_angularDamping = 0;
                        if (this.m_sleepTime === undefined)
                            this.m_sleepTime = 0;
                        if (this.m_userData === undefined)
                            this.m_userData = null;
                        if (this.m_uniqueID === undefined)
                            this.m_uniqueID = 0;
                        if (this.m_flags === undefined)
                            this.m_flags = 0;
                        if (this.m_type === undefined)
                            this.m_type = 0;
                        if (this.m_controllerList === undefined)
                            this.m_controllerList = null;
                        if (this.m_xf === undefined)
                            this.m_xf = null;
                        if (this.m_sweep === undefined)
                            this.m_sweep = null;
                        if (this.m_linearVelocity === undefined)
                            this.m_linearVelocity = null;
                        if (this.m_angularVelocity === undefined)
                            this.m_angularVelocity = 0;
                        if (this.m_force === undefined)
                            this.m_force = null;
                        if (this.m_torque === undefined)
                            this.m_torque = 0;
                        if (this.m_world === undefined)
                            this.m_world = null;
                        if (this.m_prev === undefined)
                            this.m_prev = null;
                        if (this.m_next === undefined)
                            this.m_next = null;
                        if (this.m_shapeList === undefined)
                            this.m_shapeList = null;
                        if (this.m_shapeCount === undefined)
                            this.m_shapeCount = 0;
                        if (this.m_jointList === undefined)
                            this.m_jointList = null;
                        if (this.m_contactList === undefined)
                            this.m_contactList = null;
                        if (this.m_mass === undefined)
                            this.m_mass = 0;
                        if (this.m_invMass === undefined)
                            this.m_invMass = 0;
                        if (this.m_I === undefined)
                            this.m_I = 0;
                        if (this.m_invI === undefined)
                            this.m_invI = 0;
                        if (this.m_linearDamping === undefined)
                            this.m_linearDamping = 0;
                        if (this.m_angularDamping === undefined)
                            this.m_angularDamping = 0;
                        if (this.m_sleepTime === undefined)
                            this.m_sleepTime = 0;
                        if (this.m_userData === undefined)
                            this.m_userData = null;
                        (() => {
                            {
                                this.m_uniqueID = Body.nextID++;
                            }
                            ;
                            this.m_flags = 0;
                            if (bd.isBullet) {
                                this.m_flags |= Body.e_bulletFlag;
                            }
                            if (bd.fixedRotation) {
                                this.m_flags |= Body.e_fixedRotationFlag;
                            }
                            if (bd.allowSleep) {
                                this.m_flags |= Body.e_allowSleepFlag;
                            }
                            if (bd.isSleeping) {
                                this.m_flags |= Body.e_sleepFlag;
                            }
                            this.m_world = world;
                            this.m_xf = new org.jbox2d.common.XForm();
                            this.m_xf.position.set$org_jbox2d_common_Vec2(bd.position);
                            this.m_xf.R.set$float(bd.angle);
                            this.m_sweep = new org.jbox2d.common.Sweep();
                            this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(bd.massData.center);
                            this.m_sweep.t0 = 1.0;
                            this.m_sweep.a0 = this.m_sweep.a = bd.angle;
                            this.m_sweep.c.set$org_jbox2d_common_Vec2(org.jbox2d.common.XForm.mul(this.m_xf, this.m_sweep.localCenter));
                            this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                            this.m_jointList = null;
                            this.m_contactList = null;
                            this.m_prev = null;
                            this.m_next = null;
                            this.m_linearDamping = bd.linearDamping;
                            this.m_angularDamping = bd.angularDamping;
                            this.m_force = new org.jbox2d.common.Vec2(0.0, 0.0);
                            this.m_torque = 0.0;
                            this.m_linearVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                            this.m_angularVelocity = 0.0;
                            this.m_sleepTime = 0.0;
                            this.m_invMass = 0.0;
                            this.m_I = 0.0;
                            this.m_invI = 0.0;
                            this.m_mass = bd.massData.mass;
                            if (this.m_mass > 0.0) {
                                this.m_invMass = Math.fround(1.0 / this.m_mass);
                            }
                            if ((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                                this.m_I = bd.massData.I;
                            }
                            if (this.m_I > 0.0) {
                                this.m_invI = Math.fround(1.0 / this.m_I);
                            }
                            if (this.m_invMass === 0.0 && this.m_invI === 0.0) {
                                this.m_type = Body.e_staticType;
                            }
                            else {
                                this.m_type = Body.e_dynamicType;
                            }
                            this.m_userData = bd.userData;
                            this.m_shapeList = null;
                            this.m_shapeCount = 0;
                        })();
                    }
                    else if (bd === undefined && world === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let bd = new org.jbox2d.dynamics.BodyDef();
                            let world = null;
                            if (this.m_uniqueID === undefined)
                                this.m_uniqueID = 0;
                            if (this.m_flags === undefined)
                                this.m_flags = 0;
                            if (this.m_type === undefined)
                                this.m_type = 0;
                            if (this.m_controllerList === undefined)
                                this.m_controllerList = null;
                            if (this.m_xf === undefined)
                                this.m_xf = null;
                            if (this.m_sweep === undefined)
                                this.m_sweep = null;
                            if (this.m_linearVelocity === undefined)
                                this.m_linearVelocity = null;
                            if (this.m_angularVelocity === undefined)
                                this.m_angularVelocity = 0;
                            if (this.m_force === undefined)
                                this.m_force = null;
                            if (this.m_torque === undefined)
                                this.m_torque = 0;
                            if (this.m_world === undefined)
                                this.m_world = null;
                            if (this.m_prev === undefined)
                                this.m_prev = null;
                            if (this.m_next === undefined)
                                this.m_next = null;
                            if (this.m_shapeList === undefined)
                                this.m_shapeList = null;
                            if (this.m_shapeCount === undefined)
                                this.m_shapeCount = 0;
                            if (this.m_jointList === undefined)
                                this.m_jointList = null;
                            if (this.m_contactList === undefined)
                                this.m_contactList = null;
                            if (this.m_mass === undefined)
                                this.m_mass = 0;
                            if (this.m_invMass === undefined)
                                this.m_invMass = 0;
                            if (this.m_I === undefined)
                                this.m_I = 0;
                            if (this.m_invI === undefined)
                                this.m_invI = 0;
                            if (this.m_linearDamping === undefined)
                                this.m_linearDamping = 0;
                            if (this.m_angularDamping === undefined)
                                this.m_angularDamping = 0;
                            if (this.m_sleepTime === undefined)
                                this.m_sleepTime = 0;
                            if (this.m_userData === undefined)
                                this.m_userData = null;
                            if (this.m_uniqueID === undefined)
                                this.m_uniqueID = 0;
                            if (this.m_flags === undefined)
                                this.m_flags = 0;
                            if (this.m_type === undefined)
                                this.m_type = 0;
                            if (this.m_controllerList === undefined)
                                this.m_controllerList = null;
                            if (this.m_xf === undefined)
                                this.m_xf = null;
                            if (this.m_sweep === undefined)
                                this.m_sweep = null;
                            if (this.m_linearVelocity === undefined)
                                this.m_linearVelocity = null;
                            if (this.m_angularVelocity === undefined)
                                this.m_angularVelocity = 0;
                            if (this.m_force === undefined)
                                this.m_force = null;
                            if (this.m_torque === undefined)
                                this.m_torque = 0;
                            if (this.m_world === undefined)
                                this.m_world = null;
                            if (this.m_prev === undefined)
                                this.m_prev = null;
                            if (this.m_next === undefined)
                                this.m_next = null;
                            if (this.m_shapeList === undefined)
                                this.m_shapeList = null;
                            if (this.m_shapeCount === undefined)
                                this.m_shapeCount = 0;
                            if (this.m_jointList === undefined)
                                this.m_jointList = null;
                            if (this.m_contactList === undefined)
                                this.m_contactList = null;
                            if (this.m_mass === undefined)
                                this.m_mass = 0;
                            if (this.m_invMass === undefined)
                                this.m_invMass = 0;
                            if (this.m_I === undefined)
                                this.m_I = 0;
                            if (this.m_invI === undefined)
                                this.m_invI = 0;
                            if (this.m_linearDamping === undefined)
                                this.m_linearDamping = 0;
                            if (this.m_angularDamping === undefined)
                                this.m_angularDamping = 0;
                            if (this.m_sleepTime === undefined)
                                this.m_sleepTime = 0;
                            if (this.m_userData === undefined)
                                this.m_userData = null;
                            (() => {
                                {
                                    this.m_uniqueID = Body.nextID++;
                                }
                                ;
                                this.m_flags = 0;
                                if (bd.isBullet) {
                                    this.m_flags |= Body.e_bulletFlag;
                                }
                                if (bd.fixedRotation) {
                                    this.m_flags |= Body.e_fixedRotationFlag;
                                }
                                if (bd.allowSleep) {
                                    this.m_flags |= Body.e_allowSleepFlag;
                                }
                                if (bd.isSleeping) {
                                    this.m_flags |= Body.e_sleepFlag;
                                }
                                this.m_world = world;
                                this.m_xf = new org.jbox2d.common.XForm();
                                this.m_xf.position.set$org_jbox2d_common_Vec2(bd.position);
                                this.m_xf.R.set$float(bd.angle);
                                this.m_sweep = new org.jbox2d.common.Sweep();
                                this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(bd.massData.center);
                                this.m_sweep.t0 = 1.0;
                                this.m_sweep.a0 = this.m_sweep.a = bd.angle;
                                this.m_sweep.c.set$org_jbox2d_common_Vec2(org.jbox2d.common.XForm.mul(this.m_xf, this.m_sweep.localCenter));
                                this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                                this.m_jointList = null;
                                this.m_contactList = null;
                                this.m_prev = null;
                                this.m_next = null;
                                this.m_linearDamping = bd.linearDamping;
                                this.m_angularDamping = bd.angularDamping;
                                this.m_force = new org.jbox2d.common.Vec2(0.0, 0.0);
                                this.m_torque = 0.0;
                                this.m_linearVelocity = new org.jbox2d.common.Vec2(0.0, 0.0);
                                this.m_angularVelocity = 0.0;
                                this.m_sleepTime = 0.0;
                                this.m_invMass = 0.0;
                                this.m_I = 0.0;
                                this.m_invI = 0.0;
                                this.m_mass = bd.massData.mass;
                                if (this.m_mass > 0.0) {
                                    this.m_invMass = Math.fround(1.0 / this.m_mass);
                                }
                                if ((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                                    this.m_I = bd.massData.I;
                                }
                                if (this.m_I > 0.0) {
                                    this.m_invI = Math.fround(1.0 / this.m_I);
                                }
                                if (this.m_invMass === 0.0 && this.m_invI === 0.0) {
                                    this.m_type = Body.e_staticType;
                                }
                                else {
                                    this.m_type = Body.e_dynamicType;
                                }
                                this.m_userData = bd.userData;
                                this.m_shapeList = null;
                                this.m_shapeCount = 0;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                static idLock_$LI$() { if (Body.idLock == null)
                    Body.idLock = new Object(); return Body.idLock; }
                ;
                /*private*/ connectEdges(s1, s2, angle1) {
                    let angle2 = Math.fround(Math.atan2(s2.getDirectionVector().y, s2.getDirectionVector().x));
                    let core = s2.getDirectionVector().mul(Math.fround(Math.tan(Math.fround((Math.fround(angle2 - angle1)) * 0.5))));
                    (core.subLocal(s2.getNormalVector())).mulLocal(org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(s2.getVertex1());
                    let cornerDir = s1.getDirectionVector().add(s2.getDirectionVector());
                    cornerDir.normalize();
                    let convex = org.jbox2d.common.Vec2.dot(s1.getDirectionVector(), s2.getNormalVector()) > 0.0;
                    s1.setNextEdge(s2, core, cornerDir, convex);
                    s2.setPrevEdge(s1, core, cornerDir, convex);
                    return angle2;
                }
                /**
                 * Creates a shape and attach it to this body.
                 * <BR><em>Warning</em>: This function is locked during callbacks.
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def the shape definition.
                 * @return {org.jbox2d.collision.shapes.Shape}
                 */
                createShape(def) {
                    if (this.m_world.m_lock === true) {
                        return null;
                    }
                    if (def.type === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                        let edgeDef = def;
                        let v1;
                        let v2;
                        let i = 0;
                        if (edgeDef.isLoop()) {
                            v1 = edgeDef.getVertices()[edgeDef.getVertexCount() - 1];
                            i = 0;
                        }
                        else {
                            v1 = edgeDef.getVertices()[0];
                            i = 1;
                        }
                        let s0 = null;
                        let s1 = null;
                        let s2 = null;
                        let angle = 0.0;
                        for (; i < edgeDef.getVertexCount(); i++) {
                            {
                                v2 = edgeDef.getVertices()[i];
                                s2 = new org.jbox2d.collision.shapes.EdgeShape(v1, v2, def);
                                s2.m_next = this.m_shapeList;
                                this.m_shapeList = s2;
                                ++this.m_shapeCount;
                                s2.m_body = this;
                                s2.createProxy(this.m_world.m_broadPhase, this.m_xf);
                                s2.updateSweepRadius(this.m_sweep.localCenter);
                                if (s1 == null) {
                                    s0 = s2;
                                    angle = Math.fround(Math.atan2(s2.getDirectionVector().y, s2.getDirectionVector().x));
                                }
                                else {
                                    angle = this.connectEdges(s1, s2, angle);
                                }
                                s1 = s2;
                                v1 = v2;
                            }
                            ;
                        }
                        if (edgeDef.isLoop()) {
                            this.connectEdges(s1, s0, angle);
                        }
                        return s0;
                    }
                    let s = org.jbox2d.collision.shapes.Shape.create(def);
                    s.m_next = this.m_shapeList;
                    this.m_shapeList = s;
                    ++this.m_shapeCount;
                    s.m_body = this;
                    s.createProxy(this.m_world.m_broadPhase, this.m_xf);
                    s.updateSweepRadius(this.m_sweep.localCenter);
                    return s;
                }
                /**
                 * Destroy a shape. This removes the shape from the broad-phase and
                 * therefore destroys any contacts associated with this shape. All shapes
                 * attached to a body are implicitly destroyed when the body is destroyed.
                 * <BR><em>Warning</em>: This function is locked during callbacks.
                 * @param {org.jbox2d.collision.shapes.Shape} s the shape to be removed.
                 */
                destroyShape(s) {
                    if (this.m_world.m_lock === true) {
                        return;
                    }
                    s.destroyProxy(this.m_world.m_broadPhase);
                    let node = this.m_shapeList;
                    let prevNode = null;
                    let found = false;
                    while ((node != null)) {
                        {
                            if (node === s) {
                                if (prevNode == null) {
                                    this.m_shapeList = s.m_next;
                                    found = true;
                                    break;
                                }
                                else {
                                    prevNode.m_next = s.m_next;
                                    found = true;
                                    break;
                                }
                            }
                            prevNode = node;
                            node = node.m_next;
                        }
                    }
                    ;
                    s.m_body = null;
                    s.m_next = null;
                    --this.m_shapeCount;
                    org.jbox2d.collision.shapes.Shape.destroy(s);
                }
                /**
                 * Set the mass properties. Note that this changes the center of mass position.
                 * If you are not sure how to compute mass properties, use setMassFromShapes().
                 * The inertia tensor is assumed to be relative to the center of mass.
                 * @param {org.jbox2d.collision.MassData} massData the mass properties.
                 */
                setMass(massData) {
                    if (this.m_world.m_lock === true) {
                        return;
                    }
                    this.m_invMass = 0.0;
                    this.m_I = 0.0;
                    this.m_invI = 0.0;
                    this.m_mass = massData.mass;
                    if (this.m_mass > 0.0) {
                        this.m_invMass = Math.fround(1.0 / this.m_mass);
                    }
                    if ((this.m_flags & Body.e_fixedRotationFlag) === 0) {
                        this.m_I = massData.I;
                    }
                    if (this.m_I > 0.0) {
                        this.m_invI = Math.fround(1.0 / this.m_I);
                    }
                    this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(massData.center);
                    org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
                    this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                    for (let s = this.m_shapeList; s != null; s = s.m_next) {
                        {
                            s.updateSweepRadius(this.m_sweep.localCenter);
                        }
                        ;
                    }
                    let oldType = this.m_type;
                    if (this.m_invMass === 0.0 && this.m_invI === 0.0) {
                        this.m_type = Body.e_staticType;
                    }
                    else {
                        this.m_type = Body.e_dynamicType;
                    }
                    if (oldType !== this.m_type) {
                        for (let s = this.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.refilterProxy(this.m_world.m_broadPhase, this.m_xf);
                            }
                            ;
                        }
                    }
                }
                static tlCenter_$LI$() { if (Body.tlCenter == null)
                    Body.tlCenter = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return Body.tlCenter; }
                ;
                /**
                 * Compute the mass properties from the attached shapes. You typically call this
                 * after adding all the shapes. If you add or remove shapes later, you may want
                 * to call this again. Note that this changes the center of mass position.
                 */
                setMassFromShapes() {
                    if (this.m_world.m_lock === true) {
                        return;
                    }
                    this.m_mass = 0.0;
                    this.m_invMass = 0.0;
                    this.m_I = 0.0;
                    this.m_invI = 0.0;
                    let center = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Body.tlCenter_$LI$());
                    center.setZero();
                    for (let s = this.m_shapeList; s != null; s = s.m_next) {
                        {
                            let massData = new org.jbox2d.collision.MassData();
                            s.computeMass(massData);
                            this.m_mass += massData.mass;
                            center.x += Math.fround(massData.mass * massData.center.x);
                            center.y += Math.fround(massData.mass * massData.center.y);
                            this.m_I += massData.I;
                        }
                        ;
                    }
                    if (this.m_mass > 0.0) {
                        this.m_invMass = Math.fround(1.0 / this.m_mass);
                        center.x *= this.m_invMass;
                        center.y *= this.m_invMass;
                    }
                    if (this.m_I > 0.0 && (this.m_flags & Body.e_fixedRotationFlag) === 0) {
                        this.m_I -= Math.fround(this.m_mass * org.jbox2d.common.Vec2.dot(center, center));
                        this.m_invI = Math.fround(1.0 / this.m_I);
                    }
                    else {
                        this.m_I = 0.0;
                        this.m_invI = 0.0;
                    }
                    this.m_sweep.localCenter.set$org_jbox2d_common_Vec2(center);
                    org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
                    this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                    for (let s = this.m_shapeList; s != null; s = s.m_next) {
                        {
                            s.updateSweepRadius(this.m_sweep.localCenter);
                        }
                        ;
                    }
                    let oldType = this.m_type;
                    if (this.m_invMass === 0.0 && this.m_invI === 0.0) {
                        this.m_type = Body.e_staticType;
                    }
                    else {
                        this.m_type = Body.e_dynamicType;
                    }
                    if (oldType !== this.m_type) {
                        for (let s = this.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.refilterProxy(this.m_world.m_broadPhase, this.m_xf);
                            }
                            ;
                        }
                    }
                }
                /**
                 * Set the position of the body's origin and rotation (radians).
                 * This breaks any contacts and wakes the other bodies.
                 * @param {org.jbox2d.common.Vec2} position the new world position of the body's origin (not necessarily
                 * the center of mass).
                 * @param {number} angle the new world rotation angle of the body in radians.
                 * @return {boolean} false if the movement put a shape outside the world. In this case the
                 * body is automatically frozen.
                 */
                setXForm(position, angle) {
                    if (this.m_world.m_lock === true) {
                        return true;
                    }
                    if (this.isFrozen()) {
                        return false;
                    }
                    this.m_xf.R.set$float(angle);
                    this.m_xf.position.set$org_jbox2d_common_Vec2(position);
                    org.jbox2d.common.XForm.mulToOut(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
                    this.m_sweep.c0.set$org_jbox2d_common_Vec2(this.m_sweep.c);
                    this.m_sweep.a0 = this.m_sweep.a = angle;
                    let freeze = false;
                    for (let s = this.m_shapeList; s != null; s = s.m_next) {
                        {
                            let inRange = s.synchronize(this.m_world.m_broadPhase, this.m_xf, this.m_xf);
                            if (inRange === false) {
                                freeze = true;
                                break;
                            }
                        }
                        ;
                    }
                    if (freeze === true) {
                        this.m_flags |= Body.e_frozenFlag;
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0.0;
                        for (let s = this.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.destroyProxy(this.m_world.m_broadPhase);
                            }
                            ;
                        }
                        return false;
                    }
                    this.m_world.m_broadPhase.commit();
                    return true;
                }
                /**
                 * Get a copy of the body transform for the body's origin.
                 * @return {org.jbox2d.common.XForm} the world transform of the body's origin.
                 */
                getXForm() {
                    let xf = new org.jbox2d.common.XForm();
                    xf.set(this.m_xf);
                    return xf;
                }
                /**
                 * More for internal use.  It isn't copied,
                 * so don't modify it.  instead try to use {@link #setXForm(Vec2, float)}.
                 * Otherwise, this also gives you direct access to the body's XForm, if you
                 * really need to change something (careful!).
                 * @see #getXForm()
                 * @see #setXForm(Vec2, float)
                 * @return {org.jbox2d.common.XForm} an uncopied version of this body's XForm
                 */
                getMemberXForm() {
                    return this.m_xf;
                }
                /**
                 * You probably don't want to use this
                 * function.  What you really want is getWorldCenter(),
                 * which returns the center of mass (which actually has
                 * some physical significance).
                 * <p>
                 * Just in case you do want to use this,
                 * Get a copy of the world body origin position.  This
                 * is not necessarily the same as the center of mass.
                 * In fact, it's not anything in particular.  Just a
                 * point.
                 * <p>
                 * @return {org.jbox2d.common.Vec2} a copy of the world position of the body's origin.
                 */
                getPosition() {
                    return ((o) => { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        let clone = Object.create(o);
                        for (let p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this.m_xf.position);
                }
                /**
                 * This is more for internal use.  It isn't copied, so don't
                 * modify it.  This is the position of the body's XForm
                 * ({@link #getXForm()}), and if you want to change that I would
                 * suggest using {@link #setXForm(Vec2, float)}.  Modifying this
                 * will not do what you want.
                 * @see #getPosition()
                 * @return {org.jbox2d.common.Vec2} the body's world position of the body's origin.
                 */
                getMemberPosition() {
                    return this.m_xf.position;
                }
                /**
                 * Get the angle in radians.
                 * @return {number} the current world rotation angle in radians.
                 */
                getAngle() {
                    return this.m_sweep.a;
                }
                /**
                 * Get a copy of the world position of the center of mass.
                 * @return {org.jbox2d.common.Vec2} a copy of the world position
                 */
                getWorldCenter() {
                    return ((o) => { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        let clone = Object.create(o);
                        for (let p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this.m_sweep.c);
                }
                /**
                 * More for internal use. It isn't copied, so don't
                 * modify it.  Modifying this will not do what you want,
                 * instead use {@link #setXForm(Vec2, float)}
                 * @see #getWorldCenter()
                 * @return {org.jbox2d.common.Vec2} the world position
                 */
                getMemberWorldCenter() {
                    return this.m_sweep.c;
                }
                /**
                 * Get local position of the center of mass.
                 * @return {org.jbox2d.common.Vec2} a copy of the local position of the center of mass
                 */
                getLocalCenter() {
                    return ((o) => { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        let clone = Object.create(o);
                        for (let p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this.m_sweep.localCenter);
                }
                /**
                 * More for internal use. It isn't a copy, so don't
                 * modify it.
                 * @return {org.jbox2d.common.Vec2} the local position of the center of mass
                 */
                getMemberLocalCenter() {
                    return this.m_sweep.localCenter;
                }
                /**
                 * Set the linear velocity of the center of mass.
                 * @param {org.jbox2d.common.Vec2} v the new linear velocity of the center of mass.
                 */
                setLinearVelocity(v) {
                    this.m_linearVelocity.set$org_jbox2d_common_Vec2(v);
                }
                /**
                 * Get the linear velocity of the center of mass. This isn't a copy,
                 * so modifying this will change the linear velocity.
                 * @return {org.jbox2d.common.Vec2} a the linear velocity of the center of mass.
                 */
                getLinearVelocity() {
                    return this.m_linearVelocity;
                }
                /**
                 * Set the angular velocity.
                 * @param {number} omega the new angular velocity in radians/second.
                 */
                setAngularVelocity(omega) {
                    this.m_angularVelocity = omega;
                }
                /**
                 * Get the angular velocity.
                 * @return {number} the angular velocity in radians/second.
                 */
                getAngularVelocity() {
                    return this.m_angularVelocity;
                }
                /**
                 * Apply a force at a world point. If the force is not
                 * applied at the center of mass, it will generate a torque and
                 * affect the angular velocity. This wakes up the body.
                 * @param {org.jbox2d.common.Vec2} force the world force vector, usually in Newtons (N).
                 * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
                 */
                applyForce(force, point) {
                    if (this.isSleeping()) {
                        this.wakeUp();
                    }
                    this.m_force.addLocal$org_jbox2d_common_Vec2(force);
                    this.m_torque += Math.fround(Math.fround((Math.fround(point.x - this.m_sweep.c.x)) * force.y) - Math.fround((Math.fround(point.y - this.m_sweep.c.y)) * force.x));
                }
                /**
                 * Apply a torque. This affects the angular velocity
                 * without affecting the linear velocity of the center of mass.
                 * This wakes up the body.
                 * @param {number} torque about the z-axis (out of the screen), usually in N-m.
                 */
                applyTorque(torque) {
                    if (this.isSleeping()) {
                        this.wakeUp();
                    }
                    this.m_torque += torque;
                }
                /**
                 * Apply an impulse at a point. This immediately modifies the velocity.
                 * It also modifies the angular velocity if the point of application
                 * is not at the center of mass. This wakes up the body.
                 * @param {org.jbox2d.common.Vec2} impulse the world impulse vector, usually in N-seconds or kg-m/s.
                 * @param {org.jbox2d.common.Vec2} point the world position of the point of application.
                 */
                applyImpulse(impulse, point) {
                    if (this.isSleeping()) {
                        this.wakeUp();
                    }
                    this.m_linearVelocity.x += Math.fround(this.m_invMass * impulse.x);
                    this.m_linearVelocity.y += Math.fround(this.m_invMass * impulse.y);
                    this.m_angularVelocity += Math.fround(this.m_invI * (Math.fround(Math.fround((Math.fround(point.x - this.m_sweep.c.x)) * impulse.y) - Math.fround((Math.fround(point.y - this.m_sweep.c.y)) * impulse.x))));
                }
                /**
                 * Get the total mass of the body.
                 * @return {number} the mass, usually in kilograms (kg).
                 */
                getMass() {
                    return this.m_mass;
                }
                /**
                 * Get the central rotational inertia of the body.
                 * @return {number} the rotational inertia, usually in kg-m^2.
                 */
                getInertia() {
                    return this.m_I;
                }
                /**
                 * Get the world coordinates of a point given the local coordinates.
                 * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
                 * @return {org.jbox2d.common.Vec2} the same point expressed in world coordinates.
                 */
                getWorldLocation(localPoint) {
                    return org.jbox2d.common.XForm.mul(this.m_xf, localPoint);
                }
                /**
                 * Get the world coordinates of a point given the local coordinates.
                 * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
                 * @param {org.jbox2d.common.Vec2} out where to put the same point expressed in world coordinates.
                 */
                getWorldLocationToOut(localPoint, out) {
                    org.jbox2d.common.XForm.mulToOut(this.m_xf, localPoint, out);
                }
                /**
                 * Get the world coordinates of a point given the local coordinates.
                 * @param {org.jbox2d.common.Vec2} localPoint a point on the body measured relative the the body's origin.
                 * @return {org.jbox2d.common.Vec2} the same point expressed in world coordinates.
                 * @deprecated Use getWorldLocation instead (clearer naming convention)
                 */
                getWorldPoint(localPoint) {
                    return this.getWorldLocation(localPoint);
                }
                /**
                 * Get the world coordinates of a vector given the local coordinates.
                 * @param {org.jbox2d.common.Vec2} localVector a vector fixed in the body.
                 * @return {org.jbox2d.common.Vec2} the same vector expressed in world coordinates.
                 * @deprecated Use getWorldDirection instead (clearer naming convention)
                 */
                getWorldVector(localVector) {
                    return this.getWorldDirection(localVector);
                }
                /**
                 * Get the world coordinates of a direction given the local direction.
                 * @param {org.jbox2d.common.Vec2} localDirection a vector fixed in the body.
                 * @return {org.jbox2d.common.Vec2} the same vector expressed in world coordinates.
                 */
                getWorldDirection(localDirection) {
                    return org.jbox2d.common.Mat22.mul$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_xf.R, localDirection);
                }
                /**
                 * Get the world coordinates of a direction given the local direction.
                 * @param {org.jbox2d.common.Vec2} localDirection a vector fixed in the body.
                 * @param {org.jbox2d.common.Vec2} out where to put the same vector expressed in world coordinates.
                 */
                getWorldDirectionToOut(localDirection, out) {
                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.R, localDirection, out);
                }
                /**
                 * Gets a local point relative to the body's origin given a world point.
                 * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
                 * @return {org.jbox2d.common.Vec2} the corresponding local point relative to the body's origin.
                 */
                getLocalPoint(worldPoint) {
                    return org.jbox2d.common.XForm.mulTrans(this.m_xf, worldPoint);
                }
                /**
                 * Gets a local point relative to the body's origin given a world point.
                 * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
                 * @param {org.jbox2d.common.Vec2} out where to put the the corresponding local point relative to the body's origin.
                 */
                getLocalPointToOut(worldPoint, out) {
                    org.jbox2d.common.XForm.mulTransToOut(this.m_xf, worldPoint, out);
                }
                /**
                 * Gets a local vector given a world vector.
                 * @param {org.jbox2d.common.Vec2} worldVector a vector in world coordinates.
                 * @return {org.jbox2d.common.Vec2} the corresponding local vector.
                 */
                getLocalVector(worldVector) {
                    return org.jbox2d.common.Mat22.mulTrans$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2(this.m_xf.R, worldVector);
                }
                /**
                 * Gets a local vector given a world vector.
                 * @param {org.jbox2d.common.Vec2} worldVector a vector in world coordinates.
                 * @param {org.jbox2d.common.Vec2} out where to put the corresponding local vector.
                 */
                getLocalVectorToOut(worldVector, out) {
                    org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_xf.R, worldVector, out);
                }
                /**
                 * Is this body treated like a bullet for continuous collision detection?
                 * @return {boolean}
                 */
                isBullet() {
                    return (this.m_flags & Body.e_bulletFlag) === Body.e_bulletFlag;
                }
                /**
                 * Should this body be treated like a bullet for continuous collision detection?
                 * Use sparingly, as continuous collision detection can be expensive.
                 * @param {boolean} flag
                 */
                setBullet(flag) {
                    if (flag) {
                        this.m_flags |= Body.e_bulletFlag;
                    }
                    else {
                        this.m_flags &= ~Body.e_bulletFlag;
                    }
                }
                /**
                 * Is this body static (immovable)?
                 * @return {boolean}
                 */
                isStatic() {
                    return this.m_type === Body.e_staticType;
                }
                /**
                 * Is this body dynamic (movable)?
                 * @return {boolean}
                 */
                isDynamic() {
                    return this.m_type === Body.e_dynamicType;
                }
                /**
                 * Is this body frozen?
                 * @return {boolean}
                 */
                isFrozen() {
                    return (this.m_flags & Body.e_frozenFlag) === Body.e_frozenFlag;
                }
                /**
                 * Is this body sleeping (not simulating).
                 * @return {boolean}
                 */
                isSleeping() {
                    return (this.m_flags & Body.e_sleepFlag) === Body.e_sleepFlag;
                }
                /**
                 * Set to false to prevent this body from sleeping due to inactivity.
                 * @param {boolean} flag
                 */
                allowSleeping(flag) {
                    if (flag) {
                        this.m_flags |= Body.e_allowSleepFlag;
                    }
                    else {
                        this.m_flags &= ~Body.e_allowSleepFlag;
                        this.wakeUp();
                    }
                }
                /**
                 * Wake up this body so it will begin simulating.
                 */
                wakeUp() {
                    this.m_flags &= ~Body.e_sleepFlag;
                    this.m_sleepTime = 0.0;
                }
                /**
                 * Get the linked list of all shapes attached to this body.
                 * @return {org.jbox2d.collision.shapes.Shape} first Shape in linked list
                 */
                getShapeList() {
                    return this.m_shapeList;
                }
                /**
                 * Get the linked list of all joints attached to this body.
                 * @return {org.jbox2d.dynamics.joints.JointEdge} first JointEdge in linked list
                 */
                getJointList() {
                    return this.m_jointList;
                }
                /**
                 * Get the next body in the world's body list.
                 * @return {org.jbox2d.dynamics.Body}
                 */
                getNext() {
                    return this.m_next;
                }
                /**
                 * Get the user data Object reference that was provided in the body definition.
                 * @return {*}
                 */
                getUserData() {
                    return this.m_userData;
                }
                /**
                 * For internal use only.
                 */
                computeMass() {
                }
                static tlXf1_$LI$() { if (Body.tlXf1 == null)
                    Body.tlXf1 = (() => { let __o = new org.jbox2d.pooling.TLXForm(); __o.__delegate = new org.jbox2d.pooling.TLXForm(); return __o; })(); return Body.tlXf1; }
                ;
                /**
                 * For internal use only.
                 * @return {boolean}
                 */
                synchronizeShapes() {
                    let xf1 = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(Body.tlXf1_$LI$());
                    xf1.R.set$float(this.m_sweep.a0);
                    let R = xf1.R;
                    let v = this.m_sweep.localCenter;
                    xf1.position.set$float$float(Math.fround(this.m_sweep.c0.x - (Math.fround(Math.fround(R.col1.x * v.x) + Math.fround(R.col2.x * v.y)))), Math.fround(this.m_sweep.c0.y - (Math.fround(Math.fround(R.col1.y * v.x) + Math.fround(R.col2.y * v.y)))));
                    let inRange = true;
                    for (let s = this.m_shapeList; s != null; s = s.m_next) {
                        {
                            inRange = s.synchronize(this.m_world.m_broadPhase, xf1, this.m_xf);
                            if (inRange === false) {
                                break;
                            }
                        }
                        ;
                    }
                    if (inRange === false) {
                        this.m_flags |= Body.e_frozenFlag;
                        this.m_linearVelocity.setZero();
                        this.m_angularVelocity = 0.0;
                        for (let s = this.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.destroyProxy(this.m_world.m_broadPhase);
                            }
                            ;
                        }
                        return false;
                    }
                    return true;
                }
                /**
                 * For internal use only.
                 */
                synchronizeTransform() {
                    this.m_xf.R.set$float(this.m_sweep.a);
                    let v1 = this.m_sweep.localCenter;
                    this.m_xf.position.x = Math.fround(this.m_sweep.c.x - (Math.fround(Math.fround(this.m_xf.R.col1.x * v1.x) + Math.fround(this.m_xf.R.col2.x * v1.y))));
                    this.m_xf.position.y = Math.fround(this.m_sweep.c.y - (Math.fround(Math.fround(this.m_xf.R.col1.y * v1.x) + Math.fround(this.m_xf.R.col2.y * v1.y))));
                }
                /**
                 * This is used to prevent connected bodies from colliding.
                 * It may lie, depending on the collideConnected flag, so
                 * it won't be very useful external to the engine.
                 * @param {org.jbox2d.dynamics.Body} other
                 * @return {boolean}
                 */
                isConnected(other) {
                    for (let jn = this.m_jointList; jn != null; jn = jn.next) {
                        {
                            if (jn.other === other) {
                                return (jn.joint.m_collideConnected === false);
                            }
                        }
                        ;
                    }
                    return false;
                }
                /**
                 * For internal use only.
                 * @param {number} t
                 */
                advance(t) {
                    this.m_sweep.advance(t);
                    this.m_sweep.c.set$org_jbox2d_common_Vec2(this.m_sweep.c0);
                    this.m_sweep.a = this.m_sweep.a0;
                    this.synchronizeTransform();
                }
                /**
                 * Get the world linear velocity of a world point attached to this body.
                 * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
                 * @return {org.jbox2d.common.Vec2} the world velocity of a point.
                 */
                getLinearVelocityFromWorldPoint(worldPoint) {
                    let ax = Math.fround(worldPoint.x - this.m_sweep.c.x);
                    let ay = Math.fround(worldPoint.y - this.m_sweep.c.y);
                    let vx = Math.fround(-this.m_angularVelocity * ay);
                    let vy = Math.fround(this.m_angularVelocity * ax);
                    return new org.jbox2d.common.Vec2(Math.fround(this.m_linearVelocity.x + vx), Math.fround(this.m_linearVelocity.y + vy));
                }
                /**
                 * Get the world linear velocity of a world point attached to this body.
                 * @param {org.jbox2d.common.Vec2} worldPoint a point in world coordinates.
                 * @param {org.jbox2d.common.Vec2} out where to put the world velocity of a point.
                 */
                getLinearVelocityFromWorldPointToOut(worldPoint, out) {
                    let ax = Math.fround(worldPoint.x - this.m_sweep.c.x);
                    let ay = Math.fround(worldPoint.y - this.m_sweep.c.y);
                    let vx = Math.fround(-this.m_angularVelocity * ay);
                    let vy = Math.fround(this.m_angularVelocity * ax);
                    out.set$float$float(Math.fround(this.m_linearVelocity.x + vx), Math.fround(this.m_linearVelocity.y + vy));
                }
                /**
                 * Get the world velocity of a local point.
                 * @param {org.jbox2d.common.Vec2} localPoint a point in local coordinates.
                 * @return {org.jbox2d.common.Vec2} the world velocity of a point.
                 */
                getLinearVelocityFromLocalPoint(localPoint) {
                    let out = new org.jbox2d.common.Vec2();
                    this.getWorldLocationToOut(localPoint, out);
                    let ax = Math.fround(out.x - this.m_sweep.c.x);
                    let ay = Math.fround(out.y - this.m_sweep.c.y);
                    let vx = Math.fround(-this.m_angularVelocity * ay);
                    let vy = Math.fround(this.m_angularVelocity * ax);
                    out.x = Math.fround(this.m_linearVelocity.x + vx);
                    out.y = Math.fround(this.m_linearVelocity.y + vy);
                    return out;
                }
                /**
                 * Get the world velocity of a local point.
                 * @param {org.jbox2d.common.Vec2} localPoint a point in local coordinates.
                 * @param {org.jbox2d.common.Vec2} out where to put the world velocity of a point.
                 */
                getLinearVelocityFromLocalPointToOut(localPoint, out) {
                    this.getWorldLocationToOut(localPoint, out);
                    let ax = Math.fround(out.x - this.m_sweep.c.x);
                    let ay = Math.fround(out.y - this.m_sweep.c.y);
                    let vx = Math.fround(-this.m_angularVelocity * ay);
                    let vy = Math.fround(this.m_angularVelocity * ax);
                    out.x = Math.fround(this.m_linearVelocity.x + vx);
                    out.y = Math.fround(this.m_linearVelocity.y + vy);
                }
                /**
                 * Put this body to sleep so it will stop simulating.
                 * This also sets the velocity to zero.
                 */
                putToSleep() {
                    this.m_flags |= Body.e_sleepFlag;
                    this.m_sleepTime = 0.0;
                    this.m_linearVelocity.setZero();
                    this.m_angularVelocity = 0.0;
                    this.m_force.setZero();
                    this.m_torque = 0.0;
                }
                setUserData(data) {
                    this.m_userData = data;
                }
                getWorld() {
                    return this.m_world;
                }
                /**
                 * Get the contact list, represented as a linked list of ContactEdges. Will
                 * return null if no contacts are present.
                 *
                 * @return {org.jbox2d.dynamics.contacts.ContactEdge} the head of the linked list of contacts
                 */
                getContactList() {
                    return this.m_contactList;
                }
                /**
                 * Get the set of bodies in contact with this body.
                 *
                 * @return {org.jbox2d.dynamics.Body[]} all bodies touching this one
                 */
                getBodiesInContact() {
                    let mySet = ([]);
                    let edge = this.getContactList();
                    while ((edge != null)) {
                        {
                            if (edge.contact.getManifoldCount() > 0) {
                                /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                    s.push(e);
                                    return true;
                                }
                                else {
                                    return false;
                                } })(mySet, edge.other);
                            }
                            edge = edge.next;
                        }
                    }
                    ;
                    return mySet;
                }
                /**
                 * Get the set of bodies connected to this one by a joint.
                 * Note: this does not return the entire island of connected bodies,
                 * only those directly connected to this one.
                 * @return {org.jbox2d.dynamics.Body[]} all bodies connected directly to this body by a joint
                 */
                getConnectedBodies() {
                    let mySet = ([]);
                    let edge = this.getJointList();
                    while ((edge != null)) {
                        {
                            /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(mySet, edge.other);
                            edge = edge.next;
                        }
                    }
                    ;
                    return mySet;
                }
                /**
                 * Get the set of dynamic bodies connected to this one by a joint.
                 * Note: this does not return the entire island of connected bodies,
                 * only those directly connected to this one.
                 * @return {org.jbox2d.dynamics.Body[]} all bodies connected directly to this body by a joint
                 */
                getConnectedDynamicBodies() {
                    let mySet = ([]);
                    let edge = this.getJointList();
                    while ((edge != null)) {
                        {
                            if (edge.other.isDynamic())
                                ((s, e) => { if (s.indexOf(e) == -1) {
                                    s.push(e);
                                    return true;
                                }
                                else {
                                    return false;
                                } })(mySet, edge.other);
                            edge = edge.next;
                        }
                    }
                    ;
                    return mySet;
                }
                /**
                 * Get the island of connected bodies, including the current body.
                 * <em>Warning</em>: will continue walking the joint tree past static bodies,
                 * which may lead to unwanted results esp. if bodies are connected to the ground
                 * body.
                 * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the joint tree
                 */
                getConnectedBodyIsland() {
                    let result = ([]);
                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(result, this);
                    return this.getConnectedBodyIsland_impl(this, result);
                }
                /*private*/ getConnectedBodyIsland_impl(parent, parentResult) {
                    let connected = this.getConnectedBodies();
                    for (let index132 = 0; index132 < connected.length; index132++) {
                        let b = connected[index132];
                        {
                            if (b === parent || (parentResult.indexOf((b)) >= 0))
                                continue;
                            /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(parentResult, b);
                            /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getConnectedBodyIsland_impl(b, parentResult));
                        }
                    }
                    return parentResult;
                }
                /**
                 * Get the island of joint-connected dynamic bodies, including the current body.
                 * Stops walking tree if it encounters a static body.
                 * @see Body#getConnectedBodyIsland()
                 * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the joint tree
                 */
                getConnectedDynamicBodyIsland() {
                    let result = ([]);
                    if (!this.isDynamic())
                        return result;
                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(result, this);
                    return this.getConnectedDynamicBodyIsland_impl(this, result);
                }
                /*private*/ getConnectedDynamicBodyIsland_impl(parent, parentResult) {
                    let connected = this.getConnectedBodies();
                    for (let index133 = 0; index133 < connected.length; index133++) {
                        let b = connected[index133];
                        {
                            if (b === parent || !b.isDynamic() || (parentResult.indexOf((b)) >= 0))
                                continue;
                            /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(parentResult, b);
                            /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getConnectedDynamicBodyIsland_impl(b, parentResult));
                        }
                    }
                    return parentResult;
                }
                /**
                 * Get the island of bodies in contact, including the current body.
                 * <em>Warning</em>: will continue walking the contact tree past static bodies,
                 * which may lead to unwanted results esp. if bodies are touching the ground
                 * body.
                 * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the contact tree
                 */
                getTouchingBodyIsland() {
                    let result = ([]);
                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(result, this);
                    return this.getTouchingBodyIsland_impl(this, result);
                }
                /*private*/ getTouchingBodyIsland_impl(parent, parentResult) {
                    let touching = this.getBodiesInContact();
                    for (let index134 = 0; index134 < touching.length; index134++) {
                        let b = touching[index134];
                        {
                            if (b === parent || (parentResult.indexOf((b)) >= 0))
                                continue;
                            /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(parentResult, b);
                            /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getTouchingBodyIsland_impl(b, parentResult));
                        }
                    }
                    return parentResult;
                }
                /**
                 * Get the island of dynamic bodies in contact, including the current body.
                 * Stops walking tree if it encounters a static body.
                 * @return {org.jbox2d.dynamics.Body[]} Set<Body> of all bodies accessible from this one by walking the contact tree
                 */
                getTouchingDynamicBodyIsland() {
                    let result = ([]);
                    /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(result, this);
                    return this.getTouchingDynamicBodyIsland_impl(this, result);
                }
                /*private*/ getTouchingDynamicBodyIsland_impl(parent, parentResult) {
                    let touching = this.getBodiesInContact();
                    for (let index135 = 0; index135 < touching.length; index135++) {
                        let b = touching[index135];
                        {
                            if (b === parent || !b.isDynamic() || (parentResult.indexOf((b)) >= 0))
                                continue;
                            /* add */ ((s, e) => { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(parentResult, b);
                            /* addAll */ ((l1, l2) => l1.push.apply(l1, l2))(parentResult, b.getTouchingDynamicBodyIsland_impl(b, parentResult));
                        }
                    }
                    return parentResult;
                }
                /**
                 * @return {boolean} true if this Body is currently in contact with the passed body
                 * @param {org.jbox2d.dynamics.Body} other
                 */
                isTouching(other) {
                    let edge = this.getContactList();
                    while ((edge != null)) {
                        {
                            if (edge.other === other && edge.contact.getManifoldCount() > 0)
                                return true;
                            edge = edge.next;
                        }
                    }
                    ;
                    return false;
                }
                setLinearDamping(damping) {
                    this.m_linearDamping = damping;
                }
                getLinearDamping() {
                    return this.m_linearDamping;
                }
                setAngularDamping(damping) {
                    this.m_angularDamping = damping;
                }
                getAngularDamping() {
                    return this.m_angularDamping;
                }
            }
            Body.nextID = 0;
            Body.e_frozenFlag = 2;
            Body.e_islandFlag = 4;
            Body.e_sleepFlag = 8;
            Body.e_allowSleepFlag = 16;
            Body.e_bulletFlag = 32;
            Body.e_fixedRotationFlag = 64;
            Body.e_staticType = 0;
            Body.e_dynamicType = 1;
            Body.e_maxTypes = 2;
            dynamics.Body = Body;
            Body["__class"] = "org.jbox2d.dynamics.Body";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var util;
        (function (util) {
            var blob;
            (function (blob) {
                /**
                 * Simple non-reinforced square lattice.
                 * Easy to collapse, but simple.
                 * @class
                 * @extends org.jbox2d.util.blob.BlobStructure
                 */
                class SquareLatticeStructure extends org.jbox2d.util.blob.BlobStructure {
                    constructor() {
                        super();
                        let toAdd = new org.jbox2d.util.blob.BlobPoint(0.5, 0.5);
                        let center = this.addPoint(toAdd);
                        this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, blob.BlobStructure.Region.UP_RIGHT);
                        this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, blob.BlobStructure.Region.RIGHT);
                        this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, blob.BlobStructure.Region.DOWN_RIGHT);
                        this.addConnection$int$int$org_jbox2d_util_blob_BlobStructure_Region(center, center, blob.BlobStructure.Region.DOWN);
                    }
                }
                blob.SquareLatticeStructure = SquareLatticeStructure;
                SquareLatticeStructure["__class"] = "org.jbox2d.util.blob.SquareLatticeStructure";
            })(blob = util.blob || (util.blob = {}));
        })(util = jbox2d.util || (jbox2d.util = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (game) {
    /**
     * '
     * NOTE: PREFER {@link GameThreadSafe} OVER THIS IMPLEMENTATION.
     * <p>
     * This creates the QWOP game using the Box2D library. This operates on the primary classloader. This means that
     * multiple instances of this class will interfere with others due to static information inside Box2D.
     * {@link GameThreadSafe} uses a separate classloader for each instance and can be done in multithreaded applications.
     * However, dealing with all the reflection in GameThreadSafe is really annoying. Hence, this class is more readable.
     *
     * @author matt
     * @class
     */
    class GameSingleThread {
        constructor() {
            /**
             * Has this game reached failure conditions?
             */
            /*private*/ this.isFailed = false;
            /**
             * Filters collisions. Prevents body parts from hitting other body parts.
             */
            /*private*/ this.BODY_GROUP = -1;
            if (this.m_world === undefined)
                this.m_world = null;
            if (this.rFootBody === undefined)
                this.rFootBody = null;
            if (this.lFootBody === undefined)
                this.lFootBody = null;
            if (this.rCalfBody === undefined)
                this.rCalfBody = null;
            if (this.lCalfBody === undefined)
                this.lCalfBody = null;
            if (this.rThighBody === undefined)
                this.rThighBody = null;
            if (this.lThighBody === undefined)
                this.lThighBody = null;
            if (this.torsoBody === undefined)
                this.torsoBody = null;
            if (this.rUArmBody === undefined)
                this.rUArmBody = null;
            if (this.lUArmBody === undefined)
                this.lUArmBody = null;
            if (this.rLArmBody === undefined)
                this.rLArmBody = null;
            if (this.lLArmBody === undefined)
                this.lLArmBody = null;
            if (this.headBody === undefined)
                this.headBody = null;
            if (this.trackBody === undefined)
                this.trackBody = null;
            if (this.rHipJDef === undefined)
                this.rHipJDef = null;
            if (this.lHipJDef === undefined)
                this.lHipJDef = null;
            if (this.rKneeJDef === undefined)
                this.rKneeJDef = null;
            if (this.lKneeJDef === undefined)
                this.lKneeJDef = null;
            if (this.rAnkleJDef === undefined)
                this.rAnkleJDef = null;
            if (this.lAnkleJDef === undefined)
                this.lAnkleJDef = null;
            if (this.rShoulderJDef === undefined)
                this.rShoulderJDef = null;
            if (this.lShoulderJDef === undefined)
                this.lShoulderJDef = null;
            if (this.rElbowJDef === undefined)
                this.rElbowJDef = null;
            if (this.lElbowJDef === undefined)
                this.lElbowJDef = null;
            if (this.neckJDef === undefined)
                this.neckJDef = null;
            if (this.rHipJ === undefined)
                this.rHipJ = null;
            if (this.lHipJ === undefined)
                this.lHipJ = null;
            if (this.rKneeJ === undefined)
                this.rKneeJ = null;
            if (this.lKneeJ === undefined)
                this.lKneeJ = null;
            if (this.rAnkleJ === undefined)
                this.rAnkleJ = null;
            if (this.lAnkleJ === undefined)
                this.lAnkleJ = null;
            if (this.rShoulderJ === undefined)
                this.rShoulderJ = null;
            if (this.lShoulderJ === undefined)
                this.lShoulderJ = null;
            if (this.rElbowJ === undefined)
                this.rElbowJ = null;
            if (this.lElbowJ === undefined)
                this.lElbowJ = null;
            if (this.neckJ === undefined)
                this.neckJ = null;
            if (!GameSingleThread.hasOneTimeInitializationHappened) {
                this.oneTimeSetup();
                GameSingleThread.hasOneTimeInitializationHappened = true;
            }
            this.makeNewWorld();
            this.getWorld().setContactListener(new GameSingleThread.CollisionListener(this));
        }
        static worldAABB_$LI$() { if (GameSingleThread.worldAABB == null)
            GameSingleThread.worldAABB = new org.jbox2d.collision.AABB(new org.jbox2d.common.Vec2(game.GameConstants.aabbMinX, game.GameConstants.aabbMinY), new org.jbox2d.common.Vec2(game.GameConstants.aabbMaxX, game.GameConstants.aabbMaxY)); return GameSingleThread.worldAABB; }
        ;
        static gravity_$LI$() { if (GameSingleThread.gravity == null)
            GameSingleThread.gravity = new org.jbox2d.common.Vec2(0, game.GameConstants.gravityMagnitude); return GameSingleThread.gravity; }
        ;
        static rFootPos_$LI$() { if (GameSingleThread.rFootPos == null)
            GameSingleThread.rFootPos = new org.jbox2d.common.Vec2(game.GameConstants.rFootPosX, game.GameConstants.rFootPosY); return GameSingleThread.rFootPos; }
        ;
        static lFootPos_$LI$() { if (GameSingleThread.lFootPos == null)
            GameSingleThread.lFootPos = new org.jbox2d.common.Vec2(game.GameConstants.lFootPosX, game.GameConstants.lFootPosY); return GameSingleThread.lFootPos; }
        ;
        static rCalfPos_$LI$() { if (GameSingleThread.rCalfPos == null)
            GameSingleThread.rCalfPos = new org.jbox2d.common.Vec2(game.GameConstants.rCalfPosX, game.GameConstants.rCalfPosY); return GameSingleThread.rCalfPos; }
        ;
        static lCalfPos_$LI$() { if (GameSingleThread.lCalfPos == null)
            GameSingleThread.lCalfPos = new org.jbox2d.common.Vec2(game.GameConstants.lCalfPosX, game.GameConstants.lCalfPosY); return GameSingleThread.lCalfPos; }
        ;
        static rThighPos_$LI$() { if (GameSingleThread.rThighPos == null)
            GameSingleThread.rThighPos = new org.jbox2d.common.Vec2(game.GameConstants.rThighPosX, game.GameConstants.rThighPosY); return GameSingleThread.rThighPos; }
        ;
        static lThighPos_$LI$() { if (GameSingleThread.lThighPos == null)
            GameSingleThread.lThighPos = new org.jbox2d.common.Vec2(game.GameConstants.lThighPosX, game.GameConstants.lThighPosY); return GameSingleThread.lThighPos; }
        ;
        static torsoPos_$LI$() { if (GameSingleThread.torsoPos == null)
            GameSingleThread.torsoPos = new org.jbox2d.common.Vec2(game.GameConstants.torsoPosX, game.GameConstants.torsoPosY); return GameSingleThread.torsoPos; }
        ;
        static headPos_$LI$() { if (GameSingleThread.headPos == null)
            GameSingleThread.headPos = new org.jbox2d.common.Vec2(game.GameConstants.headPosX, game.GameConstants.headPosY); return GameSingleThread.headPos; }
        ;
        static rUArmPos_$LI$() { if (GameSingleThread.rUArmPos == null)
            GameSingleThread.rUArmPos = new org.jbox2d.common.Vec2(game.GameConstants.rUArmPosX, game.GameConstants.rUArmPosY); return GameSingleThread.rUArmPos; }
        ;
        static lUArmPos_$LI$() { if (GameSingleThread.lUArmPos == null)
            GameSingleThread.lUArmPos = new org.jbox2d.common.Vec2(game.GameConstants.lUArmPosX, game.GameConstants.lUArmPosY); return GameSingleThread.lUArmPos; }
        ;
        static rLArmPos_$LI$() { if (GameSingleThread.rLArmPos == null)
            GameSingleThread.rLArmPos = new org.jbox2d.common.Vec2(game.GameConstants.rLArmPosX, game.GameConstants.rLArmPosY); return GameSingleThread.rLArmPos; }
        ;
        static lLArmPos_$LI$() { if (GameSingleThread.lLArmPos == null)
            GameSingleThread.lLArmPos = new org.jbox2d.common.Vec2(game.GameConstants.lLArmPosX, game.GameConstants.lLArmPosY); return GameSingleThread.lLArmPos; }
        ;
        static rAnklePos_$LI$() { if (GameSingleThread.rAnklePos == null)
            GameSingleThread.rAnklePos = new org.jbox2d.common.Vec2(game.GameConstants.rAnklePosX, game.GameConstants.rAnklePosY); return GameSingleThread.rAnklePos; }
        ;
        static lAnklePos_$LI$() { if (GameSingleThread.lAnklePos == null)
            GameSingleThread.lAnklePos = new org.jbox2d.common.Vec2(game.GameConstants.lAnklePosX, game.GameConstants.lAnklePosY); return GameSingleThread.lAnklePos; }
        ;
        static rKneePos_$LI$() { if (GameSingleThread.rKneePos == null)
            GameSingleThread.rKneePos = new org.jbox2d.common.Vec2(game.GameConstants.rKneePosX, game.GameConstants.rKneePosY); return GameSingleThread.rKneePos; }
        ;
        static lKneePos_$LI$() { if (GameSingleThread.lKneePos == null)
            GameSingleThread.lKneePos = new org.jbox2d.common.Vec2(game.GameConstants.lKneePosX, game.GameConstants.lKneePosY); return GameSingleThread.lKneePos; }
        ;
        static rHipPos_$LI$() { if (GameSingleThread.rHipPos == null)
            GameSingleThread.rHipPos = new org.jbox2d.common.Vec2(game.GameConstants.rHipPosX, game.GameConstants.rHipPosY); return GameSingleThread.rHipPos; }
        ;
        static lHipPos_$LI$() { if (GameSingleThread.lHipPos == null)
            GameSingleThread.lHipPos = new org.jbox2d.common.Vec2(game.GameConstants.lHipPosX, game.GameConstants.lHipPosY); return GameSingleThread.lHipPos; }
        ;
        static rShoulderPos_$LI$() { if (GameSingleThread.rShoulderPos == null)
            GameSingleThread.rShoulderPos = new org.jbox2d.common.Vec2(game.GameConstants.rShoulderPosX, game.GameConstants.rShoulderPosY); return GameSingleThread.rShoulderPos; }
        ;
        static lShoulderPos_$LI$() { if (GameSingleThread.lShoulderPos == null)
            GameSingleThread.lShoulderPos = new org.jbox2d.common.Vec2(game.GameConstants.lShoulderPosX, game.GameConstants.lShoulderPosY); return GameSingleThread.lShoulderPos; }
        ;
        static rElbowPos_$LI$() { if (GameSingleThread.rElbowPos == null)
            GameSingleThread.rElbowPos = new org.jbox2d.common.Vec2(game.GameConstants.rElbowPosX, game.GameConstants.rElbowPosY); return GameSingleThread.rElbowPos; }
        ;
        static lElbowPos_$LI$() { if (GameSingleThread.lElbowPos == null)
            GameSingleThread.lElbowPos = new org.jbox2d.common.Vec2(game.GameConstants.lElbowPosX, game.GameConstants.lElbowPosY); return GameSingleThread.lElbowPos; }
        ;
        static neckPos_$LI$() { if (GameSingleThread.neckPos == null)
            GameSingleThread.neckPos = new org.jbox2d.common.Vec2(game.GameConstants.neckPosX, game.GameConstants.neckPosY); return GameSingleThread.neckPos; }
        ;
        static shapeList_$LI$() { if (GameSingleThread.shapeList == null)
            GameSingleThread.shapeList = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(13); return GameSingleThread.shapeList; }
        ;
        static trackDef_$LI$() { if (GameSingleThread.trackDef == null)
            GameSingleThread.trackDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.trackDef; }
        ;
        static rFootDef_$LI$() { if (GameSingleThread.rFootDef == null)
            GameSingleThread.rFootDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.rFootDef; }
        ;
        static lFootDef_$LI$() { if (GameSingleThread.lFootDef == null)
            GameSingleThread.lFootDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.lFootDef; }
        ;
        static rCalfDef_$LI$() { if (GameSingleThread.rCalfDef == null)
            GameSingleThread.rCalfDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.rCalfDef; }
        ;
        static lCalfDef_$LI$() { if (GameSingleThread.lCalfDef == null)
            GameSingleThread.lCalfDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.lCalfDef; }
        ;
        static rThighDef_$LI$() { if (GameSingleThread.rThighDef == null)
            GameSingleThread.rThighDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.rThighDef; }
        ;
        static lThighDef_$LI$() { if (GameSingleThread.lThighDef == null)
            GameSingleThread.lThighDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.lThighDef; }
        ;
        static torsoDef_$LI$() { if (GameSingleThread.torsoDef == null)
            GameSingleThread.torsoDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.torsoDef; }
        ;
        static headDef_$LI$() { if (GameSingleThread.headDef == null)
            GameSingleThread.headDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.headDef; }
        ;
        static rUArmDef_$LI$() { if (GameSingleThread.rUArmDef == null)
            GameSingleThread.rUArmDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.rUArmDef; }
        ;
        static lUArmDef_$LI$() { if (GameSingleThread.lUArmDef == null)
            GameSingleThread.lUArmDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.lUArmDef; }
        ;
        static rLArmDef_$LI$() { if (GameSingleThread.rLArmDef == null)
            GameSingleThread.rLArmDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.rLArmDef; }
        ;
        static lLArmDef_$LI$() { if (GameSingleThread.lLArmDef == null)
            GameSingleThread.lLArmDef = new org.jbox2d.dynamics.BodyDef(); return GameSingleThread.lLArmDef; }
        ;
        static trackShape_$LI$() { if (GameSingleThread.trackShape == null)
            GameSingleThread.trackShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.trackShape; }
        ;
        static rFootShape_$LI$() { if (GameSingleThread.rFootShape == null)
            GameSingleThread.rFootShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.rFootShape; }
        ;
        static lFootShape_$LI$() { if (GameSingleThread.lFootShape == null)
            GameSingleThread.lFootShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.lFootShape; }
        ;
        static rCalfShape_$LI$() { if (GameSingleThread.rCalfShape == null)
            GameSingleThread.rCalfShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.rCalfShape; }
        ;
        static lCalfShape_$LI$() { if (GameSingleThread.lCalfShape == null)
            GameSingleThread.lCalfShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.lCalfShape; }
        ;
        static rThighShape_$LI$() { if (GameSingleThread.rThighShape == null)
            GameSingleThread.rThighShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.rThighShape; }
        ;
        static lThighShape_$LI$() { if (GameSingleThread.lThighShape == null)
            GameSingleThread.lThighShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.lThighShape; }
        ;
        static torsoShape_$LI$() { if (GameSingleThread.torsoShape == null)
            GameSingleThread.torsoShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.torsoShape; }
        ;
        static rUArmShape_$LI$() { if (GameSingleThread.rUArmShape == null)
            GameSingleThread.rUArmShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.rUArmShape; }
        ;
        static lUArmShape_$LI$() { if (GameSingleThread.lUArmShape == null)
            GameSingleThread.lUArmShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.lUArmShape; }
        ;
        static rLArmShape_$LI$() { if (GameSingleThread.rLArmShape == null)
            GameSingleThread.rLArmShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.rLArmShape; }
        ;
        static lLArmShape_$LI$() { if (GameSingleThread.lLArmShape == null)
            GameSingleThread.lLArmShape = new org.jbox2d.collision.shapes.PolygonDef(); return GameSingleThread.lLArmShape; }
        ;
        static headShape_$LI$() { if (GameSingleThread.headShape == null)
            GameSingleThread.headShape = new org.jbox2d.collision.shapes.CircleDef(); return GameSingleThread.headShape; }
        ;
        static rFootMassData_$LI$() { if (GameSingleThread.rFootMassData == null)
            GameSingleThread.rFootMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.rFootMassData; }
        ;
        static lFootMassData_$LI$() { if (GameSingleThread.lFootMassData == null)
            GameSingleThread.lFootMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.lFootMassData; }
        ;
        static rCalfMassData_$LI$() { if (GameSingleThread.rCalfMassData == null)
            GameSingleThread.rCalfMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.rCalfMassData; }
        ;
        static lCalfMassData_$LI$() { if (GameSingleThread.lCalfMassData == null)
            GameSingleThread.lCalfMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.lCalfMassData; }
        ;
        static rThighMassData_$LI$() { if (GameSingleThread.rThighMassData == null)
            GameSingleThread.rThighMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.rThighMassData; }
        ;
        static lThighMassData_$LI$() { if (GameSingleThread.lThighMassData == null)
            GameSingleThread.lThighMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.lThighMassData; }
        ;
        static torsoMassData_$LI$() { if (GameSingleThread.torsoMassData == null)
            GameSingleThread.torsoMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.torsoMassData; }
        ;
        static headMassData_$LI$() { if (GameSingleThread.headMassData == null)
            GameSingleThread.headMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.headMassData; }
        ;
        static rUArmMassData_$LI$() { if (GameSingleThread.rUArmMassData == null)
            GameSingleThread.rUArmMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.rUArmMassData; }
        ;
        static lUArmMassData_$LI$() { if (GameSingleThread.lUArmMassData == null)
            GameSingleThread.lUArmMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.lUArmMassData; }
        ;
        static rLArmMassData_$LI$() { if (GameSingleThread.rLArmMassData == null)
            GameSingleThread.rLArmMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.rLArmMassData; }
        ;
        static lLArmMassData_$LI$() { if (GameSingleThread.lLArmMassData == null)
            GameSingleThread.lLArmMassData = new org.jbox2d.collision.MassData(); return GameSingleThread.lLArmMassData; }
        ;
        static initState_$LI$() { if (GameSingleThread.initState == null)
            GameSingleThread.initState = new GameSingleThread().getCurrentState(); return GameSingleThread.initState; }
        ;
        /**
         * Call once to initialize a lot of shape definitions which only need to be created once.
         * @private
         */
        oneTimeSetup() {
            GameSingleThread.trackDef_$LI$().position = new org.jbox2d.common.Vec2(game.GameConstants.trackPosX, game.GameConstants.trackPosY);
            GameSingleThread.trackShape_$LI$().setAsBox$float$float(game.GameConstants.trackXDim, game.GameConstants.trackYDim);
            GameSingleThread.trackShape_$LI$().restitution = game.GameConstants.trackRest;
            GameSingleThread.trackShape_$LI$().friction = game.GameConstants.trackFric;
            GameSingleThread.trackShape_$LI$().filter.groupIndex = 1;
            GameSingleThread.rFootShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.rFootL / 2.0), Math.fround(game.GameConstants.rFootH / 2.0));
            GameSingleThread.lFootShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.lFootL / 2.0), Math.fround(game.GameConstants.lFootH / 2.0));
            GameSingleThread.rFootShape_$LI$().friction = (game.GameConstants.rFootFric);
            GameSingleThread.lFootShape_$LI$().friction = (game.GameConstants.lFootFric);
            GameSingleThread.rFootShape_$LI$().density = game.GameConstants.rFootDensity;
            GameSingleThread.lFootShape_$LI$().density = game.GameConstants.lFootDensity;
            GameSingleThread.rFootShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.lFootShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.rFootDef_$LI$().position = GameSingleThread.rFootPos_$LI$();
            GameSingleThread.rFootDef_$LI$().angle = game.GameConstants.rFootAng;
            GameSingleThread.lFootDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.lFootPos_$LI$());
            GameSingleThread.lFootDef_$LI$().angle = game.GameConstants.lFootAng;
            GameSingleThread.rFootMassData_$LI$().mass = game.GameConstants.rFootMass;
            GameSingleThread.rFootMassData_$LI$().I = game.GameConstants.rFootInertia;
            GameSingleThread.rFootDef_$LI$().massData = GameSingleThread.rFootMassData_$LI$();
            GameSingleThread.lFootMassData_$LI$().mass = game.GameConstants.lFootMass;
            GameSingleThread.lFootMassData_$LI$().I = game.GameConstants.lFootInertia;
            GameSingleThread.lFootDef_$LI$().massData = GameSingleThread.lFootMassData_$LI$();
            GameSingleThread.rCalfShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.rCalfW / 2.0), Math.fround(game.GameConstants.rCalfL / 2.0));
            GameSingleThread.lCalfShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.lCalfW / 2.0), Math.fround(game.GameConstants.lCalfL / 2.0));
            GameSingleThread.rCalfShape_$LI$().friction = game.GameConstants.rCalfFric;
            GameSingleThread.lCalfShape_$LI$().friction = game.GameConstants.lCalfFric;
            GameSingleThread.rCalfShape_$LI$().density = game.GameConstants.rCalfDensity;
            GameSingleThread.lCalfShape_$LI$().density = game.GameConstants.lCalfDensity;
            GameSingleThread.rCalfShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.lCalfShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.rCalfDef_$LI$().position = (GameSingleThread.rCalfPos_$LI$());
            GameSingleThread.rCalfDef_$LI$().angle = Math.fround(game.GameConstants.rCalfAng + game.GameConstants.rCalfAngAdj);
            GameSingleThread.lCalfDef_$LI$().position = (GameSingleThread.lCalfPos_$LI$());
            GameSingleThread.lCalfDef_$LI$().angle = Math.fround(game.GameConstants.lCalfAng + game.GameConstants.lCalfAngAdj);
            GameSingleThread.rCalfMassData_$LI$().I = game.GameConstants.rCalfInertia;
            GameSingleThread.rCalfMassData_$LI$().mass = game.GameConstants.rCalfMass;
            GameSingleThread.lCalfMassData_$LI$().I = game.GameConstants.lCalfInertia;
            GameSingleThread.lCalfMassData_$LI$().mass = game.GameConstants.lCalfMass;
            GameSingleThread.rCalfDef_$LI$().massData = GameSingleThread.rCalfMassData_$LI$();
            GameSingleThread.lCalfDef_$LI$().massData = GameSingleThread.lCalfMassData_$LI$();
            GameSingleThread.rThighShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.rThighW / 2.0), Math.fround(game.GameConstants.rThighL / 2.0));
            GameSingleThread.lThighShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.lThighW / 2.0), Math.fround(game.GameConstants.lThighL / 2.0));
            GameSingleThread.rThighShape_$LI$().friction = game.GameConstants.rThighFric;
            GameSingleThread.lThighShape_$LI$().friction = game.GameConstants.lThighFric;
            GameSingleThread.rThighShape_$LI$().density = game.GameConstants.rThighDensity;
            GameSingleThread.lThighShape_$LI$().density = game.GameConstants.lThighDensity;
            GameSingleThread.rThighShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.lThighShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.rThighDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.rThighPos_$LI$());
            GameSingleThread.lThighDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.lThighPos_$LI$());
            GameSingleThread.rThighDef_$LI$().angle = Math.fround(game.GameConstants.rThighAng + game.GameConstants.rThighAngAdj);
            GameSingleThread.lThighDef_$LI$().angle = Math.fround(game.GameConstants.lThighAng + game.GameConstants.lThighAngAdj);
            GameSingleThread.rThighMassData_$LI$().I = game.GameConstants.rThighInertia;
            GameSingleThread.rThighMassData_$LI$().mass = game.GameConstants.rThighMass;
            GameSingleThread.lThighMassData_$LI$().I = game.GameConstants.lThighInertia;
            GameSingleThread.lThighMassData_$LI$().mass = game.GameConstants.lThighMass;
            GameSingleThread.rThighDef_$LI$().massData = GameSingleThread.rThighMassData_$LI$();
            GameSingleThread.lThighDef_$LI$().massData = GameSingleThread.lThighMassData_$LI$();
            GameSingleThread.torsoShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.torsoW / 2.0), Math.fround(game.GameConstants.torsoL / 2.0));
            GameSingleThread.torsoShape_$LI$().friction = game.GameConstants.torsoFric;
            GameSingleThread.torsoShape_$LI$().density = game.GameConstants.torsoDensity;
            GameSingleThread.torsoShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.torsoDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.torsoPos_$LI$());
            GameSingleThread.torsoDef_$LI$().angle = Math.fround(game.GameConstants.torsoAng + game.GameConstants.torsoAngAdj);
            GameSingleThread.torsoMassData_$LI$().I = game.GameConstants.torsoInertia;
            GameSingleThread.torsoMassData_$LI$().mass = game.GameConstants.torsoMass;
            GameSingleThread.torsoDef_$LI$().massData = GameSingleThread.torsoMassData_$LI$();
            GameSingleThread.headShape_$LI$().radius = (game.GameConstants.headR);
            GameSingleThread.headShape_$LI$().friction = game.GameConstants.headFric;
            GameSingleThread.headShape_$LI$().density = game.GameConstants.headDensity;
            GameSingleThread.headShape_$LI$().restitution = 0.0;
            GameSingleThread.headShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.headDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.headPos_$LI$());
            GameSingleThread.headDef_$LI$().angle = Math.fround(game.GameConstants.headAng + game.GameConstants.headAngAdj);
            GameSingleThread.headMassData_$LI$().I = game.GameConstants.headInertia;
            GameSingleThread.headMassData_$LI$().mass = game.GameConstants.headMass;
            GameSingleThread.headDef_$LI$().massData = GameSingleThread.headMassData_$LI$();
            GameSingleThread.rUArmShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.rUArmW / 2.0), Math.fround(game.GameConstants.rUArmL / 2.0));
            GameSingleThread.lUArmShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.lUArmW / 2.0), Math.fround(game.GameConstants.lUArmL / 2.0));
            GameSingleThread.rUArmShape_$LI$().friction = game.GameConstants.rUArmFric;
            GameSingleThread.lUArmShape_$LI$().friction = game.GameConstants.lUArmFric;
            GameSingleThread.rUArmShape_$LI$().density = game.GameConstants.rUArmDensity;
            GameSingleThread.lUArmShape_$LI$().density = game.GameConstants.lUArmDensity;
            GameSingleThread.rUArmShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.lUArmShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.rUArmDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.rUArmPos_$LI$());
            GameSingleThread.lUArmDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.lUArmPos_$LI$());
            GameSingleThread.rUArmDef_$LI$().angle = Math.fround(game.GameConstants.rUArmAng + game.GameConstants.rUArmAngAdj);
            GameSingleThread.lUArmDef_$LI$().angle = Math.fround(game.GameConstants.lUArmAng + game.GameConstants.lUArmAngAdj);
            GameSingleThread.rUArmMassData_$LI$().I = game.GameConstants.rUArmInertia;
            GameSingleThread.rUArmMassData_$LI$().mass = game.GameConstants.rUArmMass;
            GameSingleThread.lUArmMassData_$LI$().I = game.GameConstants.lUArmInertia;
            GameSingleThread.lUArmMassData_$LI$().mass = game.GameConstants.lUArmMass;
            GameSingleThread.rUArmDef_$LI$().massData = GameSingleThread.rUArmMassData_$LI$();
            GameSingleThread.lUArmDef_$LI$().massData = GameSingleThread.lUArmMassData_$LI$();
            GameSingleThread.rLArmShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.rLArmW / 2.0), Math.fround(game.GameConstants.rLArmL / 2.0));
            GameSingleThread.lLArmShape_$LI$().setAsBox$float$float(Math.fround(game.GameConstants.lLArmW / 2.0), Math.fround(game.GameConstants.lLArmL / 2.0));
            GameSingleThread.rLArmShape_$LI$().friction = game.GameConstants.rLArmFric;
            GameSingleThread.lLArmShape_$LI$().friction = game.GameConstants.lLArmFric;
            GameSingleThread.rLArmShape_$LI$().density = game.GameConstants.rLArmDensity;
            GameSingleThread.lLArmShape_$LI$().density = game.GameConstants.lLArmDensity;
            GameSingleThread.rLArmShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.lLArmShape_$LI$().filter.groupIndex = this.BODY_GROUP;
            GameSingleThread.rLArmDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.rLArmPos_$LI$());
            GameSingleThread.lLArmDef_$LI$().position.set$org_jbox2d_common_Vec2(GameSingleThread.lLArmPos_$LI$());
            GameSingleThread.rLArmDef_$LI$().angle = Math.fround(game.GameConstants.rLArmAng + game.GameConstants.rLArmAngAdj);
            GameSingleThread.lLArmDef_$LI$().angle = Math.fround(game.GameConstants.lLArmAng + game.GameConstants.lLArmAngAdj);
            GameSingleThread.rLArmMassData_$LI$().I = game.GameConstants.rLArmInertia;
            GameSingleThread.rLArmMassData_$LI$().mass = game.GameConstants.rLArmMass;
            GameSingleThread.lLArmMassData_$LI$().I = game.GameConstants.lLArmInertia;
            GameSingleThread.lLArmMassData_$LI$().mass = game.GameConstants.lLArmMass;
            GameSingleThread.rLArmDef_$LI$().massData = GameSingleThread.rLArmMassData_$LI$();
            GameSingleThread.lLArmDef_$LI$().massData = GameSingleThread.lLArmMassData_$LI$();
        }
        makeNewWorld() {
            this.isFailed = false;
            GameSingleThread.timestepsSimulated = 0;
            this.m_world = new org.jbox2d.dynamics.World(GameSingleThread.worldAABB_$LI$(), GameSingleThread.gravity_$LI$(), true);
            this.m_world.setWarmStarting(true);
            this.m_world.setPositionCorrection(true);
            this.m_world.setContinuousPhysics(true);
            this.trackBody = this.m_world.createBody(GameSingleThread.trackDef_$LI$());
            this.trackBody.createShape(GameSingleThread.trackShape_$LI$());
            if (!GameSingleThread.noFeet) {
                this.rFootBody = this.getWorld().createBody(GameSingleThread.rFootDef_$LI$());
                this.lFootBody = this.getWorld().createBody(GameSingleThread.lFootDef_$LI$());
                this.rFootBody.createShape(GameSingleThread.rFootShape_$LI$());
                this.lFootBody.createShape(GameSingleThread.lFootShape_$LI$());
            }
            this.rCalfBody = this.getWorld().createBody(GameSingleThread.rCalfDef_$LI$());
            this.lCalfBody = this.getWorld().createBody(GameSingleThread.lCalfDef_$LI$());
            this.rCalfBody.createShape(GameSingleThread.rCalfShape_$LI$());
            this.lCalfBody.createShape(GameSingleThread.lCalfShape_$LI$());
            this.rThighBody = this.getWorld().createBody(GameSingleThread.rThighDef_$LI$());
            this.lThighBody = this.getWorld().createBody(GameSingleThread.lThighDef_$LI$());
            this.rThighBody.createShape(GameSingleThread.rThighShape_$LI$());
            this.lThighBody.createShape(GameSingleThread.lThighShape_$LI$());
            this.rUArmBody = this.getWorld().createBody(GameSingleThread.rUArmDef_$LI$());
            this.lUArmBody = this.getWorld().createBody(GameSingleThread.lUArmDef_$LI$());
            this.rUArmBody.createShape(GameSingleThread.rUArmShape_$LI$());
            this.lUArmBody.createShape(GameSingleThread.lUArmShape_$LI$());
            this.rLArmBody = this.getWorld().createBody(GameSingleThread.rLArmDef_$LI$());
            this.lLArmBody = this.getWorld().createBody(GameSingleThread.lLArmDef_$LI$());
            this.rLArmBody.createShape(GameSingleThread.rLArmShape_$LI$());
            this.lLArmBody.createShape(GameSingleThread.lLArmShape_$LI$());
            this.torsoBody = this.getWorld().createBody(GameSingleThread.torsoDef_$LI$());
            this.torsoBody.createShape(GameSingleThread.torsoShape_$LI$());
            this.headBody = this.getWorld().createBody(GameSingleThread.headDef_$LI$());
            this.headBody.createShape(GameSingleThread.headShape_$LI$());
            if (!GameSingleThread.noFeet) {
                this.rAnkleJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
                this.rAnkleJDef.initialize(this.rFootBody, this.rCalfBody, GameSingleThread.rAnklePos_$LI$());
                this.rAnkleJDef.enableLimit = true;
                this.rAnkleJDef.upperAngle = 0.5;
                this.rAnkleJDef.lowerAngle = -0.5;
                this.rAnkleJDef.enableMotor = false;
                this.rAnkleJDef.maxMotorTorque = 2000.0;
                this.rAnkleJDef.motorSpeed = 0.0;
                this.rAnkleJDef.collideConnected = false;
                this.rAnkleJ = this.getWorld().createJoint(this.rAnkleJDef);
                this.lAnkleJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
                this.lAnkleJDef.initialize(this.lFootBody, this.lCalfBody, GameSingleThread.lAnklePos_$LI$());
                this.lAnkleJDef.enableLimit = true;
                this.lAnkleJDef.upperAngle = 0.5;
                this.lAnkleJDef.lowerAngle = -0.5;
                this.lAnkleJDef.enableMotor = false;
                this.lAnkleJDef.maxMotorTorque = 2000.0;
                this.lAnkleJDef.motorSpeed = 0.0;
                this.lAnkleJDef.collideConnected = false;
                this.lAnkleJ = this.getWorld().createJoint(this.lAnkleJDef);
            }
            this.rKneeJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.rKneeJDef.initialize(this.rCalfBody, this.rThighBody, GameSingleThread.rKneePos_$LI$());
            this.rKneeJDef.enableLimit = true;
            this.rKneeJDef.upperAngle = 0.3;
            this.rKneeJDef.lowerAngle = -1.3;
            this.rKneeJDef.enableMotor = true;
            this.rKneeJDef.maxMotorTorque = 3000.0;
            this.rKneeJDef.motorSpeed = 0.0;
            this.rKneeJDef.collideConnected = false;
            this.rKneeJ = this.getWorld().createJoint(this.rKneeJDef);
            this.lKneeJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.lKneeJDef.initialize(this.lCalfBody, this.lThighBody, GameSingleThread.lKneePos_$LI$());
            this.lKneeJDef.enableLimit = true;
            this.lKneeJDef.upperAngle = 0.0;
            this.lKneeJDef.lowerAngle = -1.6;
            this.lKneeJDef.enableMotor = true;
            this.lKneeJDef.maxMotorTorque = 3000.0;
            this.lKneeJDef.motorSpeed = 0.0;
            this.lKneeJDef.collideConnected = false;
            this.lKneeJ = this.getWorld().createJoint(this.lKneeJDef);
            this.rHipJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.rHipJDef.initialize(this.rThighBody, this.torsoBody, GameSingleThread.rHipPos_$LI$());
            this.rHipJDef.enableLimit = true;
            this.rHipJDef.upperAngle = 0.7;
            this.rHipJDef.lowerAngle = -1.3;
            this.rHipJDef.enableMotor = true;
            this.rHipJDef.motorSpeed = 0.0;
            this.rHipJDef.maxMotorTorque = 6000.0;
            this.rHipJDef.collideConnected = false;
            this.rHipJ = this.getWorld().createJoint(this.rHipJDef);
            this.lHipJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.lHipJDef.initialize(this.lThighBody, this.torsoBody, GameSingleThread.lHipPos_$LI$());
            this.lHipJDef.enableLimit = true;
            this.lHipJDef.upperAngle = 0.5;
            this.lHipJDef.lowerAngle = -1.5;
            this.lHipJDef.enableMotor = true;
            this.lHipJDef.motorSpeed = 0.0;
            this.lHipJDef.maxMotorTorque = 6000.0;
            this.lHipJDef.collideConnected = false;
            this.lHipJ = this.getWorld().createJoint(this.lHipJDef);
            this.neckJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.neckJDef.initialize(this.headBody, this.torsoBody, GameSingleThread.neckPos_$LI$());
            this.neckJDef.enableLimit = true;
            this.neckJDef.upperAngle = 0.0;
            this.neckJDef.lowerAngle = -0.5;
            this.neckJDef.enableMotor = true;
            this.neckJDef.maxMotorTorque = 1000.0;
            this.neckJDef.motorSpeed = 0.0;
            this.neckJDef.collideConnected = false;
            this.neckJ = this.getWorld().createJoint(this.neckJDef);
            let rUFake = this.getWorld().createBody(GameSingleThread.rUArmDef_$LI$());
            rUFake.createShape(GameSingleThread.rUArmShape_$LI$());
            this.rShoulderJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.rShoulderJDef.initialize(this.rUArmBody, this.torsoBody, GameSingleThread.rShoulderPos_$LI$());
            this.rShoulderJDef.enableLimit = true;
            this.rShoulderJDef.upperAngle = 1.5;
            this.rShoulderJDef.lowerAngle = -0.5;
            this.rShoulderJDef.enableMotor = true;
            this.rShoulderJDef.maxMotorTorque = 1000.0;
            this.rShoulderJDef.motorSpeed = 0.0;
            this.rShoulderJDef.collideConnected = false;
            this.rShoulderJ = this.getWorld().createJoint(this.rShoulderJDef);
            this.lShoulderJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.lShoulderJDef.initialize(this.lUArmBody, this.torsoBody, GameSingleThread.lShoulderPos_$LI$());
            this.lShoulderJDef.enableLimit = true;
            this.lShoulderJDef.upperAngle = 0.0;
            this.lShoulderJDef.lowerAngle = -2.0;
            this.lShoulderJDef.enableMotor = true;
            this.lShoulderJDef.maxMotorTorque = 1000.0;
            this.lShoulderJDef.motorSpeed = 0.0;
            this.lShoulderJDef.collideConnected = false;
            this.lShoulderJ = this.getWorld().createJoint(this.lShoulderJDef);
            this.rElbowJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.rElbowJDef.initialize(this.rLArmBody, this.rUArmBody, GameSingleThread.rElbowPos_$LI$());
            this.rElbowJDef.enableLimit = true;
            this.rElbowJDef.upperAngle = 0.5;
            this.rElbowJDef.lowerAngle = -0.1;
            this.rElbowJDef.enableMotor = true;
            this.rElbowJDef.maxMotorTorque = 0.0;
            this.rElbowJDef.motorSpeed = 10.0;
            this.rElbowJDef.collideConnected = false;
            this.rElbowJ = this.getWorld().createJoint(this.rElbowJDef);
            this.lElbowJDef = new org.jbox2d.dynamics.joints.RevoluteJointDef();
            this.lElbowJDef.initialize(this.lLArmBody, this.lUArmBody, GameSingleThread.lElbowPos_$LI$());
            this.lElbowJDef.enableLimit = true;
            this.lElbowJDef.upperAngle = 0.5;
            this.lElbowJDef.lowerAngle = -0.1;
            this.lElbowJDef.enableMotor = true;
            this.lElbowJDef.maxMotorTorque = 0.0;
            this.lElbowJDef.motorSpeed = 10.0;
            this.lElbowJDef.collideConnected = false;
            this.lElbowJ = this.getWorld().createJoint(this.lElbowJDef);
            if (GameSingleThread.shapeList_$LI$()[0] == null) {
                GameSingleThread.shapeList_$LI$()[0] = this.torsoBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[1] = this.headBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[2] = this.rFootBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[3] = this.lFootBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[4] = this.rCalfBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[5] = this.lCalfBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[6] = this.rThighBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[7] = this.lThighBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[8] = this.rUArmBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[9] = this.lUArmBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[10] = this.rLArmBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[11] = this.lLArmBody.getShapeList();
                GameSingleThread.shapeList_$LI$()[12] = this.trackBody.getShapeList();
            }
        }
        setMaxMotorTorque(torqueLimitMultiplier) {
            if (!GameSingleThread.noFeet) {
                this.rAnkleJ.setMaxMotorTorque(Math.fround(2000.0 * torqueLimitMultiplier));
                this.lAnkleJ.setMaxMotorTorque(Math.fround(2000.0 * torqueLimitMultiplier));
            }
            this.rKneeJ.setMaxMotorTorque(Math.fround(3000.0 * torqueLimitMultiplier));
            this.lKneeJ.setMaxMotorTorque(Math.fround(3000.0 * torqueLimitMultiplier));
            this.rHipJ.setMaxMotorTorque(Math.fround(6000.0 * torqueLimitMultiplier));
            this.lHipJ.setMaxMotorTorque(Math.fround(6000.0 * torqueLimitMultiplier));
            this.neckJ.setMaxMotorTorque(Math.fround(1000.0 * torqueLimitMultiplier));
            this.rShoulderJ.setMaxMotorTorque(Math.fround(1000.0 * torqueLimitMultiplier));
            this.lShoulderJ.setMaxMotorTorque(Math.fround(1000.0 * torqueLimitMultiplier));
            this.rElbowJ.setMaxMotorTorque(0.0);
            this.lElbowJ.setMaxMotorTorque(0.0);
        }
        stepGame$boolean_A(command) {
            if (command.length !== 4) {
                throw Object.defineProperty(new Error("Command is not the correct length. Expected 4, got: " + command.length), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
            }
            this.stepGame$boolean$boolean$boolean$boolean(command[0], command[1], command[2], command[3]);
        }
        stepGame$boolean$boolean$boolean$boolean(q, w, o, p) {
            let NeckTorque = Math.fround(Math.fround(-game.GameConstants.neckStiff * this.neckJ.getJointAngle()) + Math.fround(Math.fround(0 * game.GameConstants.neckDamp) * this.neckJ.getJointSpeed()));
            NeckTorque = Math.fround(NeckTorque + Math.fround(Math.fround(0 * 400.0) * (Math.fround(this.neckJ.getJointAngle() + 0.2))));
            let RElbowTorque = Math.fround(Math.fround(-game.GameConstants.rElbowStiff * this.rElbowJ.getJointAngle()) + Math.fround(Math.fround(0 * game.GameConstants.rElbowDamp) * this.rElbowJ.getJointSpeed()));
            let LElbowTorque = Math.fround(Math.fround(-game.GameConstants.lElbowStiff * this.lElbowJ.getJointAngle()) + Math.fround(Math.fround(0 * game.GameConstants.lElbowDamp) * this.lElbowJ.getJointSpeed()));
            this.neckJ.m_motorSpeed = (Math.fround(1000.0 * (f => { if (f > 0) {
                return 1;
            }
            else if (f < 0) {
                return -1;
            }
            else {
                return 0;
            } })(NeckTorque)));
            this.rElbowJ.m_motorSpeed = (Math.fround(1000.0 * (f => { if (f > 0) {
                return 1;
            }
            else if (f < 0) {
                return -1;
            }
            else {
                return 0;
            } })(RElbowTorque)));
            this.lElbowJ.m_motorSpeed = (Math.fround(1000.0 * (f => { if (f > 0) {
                return 1;
            }
            else if (f < 0) {
                return -1;
            }
            else {
                return 0;
            } })(LElbowTorque)));
            this.neckJ.m_maxMotorTorque = (Math.abs(NeckTorque));
            this.rElbowJ.m_maxMotorTorque = (Math.abs(RElbowTorque));
            this.lElbowJ.m_maxMotorTorque = (Math.abs(LElbowTorque));
            if (q) {
                this.lHipJ.m_motorSpeed = (game.GameConstants.lHipSpeed2);
                this.rHipJ.m_motorSpeed = (game.GameConstants.rHipSpeed2);
                this.lShoulderJ.m_motorSpeed = (game.GameConstants.lShoulderSpeed2);
                this.rShoulderJ.m_motorSpeed = (game.GameConstants.rShoulderSpeed2);
            }
            else if (w) {
                this.lHipJ.m_motorSpeed = (game.GameConstants.lHipSpeed1);
                this.rHipJ.m_motorSpeed = (game.GameConstants.rHipSpeed1);
                this.lShoulderJ.m_motorSpeed = (game.GameConstants.lShoulderSpeed1);
                this.rShoulderJ.m_motorSpeed = (game.GameConstants.rShoulderSpeed1);
            }
            else {
                this.lHipJ.m_motorSpeed = (0.0);
                this.rHipJ.m_motorSpeed = (0.0);
                this.lShoulderJ.m_motorSpeed = (0.0);
                this.rShoulderJ.m_motorSpeed = (0.0);
            }
            if (q || w && !GameSingleThread.noFeet) {
                let RAnkleCur = this.rAnkleJ.getAnchor1();
                let LAnkleCur = this.lAnkleJ.getAnchor1();
                let RHipCur = this.rHipJ.getAnchor1();
                if (RAnkleCur.x < RHipCur.x) {
                    this.rAnkleJ.m_motorSpeed = (game.GameConstants.rAnkleSpeed2);
                }
                else {
                    this.rAnkleJ.m_motorSpeed = (game.GameConstants.rAnkleSpeed1);
                }
                if (LAnkleCur.x < RHipCur.x) {
                    this.lAnkleJ.m_motorSpeed = (game.GameConstants.lAnkleSpeed2);
                }
                else {
                    this.lAnkleJ.m_motorSpeed = (game.GameConstants.lAnkleSpeed1);
                }
            }
            if (o) {
                this.rKneeJ.m_motorSpeed = (game.GameConstants.rKneeSpeed2);
                this.lKneeJ.m_motorSpeed = (game.GameConstants.lKneeSpeed2);
                this.rHipJ.m_lowerAngle = (game.GameConstants.oRHipLimLo);
                this.rHipJ.m_upperAngle = (game.GameConstants.oRHipLimHi);
                this.lHipJ.m_lowerAngle = (game.GameConstants.oLHipLimLo);
                this.lHipJ.m_upperAngle = (game.GameConstants.oLHipLimHi);
            }
            else if (p) {
                this.rKneeJ.m_motorSpeed = (game.GameConstants.rKneeSpeed1);
                this.lKneeJ.m_motorSpeed = (game.GameConstants.lKneeSpeed1);
                this.rHipJ.m_lowerAngle = (game.GameConstants.pRHipLimLo);
                this.rHipJ.m_upperAngle = (game.GameConstants.pRHipLimHi);
                this.lHipJ.m_lowerAngle = game.GameConstants.pLHipLimLo;
                this.lHipJ.m_upperAngle = game.GameConstants.pLHipLimHi;
            }
            else {
                this.rKneeJ.m_motorSpeed = (0.0);
                this.lKneeJ.m_motorSpeed = (0.0);
            }
            this.getWorld().step(game.GameConstants.timestep, game.GameConstants.physIterations);
            let angle = this.torsoBody.getAngle();
            if (angle > game.GameConstants.torsoAngUpper || angle < game.GameConstants.torsoAngLower) {
                this.isFailed = true;
            }
            GameSingleThread.timestepsSimulated++;
        }
        /**
         * Step the game forward 1 timestep with the specified keys pressed.
         * @param {boolean} q
         * @param {boolean} w
         * @param {boolean} o
         * @param {boolean} p
         */
        stepGame(q, w, o, p) {
            if (((typeof q === 'boolean') || q === null) && ((typeof w === 'boolean') || w === null) && ((typeof o === 'boolean') || o === null) && ((typeof p === 'boolean') || p === null)) {
                return this.stepGame$boolean$boolean$boolean$boolean(q, w, o, p);
            }
            else if (((q != null && q instanceof Array && (q.length == 0 || q[0] == null || (typeof q[0] === 'boolean'))) || q === null) && w === undefined && o === undefined && p === undefined) {
                return this.stepGame$boolean_A(q);
            }
            else
                throw new Error('invalid overload');
        }
        /**
         * Get the actual Box2D world.
         * @return {org.jbox2d.dynamics.World}
         */
        getWorld() {
            return this.m_world;
        }
        /**
         * QWOP initial condition. Good way to give the root node a state.
         * @return {game.State}
         */
        static getInitialState() {
            return GameSingleThread.initState_$LI$();
        }
        /**
         * Get the current full state of the runner.
         * @return {game.State}
         */
        getCurrentState() {
            return new game.State(this.getCurrentBodyState(this.torsoBody), this.getCurrentBodyState(this.headBody), this.getCurrentBodyState(this.rThighBody), this.getCurrentBodyState(this.lThighBody), this.getCurrentBodyState(this.rCalfBody), this.getCurrentBodyState(this.lCalfBody), GameSingleThread.noFeet ? new game.StateVariable(0, 0, 0, 0, 0, 0) : this.getCurrentBodyState(this.rFootBody), GameSingleThread.noFeet ? new game.StateVariable(0, 0, 0, 0, 0, 0) : this.getCurrentBodyState(this.lFootBody), this.getCurrentBodyState(this.rUArmBody), this.getCurrentBodyState(this.lUArmBody), this.getCurrentBodyState(this.rLArmBody), this.getCurrentBodyState(this.lLArmBody), this.getFailureStatus());
        }
        /**
         * Get a new StateVariable for a given body.
         * @param {org.jbox2d.dynamics.Body} body
         * @return {game.StateVariable}
         * @private
         */
        getCurrentBodyState(body) {
            let pos = body.getPosition();
            let x = pos.x;
            let y = pos.y;
            let th = body.getAngle();
            let vel = body.getLinearVelocity();
            let dx = vel.x;
            let dy = vel.y;
            let dth = body.getAngularVelocity();
            return new game.StateVariable(x, y, th, dx, dy, dth);
        }
        /**
         * Is this state in failure?
         * @return {boolean}
         */
        getFailureStatus() {
            return this.isFailed;
        }
        /**
         * Get the number of timesteps simulated since the beginning of execution.
         * @return {number}
         */
        getTimestepsSimulated() {
            return GameSingleThread.timestepsSimulated;
        }
        /**
         * Change world gravity.
         *
         * @param {number} xGrav x component of gravity.
         * @param {number} yGrav y component of gravity -- positive is down.
         */
        setGravity(xGrav, yGrav) {
            this.getWorld().setGravity(new org.jbox2d.common.Vec2(xGrav, yGrav));
        }
        setMaxTorqueMultiplier(multiplier) {
            this.setMaxMotorTorque(multiplier);
        }
        setPointFeet(usePointFeet) {
            GameSingleThread.noFeet = usePointFeet;
        }
        setBodyInertiaMultiplier(multiplier) {
            let massData = new org.jbox2d.collision.MassData();
            massData.mass = GameSingleThread.torsoMassData_$LI$().mass;
            massData.I = Math.fround(GameSingleThread.torsoMassData_$LI$().I * multiplier);
            this.torsoBody.setMass(massData);
        }
        /**
         * Apply a disturbance impulse to the body COM.
         * @param {number} xComp
         * @param {number} yComp
         */
        applyBodyImpulse(xComp, yComp) {
            let torsoCenter = this.torsoBody.getWorldCenter();
            this.torsoBody.applyImpulse(new org.jbox2d.common.Vec2(xComp, yComp), torsoCenter);
        }
        /**
         * Apply a disturbance torque to the body.
         * @param {number} cwTorque
         */
        applyBodyTorque(cwTorque) {
            this.torsoBody.applyTorque(cwTorque);
        }
        /**
         * Get vertices for debug drawing. Each array in the list will have:
         * 8 floats for rectangles (x1,y1,x2,y2,...).
         * 3 floats for circles (x,y,radius).
         * 1 float for ground (height).
         * <p>
         * This is primarily for drawing using external tools, e.g. in MATLAB.
         * @return {game.GameSingleThread.VertHolder}
         */
        getDebugVertices() {
            let vertHolder = new GameSingleThread.VertHolder(this);
            vertHolder.groundHeight = org.jbox2d.common.XForm.mul(this.trackBody.getXForm(), /* get */ GameSingleThread.trackShape_$LI$().vertices[0]).y;
            vertHolder.torsoX = this.torsoBody.getPosition().x;
            let bodies;
            if (!GameSingleThread.noFeet) {
                bodies = [this.rFootBody, this.lFootBody, this.rCalfBody, this.lCalfBody, this.rThighBody, this.lThighBody, this.torsoBody, this.rUArmBody, this.lUArmBody, this.rLArmBody, this.lLArmBody];
            }
            else {
                bodies = [this.rCalfBody, this.lCalfBody, this.rThighBody, this.lThighBody, this.torsoBody, this.rUArmBody, this.lUArmBody, this.rLArmBody, this.lLArmBody];
            }
            for (let i = 0; i < bodies.length; i++) {
                {
                    let xf = bodies[i].getXForm();
                    let shape = bodies[i].getShapeList();
                    let shapeVerts = shape.m_vertices;
                    for (let j = 0; j < shapeVerts.length; j++) {
                        {
                            let vert = org.jbox2d.common.XForm.mul(xf, shapeVerts[j]);
                            vertHolder.bodyVerts[i][2 * j] = vert.x;
                            vertHolder.bodyVerts[i][2 * j + 1] = vert.y;
                        }
                        ;
                    }
                }
                ;
            }
            vertHolder.headLocAndRadius[0] = this.headBody.getPosition().x;
            vertHolder.headLocAndRadius[1] = this.headBody.getPosition().y;
            vertHolder.headLocAndRadius[2] = game.GameConstants.headR;
            return vertHolder;
        }
    }
    /**
     * Keep track of sim stats since beginning of execution.
     */
    GameSingleThread.timestepsSimulated = 0;
    GameSingleThread.hasOneTimeInitializationHappened = false;
    GameSingleThread.noFeet = false;
    game.GameSingleThread = GameSingleThread;
    GameSingleThread["__class"] = "game.GameSingleThread";
    (function (GameSingleThread) {
        class VertHolder {
            constructor(__parent) {
                this.__parent = __parent;
                if (this.torsoX === undefined)
                    this.torsoX = 0;
                if (this.groundHeight === undefined)
                    this.groundHeight = 0;
                this.bodyVerts = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                    return 0;
                }
                else {
                    let array = [];
                    for (let i = 0; i < dims[0]; i++) {
                        array.push(allocate(dims.slice(1)));
                    }
                    return array;
                } }; return allocate(dims); })([11, 8]);
                this.headLocAndRadius = [0, 0, 0];
            }
        }
        GameSingleThread.VertHolder = VertHolder;
        VertHolder["__class"] = "game.GameSingleThread.VertHolder";
        /**
         * Listens for collisions involving lower arms and head (implicitly with the ground)
         * @class
         */
        class CollisionListener {
            constructor(__parent) {
                this.__parent = __parent;
                this.rFootDown = false;
                this.lFootDown = false;
            }
            /**
             *
             * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
             */
            add(point) {
                let fixtureA = point.shape1;
                let fixtureB = point.shape2;
                if (((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.headBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.headBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.lLArmBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.lLArmBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.rLArmBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.rLArmBody)) {
                    this.__parent.isFailed = true;
                }
                else if (((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.lThighBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.lThighBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.rThighBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.rThighBody)) {
                    this.__parent.isFailed = true;
                }
                else if (!game.GameSingleThread.noFeet && ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.rFootBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.rFootBody)) {
                    this.rFootDown = true;
                }
                else if (!game.GameSingleThread.noFeet && ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.lFootBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.lFootBody)) {
                    this.lFootDown = true;
                }
            }
            /**
             *
             * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
             */
            persist(point) {
            }
            /**
             *
             * @param {org.jbox2d.dynamics.contacts.ContactPoint} point
             */
            remove(point) {
                let fixtureA = point.shape1;
                let fixtureB = point.shape2;
                if (!game.GameSingleThread.noFeet && ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.rFootBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.rFootBody)) {
                    this.rFootDown = false;
                }
                else if (!game.GameSingleThread.noFeet && ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureA.m_body, this.__parent.lFootBody) || ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(fixtureB.m_body, this.__parent.lFootBody)) {
                    this.lFootDown = false;
                }
            }
            /**
             *
             * @param {org.jbox2d.dynamics.contacts.ContactResult} point
             */
            result(point) {
            }
            /**
             * Check if the right foot is touching the ground.
             * @return {boolean}
             */
            isRightFootGrounded() {
                return this.rFootDown;
            }
            /**
             * Check if the left foot is touching the ground.
             * @return {boolean}
             */
            isLeftFootGrounded() {
                return this.lFootDown;
            }
        }
        GameSingleThread.CollisionListener = CollisionListener;
        CollisionListener["__class"] = "game.GameSingleThread.CollisionListener";
        CollisionListener["__interfaces"] = ["org.jbox2d.dynamics.ContactListener"];
    })(GameSingleThread = game.GameSingleThread || (game.GameSingleThread = {}));
})(game || (game = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class PointAndPolyContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(s1, s2) {
                        if (((s1 != null && s1 instanceof org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                            let __args = arguments;
                            super(s1, s2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                                this.m_manifold.points[0].normalImpulse = 0.0;
                                this.m_manifold.points[0].tangentImpulse = 0.0;
                            })();
                        }
                        else if (s1 === undefined && s2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.Contact}
                     */
                    clone() {
                        let newC = new PointAndPolyContact(this.m_shape1, this.m_shape2);
                        newC.m_manifold.set(this.m_manifold);
                        newC.m_manifoldCount = this.m_manifoldCount;
                        newC.m_world = this.m_world;
                        newC.m_prev = this.m_prev;
                        newC.m_next = this.m_next;
                        newC.m_node1.set(this.m_node1);
                        newC.m_node2.set(this.m_node2);
                        newC.m_friction = this.m_friction;
                        newC.m_restitution = this.m_restitution;
                        newC.m_flags = this.m_flags;
                        return newC;
                    }
                    create(shape1, shape2) {
                        return new PointAndPolyContact(shape1, shape2);
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        let ret = ([]);
                        if (this.m_manifold != null) {
                            /* add */ (ret.push(this.m_manifold) > 0);
                        }
                        return ret;
                    }
                    getFirstManifold() {
                        return this.m_manifold;
                    }
                    static tlm0_$LI$() { if (PointAndPolyContact.tlm0 == null)
                        PointAndPolyContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PointAndPolyContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (PointAndPolyContact.tlV1 == null)
                        PointAndPolyContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointAndPolyContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (PointAndPolyContact.tlCp == null)
                        PointAndPolyContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PointAndPolyContact.tlCp; }
                    ;
                    static tlPersisted_$LI$() { if (PointAndPolyContact.tlPersisted == null)
                        PointAndPolyContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PointAndPolyContact.tlPersisted; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndPolyContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndPolyContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointAndPolyContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolygonAndPoint(this.m_manifold, this.m_shape1, b1.getMemberXForm(), this.m_shape2, b2.getMemberXForm());
                        let persisted = PointAndPolyContact.tlPersisted_$LI$().get(2);
                        persisted[0] = false;
                        persisted[1] = false;
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                                {
                                    let mp = this.m_manifold.points[i];
                                    mp.normalImpulse = 0.0;
                                    mp.tangentImpulse = 0.0;
                                    let found = false;
                                    cp.id.set(mp.id);
                                    for (let j = 0; j < m0.pointCount; ++j) {
                                        {
                                            if (persisted[j] === true) {
                                                continue;
                                            }
                                            let mp0 = m0.points[j];
                                            if (mp0.id.isEqual(cp.id)) {
                                                persisted[j] = true;
                                                mp.normalImpulse = mp0.normalImpulse;
                                                mp.tangentImpulse = mp0.tangentImpulse;
                                                found = true;
                                                if (listener != null) {
                                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                                    cp.velocity.subLocal(v1);
                                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                                    cp.separation = mp.separation;
                                                    listener.persist(cp);
                                                }
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    if (found === false && listener != null) {
                                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                        cp.velocity.subLocal(v1);
                                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                        cp.separation = mp.separation;
                                        listener.add(cp);
                                    }
                                }
                                ;
                            }
                            this.m_manifoldCount = 1;
                        }
                        else {
                            this.m_manifoldCount = 0;
                        }
                        if (listener == null) {
                            return;
                        }
                        for (let i = 0; i < m0.pointCount; ++i) {
                            {
                                if (persisted[i]) {
                                    continue;
                                }
                                let mp0 = m0.points[i];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                            ;
                        }
                    }
                }
                contacts.PointAndPolyContact = PointAndPolyContact;
                PointAndPolyContact["__class"] = "org.jbox2d.dynamics.contacts.PointAndPolyContact";
                PointAndPolyContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class PolyAndCircleContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(s1, s2) {
                        if (((s1 != null && s1 instanceof org.jbox2d.collision.shapes.Shape) || s1 === null) && ((s2 != null && s2 instanceof org.jbox2d.collision.shapes.Shape) || s2 === null)) {
                            let __args = arguments;
                            super(s1, s2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else if (s1 === undefined && s2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.Contact}
                     */
                    clone() {
                        let newC = new PolyAndCircleContact(this.m_shape1, this.m_shape2);
                        newC.m_manifold.set(this.m_manifold);
                        newC.m_manifoldCount = this.m_manifoldCount;
                        newC.m_world = this.m_world;
                        newC.m_prev = this.m_prev;
                        newC.m_next = this.m_next;
                        newC.m_node1.set(this.m_node1);
                        newC.m_node2.set(this.m_node2);
                        newC.m_friction = this.m_friction;
                        newC.m_restitution = this.m_restitution;
                        newC.m_flags = this.m_flags;
                        return newC;
                    }
                    create(shape1, shape2) {
                        return new PolyAndCircleContact(shape1, shape2);
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                    static tlm0_$LI$() { if (PolyAndCircleContact.tlm0 == null)
                        PolyAndCircleContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyAndCircleContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (PolyAndCircleContact.tlV1 == null)
                        PolyAndCircleContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyAndCircleContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (PolyAndCircleContact.tlCp == null)
                        PolyAndCircleContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyAndCircleContact.tlCp; }
                    ;
                    static tlPersisted_$LI$() { if (PolyAndCircleContact.tlPersisted == null)
                        PolyAndCircleContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PolyAndCircleContact.tlPersisted; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndCircleContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndCircleContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndCircleContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollideCircle().collidePolygonAndCircle(this.m_manifold, this.m_shape1, b1.getMemberXForm(), this.m_shape2, b2.getMemberXForm());
                        let persisted = PolyAndCircleContact.tlPersisted_$LI$().get(2);
                        persisted[0] = false;
                        persisted[1] = false;
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                                {
                                    let mp = this.m_manifold.points[i];
                                    mp.normalImpulse = 0.0;
                                    mp.tangentImpulse = 0.0;
                                    let found = false;
                                    let id = mp.id;
                                    for (let j = 0; j < m0.pointCount; ++j) {
                                        {
                                            if (persisted[j] === true) {
                                                continue;
                                            }
                                            let mp0 = m0.points[j];
                                            if (mp0.id.isEqual(id)) {
                                                persisted[j] = true;
                                                mp.normalImpulse = mp0.normalImpulse;
                                                mp.tangentImpulse = mp0.tangentImpulse;
                                                found = true;
                                                if (listener != null) {
                                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                                    cp.velocity.subLocal(v1);
                                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                                    cp.separation = mp.separation;
                                                    cp.id.set(id);
                                                    listener.persist(cp);
                                                }
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    if (found === false && listener != null) {
                                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                        cp.velocity.subLocal(v1);
                                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                        cp.separation = mp.separation;
                                        cp.id.set(id);
                                        listener.add(cp);
                                    }
                                }
                                ;
                            }
                            this.m_manifoldCount = 1;
                        }
                        else {
                            this.m_manifoldCount = 0;
                        }
                        if (listener == null) {
                            return;
                        }
                        for (let i = 0; i < m0.pointCount; ++i) {
                            {
                                if (persisted[i]) {
                                    continue;
                                }
                                let mp0 = m0.points[i];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                            ;
                        }
                    }
                }
                contacts.PolyAndCircleContact = PolyAndCircleContact;
                PolyAndCircleContact["__class"] = "org.jbox2d.dynamics.contacts.PolyAndCircleContact";
                PolyAndCircleContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var contacts;
            (function (contacts) {
                class PolyAndEdgeContact extends org.jbox2d.dynamics.contacts.Contact {
                    constructor(shape1, shape2) {
                        if (((shape1 != null && shape1 instanceof org.jbox2d.collision.shapes.Shape) || shape1 === null) && ((shape2 != null && shape2 instanceof org.jbox2d.collision.shapes.Shape) || shape2 === null)) {
                            let __args = arguments;
                            super(shape1, shape2);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                this.m_manifoldCount = 0;
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                            })();
                        }
                        else if (shape1 === undefined && shape2 === undefined) {
                            let __args = arguments;
                            super();
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            this.manifoldList = ([]);
                            if (this.m_manifold === undefined)
                                this.m_manifold = null;
                            (() => {
                                this.m_manifold = new org.jbox2d.collision.Manifold();
                                /* add */ (this.manifoldList.push(this.m_manifold) > 0);
                                this.m_manifoldCount = 0;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    create(s1, s2) {
                        return new PolyAndEdgeContact(s1, s2);
                    }
                    static Destroy(contact) {
                        contact.destructor();
                    }
                    destructor() {
                    }
                    /**
                     *
                     * @return {org.jbox2d.dynamics.contacts.Contact}
                     */
                    clone() {
                        return this;
                    }
                    static tlm0_$LI$() { if (PolyAndEdgeContact.tlm0 == null)
                        PolyAndEdgeContact.tlm0 = (() => { let __o = new org.jbox2d.pooling.TLManifold(); __o.__delegate = new org.jbox2d.pooling.TLManifold(); return __o; })(); return PolyAndEdgeContact.tlm0; }
                    ;
                    static tlV1_$LI$() { if (PolyAndEdgeContact.tlV1 == null)
                        PolyAndEdgeContact.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolyAndEdgeContact.tlV1; }
                    ;
                    static tlCp_$LI$() { if (PolyAndEdgeContact.tlCp == null)
                        PolyAndEdgeContact.tlCp = (() => { let __o = new org.jbox2d.pooling.TLContactPoint(); __o.__delegate = new org.jbox2d.pooling.TLContactPoint(); return __o; })(); return PolyAndEdgeContact.tlCp; }
                    ;
                    static tlPersisted_$LI$() { if (PolyAndEdgeContact.tlPersisted == null)
                        PolyAndEdgeContact.tlPersisted = new org.jbox2d.pooling.arrays.BooleanArray(); return PolyAndEdgeContact.tlPersisted; }
                    ;
                    /**
                     *
                     * @param {*} listener
                     */
                    evaluate(listener) {
                        let b1 = this.m_shape1.getBody();
                        let b2 = this.m_shape2.getBody();
                        let m0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndEdgeContact.tlm0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndEdgeContact.tlV1_$LI$());
                        let cp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolyAndEdgeContact.tlCp_$LI$());
                        m0.set(this.m_manifold);
                        org.jbox2d.pooling.SingletonPool.getCollidePoly().collidePolyAndEdge(this.m_manifold, this.m_shape1, b1.getMemberXForm(), this.m_shape2, b2.getMemberXForm());
                        let persisted = PolyAndEdgeContact.tlPersisted_$LI$().get(2);
                        persisted[0] = false;
                        persisted[1] = false;
                        cp.shape1 = this.m_shape1;
                        cp.shape2 = this.m_shape2;
                        cp.friction = this.m_friction;
                        cp.restitution = this.m_restitution;
                        if (this.m_manifold.pointCount > 0) {
                            for (let i = 0; i < this.m_manifold.pointCount; ++i) {
                                {
                                    let mp = this.m_manifold.points[i];
                                    mp.normalImpulse = 0.0;
                                    mp.tangentImpulse = 0.0;
                                    let found = false;
                                    let id = mp.id;
                                    for (let j = 0; j < m0.pointCount; ++j) {
                                        {
                                            if (persisted[j] === true) {
                                                continue;
                                            }
                                            let mp0 = m0.points[j];
                                            if (mp0.id.isEqual(id)) {
                                                persisted[j] = true;
                                                mp.normalImpulse = mp0.normalImpulse;
                                                mp.tangentImpulse = mp0.tangentImpulse;
                                                found = true;
                                                if (listener != null) {
                                                    b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                                    b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                                    b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                                    cp.velocity.subLocal(v1);
                                                    cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                                    cp.separation = mp.separation;
                                                    cp.id.set(id);
                                                    listener.persist(cp);
                                                }
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    if (found === false && listener != null) {
                                        b1.getWorldLocationToOut(mp.localPoint1, cp.position);
                                        b1.getLinearVelocityFromLocalPointToOut(mp.localPoint1, v1);
                                        b2.getLinearVelocityFromLocalPointToOut(mp.localPoint2, cp.velocity);
                                        cp.velocity.subLocal(v1);
                                        cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                        cp.separation = mp.separation;
                                        cp.id.set(id);
                                        listener.add(cp);
                                    }
                                }
                                ;
                            }
                            this.m_manifoldCount = 1;
                        }
                        else {
                            this.m_manifoldCount = 0;
                        }
                        if (listener == null) {
                            return;
                        }
                        for (let i = 0; i < m0.pointCount; ++i) {
                            {
                                if (persisted[i]) {
                                    continue;
                                }
                                let mp0 = m0.points[i];
                                b1.getWorldLocationToOut(mp0.localPoint1, cp.position);
                                b1.getLinearVelocityFromLocalPointToOut(mp0.localPoint1, v1);
                                b2.getLinearVelocityFromLocalPointToOut(mp0.localPoint2, cp.velocity);
                                cp.velocity.subLocal(v1);
                                cp.normal.set$org_jbox2d_common_Vec2(this.m_manifold.normal);
                                cp.separation = mp0.separation;
                                cp.id.set(mp0.id);
                                listener.remove(cp);
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @return {org.jbox2d.collision.Manifold[]}
                     */
                    getManifolds() {
                        return this.manifoldList;
                    }
                }
                contacts.PolyAndEdgeContact = PolyAndEdgeContact;
                PolyAndEdgeContact["__class"] = "org.jbox2d.dynamics.contacts.PolyAndEdgeContact";
                PolyAndEdgeContact["__interfaces"] = ["org.jbox2d.dynamics.contacts.ContactCreateFcn"];
            })(contacts = dynamics.contacts || (dynamics.contacts = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            /**
             * This broad phase uses the Sweep and Prune algorithm as described in:
             * Collision Detection in Interactive 3D Environments by Gino van den Bergen
             * Also, some ideas, such as using integral values for fast compares comes from
             * Bullet (http:/www.bulletphysics.com).<br/>
             * <br/>
             *
             * Notes:<br/>
             * - we use bound arrays instead of linked lists for cache coherence.<br/>
             * - we use quantized integral values for fast compares.<br/>
             * - we use short indices rather than pointers to save memory.<br/>
             * - we use a stabbing count for fast overlap queries (less than order N).<br/>
             * - we also use a time stamp on each proxy to speed up the registration of
             * overlap query results.<br/>
             * - where possible, we compare bound indices instead of values to reduce cache
             * misses (TODO_ERIN).<br/>
             * - no broadphase is perfect and neither is this one: it is not great for huge
             * worlds (use a multi-SAP instead), it is not great for large objects.
             * @param {org.jbox2d.collision.AABB} worldAABB
             * @param {*} callback
             * @class
             */
            class BroadPhase {
                constructor(worldAABB, callback) {
                    if (this.m_pairManager === undefined)
                        this.m_pairManager = null;
                    if (this.m_proxyPool === undefined)
                        this.m_proxyPool = null;
                    if (this.m_freeProxy === undefined)
                        this.m_freeProxy = 0;
                    if (this.pairBuffer === undefined)
                        this.pairBuffer = null;
                    if (this.m_pairBufferCount === undefined)
                        this.m_pairBufferCount = 0;
                    if (this.m_bounds === undefined)
                        this.m_bounds = null;
                    if (this.m_queryResults === undefined)
                        this.m_queryResults = null;
                    if (this.m_querySortKeys === undefined)
                        this.m_querySortKeys = null;
                    if (this.m_queryResultCount === undefined)
                        this.m_queryResultCount = 0;
                    if (this.m_worldAABB === undefined)
                        this.m_worldAABB = null;
                    if (this.m_quantizationFactor === undefined)
                        this.m_quantizationFactor = null;
                    if (this.m_proxyCount === undefined)
                        this.m_proxyCount = 0;
                    if (this.m_timeStamp === undefined)
                        this.m_timeStamp = 0;
                    if (BroadPhase.debugPrint) {
                        console.info("BroadPhase()");
                    }
                    this.m_querySortKeys = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(org.jbox2d.common.Settings.maxProxies);
                    this.m_proxyPool = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(org.jbox2d.common.Settings.maxProxies);
                    this.pairBuffer = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(org.jbox2d.common.Settings.maxPairs_$LI$());
                    this.m_bounds = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                        return null;
                    }
                    else {
                        let array = [];
                        for (let i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([2, 2 * org.jbox2d.common.Settings.maxProxies]);
                    this.m_queryResults = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(org.jbox2d.common.Settings.maxProxies);
                    for (let i = 0; i < 2 * org.jbox2d.common.Settings.maxProxies; i++) {
                        {
                            this.m_bounds[0][i] = new org.jbox2d.collision.Bound();
                            this.m_bounds[1][i] = new org.jbox2d.collision.Bound();
                        }
                        ;
                    }
                    for (let i = 0; i < org.jbox2d.common.Settings.maxProxies; i++) {
                        {
                            this.pairBuffer[i] = new org.jbox2d.collision.BufferedPair();
                        }
                        ;
                    }
                    this.m_pairManager = new org.jbox2d.collision.PairManager();
                    this.m_pairManager.initialize(this, callback);
                    this.m_worldAABB = new org.jbox2d.collision.AABB(worldAABB);
                    this.m_proxyCount = 0;
                    let d = worldAABB.upperBound.sub(worldAABB.lowerBound);
                    this.m_quantizationFactor = new org.jbox2d.common.Vec2(Math.fround(2147483647 / d.x), Math.fround(2147483647 / d.y));
                    for (let i = 0; i < org.jbox2d.common.Settings.maxProxies - 1; ++i) {
                        {
                            this.m_proxyPool[i] = new org.jbox2d.collision.Proxy();
                            this.m_proxyPool[i].setNext(i + 1);
                            this.m_proxyPool[i].timeStamp = 0;
                            this.m_proxyPool[i].overlapCount = BroadPhase.INVALID_$LI$();
                            this.m_proxyPool[i].userData = null;
                        }
                        ;
                    }
                    this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1] = new org.jbox2d.collision.Proxy();
                    this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].setNext(org.jbox2d.collision.PairManager.NULL_PROXY_$LI$());
                    this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].timeStamp = 0;
                    this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].overlapCount = BroadPhase.INVALID_$LI$();
                    this.m_proxyPool[org.jbox2d.common.Settings.maxProxies - 1].userData = null;
                    this.m_freeProxy = 0;
                    this.m_timeStamp = 1;
                    this.m_queryResultCount = 0;
                }
                static INVALID_$LI$() { if (BroadPhase.INVALID == null)
                    BroadPhase.INVALID = 2147483647; return BroadPhase.INVALID; }
                ;
                static NULL_EDGE_$LI$() { if (BroadPhase.NULL_EDGE == null)
                    BroadPhase.NULL_EDGE = 2147483647; return BroadPhase.NULL_EDGE; }
                ;
                /*private*/ dump() {
                    for (let i = 0; i < 10; i++) {
                        {
                            console.info("bounds[ %d ] = %d, %d \n");
                        }
                        ;
                    }
                }
                testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(p1, p2) {
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            if (bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value) {
                                return false;
                            }
                            if (bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value) {
                                return false;
                            }
                        }
                        ;
                    }
                    return true;
                }
                testOverlap(p1, p2) {
                    if (((p1 != null && p1 instanceof org.jbox2d.collision.Proxy) || p1 === null) && ((p2 != null && p2 instanceof org.jbox2d.collision.Proxy) || p2 === null)) {
                        return this.testOverlap$org_jbox2d_collision_Proxy$org_jbox2d_collision_Proxy(p1, p2);
                    }
                    else if (((p1 != null && p1 instanceof org.jbox2d.collision.BoundValues) || p1 === null) && ((p2 != null && p2 instanceof org.jbox2d.collision.Proxy) || p2 === null)) {
                        return this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(p1, p2);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(b, p) {
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            if (b.lowerValues[axis] > bounds[p.upperBounds[axis]].value) {
                                return false;
                            }
                            if (b.upperValues[axis] < bounds[p.lowerBounds[axis]].value) {
                                return false;
                            }
                        }
                        ;
                    }
                    return true;
                }
                getProxy(proxyId) {
                    if (proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$() || (this.m_proxyPool[proxyId].isValid() === false)) {
                        return null;
                    }
                    else {
                        return this.m_proxyPool[proxyId];
                    }
                }
                static tlLowerValues_$LI$() { if (BroadPhase.tlLowerValues == null)
                    BroadPhase.tlLowerValues = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlLowerValues; }
                ;
                static tlUpperValues_$LI$() { if (BroadPhase.tlUpperValues == null)
                    BroadPhase.tlUpperValues = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlUpperValues; }
                ;
                static tlIndexes_$LI$() { if (BroadPhase.tlIndexes == null)
                    BroadPhase.tlIndexes = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlIndexes; }
                ;
                /**
                 * internal
                 * @param {org.jbox2d.collision.AABB} aabb
                 * @param {*} userData
                 * @return {number}
                 */
                createProxy(aabb, userData) {
                    if (BroadPhase.debugPrint) {
                        console.info("CreateProxy()");
                    }
                    let proxyId = this.m_freeProxy;
                    let proxy = this.m_proxyPool[proxyId];
                    this.m_freeProxy = proxy.getNext();
                    proxy.overlapCount = 0;
                    proxy.userData = userData;
                    let boundCount = 2 * this.m_proxyCount;
                    let lowerValues = BroadPhase.tlLowerValues_$LI$().get(2);
                    let upperValues = BroadPhase.tlUpperValues_$LI$().get(2);
                    let indexes = BroadPhase.tlIndexes_$LI$().get(2);
                    this.computeBounds(lowerValues, upperValues, aabb);
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
                            let lowerIndex = indexes[0];
                            let upperIndex = indexes[1];
                            /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                                while (--size >= 0)
                                    dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            else {
                                let tmp = srcPts.slice(srcOff, srcOff + size);
                                for (let i = 0; i < size; i++)
                                    dstPts[dstOff++] = tmp[i];
                            } })(this.m_bounds[axis], upperIndex, this.m_bounds[axis], upperIndex + 2, boundCount - upperIndex);
                            for (let i = 0; i < boundCount - upperIndex; i++) {
                                {
                                    this.m_bounds[axis][upperIndex + 2 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][upperIndex + 2 + i]);
                                }
                                ;
                            }
                            /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                                while (--size >= 0)
                                    dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            else {
                                let tmp = srcPts.slice(srcOff, srcOff + size);
                                for (let i = 0; i < size; i++)
                                    dstPts[dstOff++] = tmp[i];
                            } })(this.m_bounds[axis], lowerIndex, this.m_bounds[axis], lowerIndex + 1, upperIndex - lowerIndex);
                            for (let i = 0; i < upperIndex - lowerIndex; i++) {
                                {
                                    this.m_bounds[axis][lowerIndex + 1 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][lowerIndex + 1 + i]);
                                }
                                ;
                            }
                            ++upperIndex;
                            bounds[lowerIndex].value = lowerValues[axis];
                            bounds[lowerIndex].proxyId = proxyId;
                            bounds[upperIndex].value = upperValues[axis];
                            bounds[upperIndex].proxyId = proxyId;
                            bounds[lowerIndex].stabbingCount = lowerIndex === 0 ? 0 : bounds[lowerIndex - 1].stabbingCount;
                            bounds[upperIndex].stabbingCount = bounds[upperIndex - 1].stabbingCount;
                            for (let index = lowerIndex; index < upperIndex; ++index) {
                                {
                                    ++bounds[index].stabbingCount;
                                }
                                ;
                            }
                            for (let index = lowerIndex; index < boundCount + 2; ++index) {
                                {
                                    let proxyn = this.m_proxyPool[bounds[index].proxyId];
                                    if (bounds[index].isLower()) {
                                        proxyn.lowerBounds[axis] = index;
                                    }
                                    else {
                                        proxyn.upperBounds[axis] = index;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                    ++this.m_proxyCount;
                    for (let i = 0; i < this.m_queryResultCount; ++i) {
                        {
                            this.m_pairManager.addBufferedPair(proxyId, this.m_queryResults[i]);
                        }
                        ;
                    }
                    this.m_pairManager.commit();
                    if (BroadPhase.s_validate) {
                        this.validate();
                    }
                    this.m_queryResultCount = 0;
                    this.incrementTimeStamp();
                    return proxyId;
                }
                static tlIgnored_$LI$() { if (BroadPhase.tlIgnored == null)
                    BroadPhase.tlIgnored = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlIgnored; }
                ;
                destroyProxy(proxyId) {
                    let proxy = this.m_proxyPool[proxyId];
                    let boundCount = 2 * this.m_proxyCount;
                    let ignored = BroadPhase.tlIgnored_$LI$().get(2);
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            let lowerIndex = proxy.lowerBounds[axis];
                            let upperIndex = proxy.upperBounds[axis];
                            let lowerValue = bounds[lowerIndex].value;
                            let upperValue = bounds[upperIndex].value;
                            /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                                while (--size >= 0)
                                    dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            else {
                                let tmp = srcPts.slice(srcOff, srcOff + size);
                                for (let i = 0; i < size; i++)
                                    dstPts[dstOff++] = tmp[i];
                            } })(this.m_bounds[axis], lowerIndex + 1, this.m_bounds[axis], lowerIndex, upperIndex - lowerIndex - 1);
                            for (let i = 0; i < upperIndex - lowerIndex - 1; i++) {
                                {
                                    this.m_bounds[axis][lowerIndex + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][lowerIndex + i]);
                                }
                                ;
                            }
                            /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                                while (--size >= 0)
                                    dstPts[dstOff++] = srcPts[srcOff++];
                            }
                            else {
                                let tmp = srcPts.slice(srcOff, srcOff + size);
                                for (let i = 0; i < size; i++)
                                    dstPts[dstOff++] = tmp[i];
                            } })(this.m_bounds[axis], upperIndex + 1, this.m_bounds[axis], upperIndex - 1, boundCount - upperIndex - 1);
                            for (let i = 0; i < boundCount - upperIndex - 1; i++) {
                                {
                                    this.m_bounds[axis][upperIndex - 1 + i] = new org.jbox2d.collision.Bound(this.m_bounds[axis][upperIndex - 1 + i]);
                                }
                                ;
                            }
                            for (let index = lowerIndex; index < boundCount - 2; ++index) {
                                {
                                    let proxyn = this.m_proxyPool[bounds[index].proxyId];
                                    if (bounds[index].isLower()) {
                                        proxyn.lowerBounds[axis] = index;
                                    }
                                    else {
                                        proxyn.upperBounds[axis] = index;
                                    }
                                }
                                ;
                            }
                            for (let index = lowerIndex; index < upperIndex - 1; ++index) {
                                {
                                    --bounds[index].stabbingCount;
                                }
                                ;
                            }
                            this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(ignored, lowerValue, upperValue, bounds, boundCount - 2, axis);
                        }
                        ;
                    }
                    for (let i = 0; i < this.m_queryResultCount; ++i) {
                        {
                            this.m_pairManager.removeBufferedPair(proxyId, this.m_queryResults[i]);
                        }
                        ;
                    }
                    this.m_pairManager.commit();
                    this.m_queryResultCount = 0;
                    this.incrementTimeStamp();
                    proxy.userData = null;
                    proxy.overlapCount = BroadPhase.INVALID_$LI$();
                    proxy.lowerBounds[0] = BroadPhase.INVALID_$LI$();
                    proxy.lowerBounds[1] = BroadPhase.INVALID_$LI$();
                    proxy.upperBounds[0] = BroadPhase.INVALID_$LI$();
                    proxy.upperBounds[1] = BroadPhase.INVALID_$LI$();
                    proxy.setNext(this.m_freeProxy);
                    this.m_freeProxy = proxyId;
                    --this.m_proxyCount;
                    if (BroadPhase.s_validate) {
                        this.validate();
                    }
                }
                static tlNewValues_$LI$() { if (BroadPhase.tlNewValues == null)
                    BroadPhase.tlNewValues = (() => { let __o = new org.jbox2d.pooling.TLBoundValues(); __o.__delegate = new org.jbox2d.pooling.TLBoundValues(); return __o; })(); return BroadPhase.tlNewValues; }
                ;
                static tlOldValues_$LI$() { if (BroadPhase.tlOldValues == null)
                    BroadPhase.tlOldValues = (() => { let __o = new org.jbox2d.pooling.TLBoundValues(); __o.__delegate = new org.jbox2d.pooling.TLBoundValues(); return __o; })(); return BroadPhase.tlOldValues; }
                ;
                /**
                 * internal
                 * @param {number} proxyId
                 * @param {org.jbox2d.collision.AABB} aabb
                 */
                moveProxy(proxyId, aabb) {
                    if (BroadPhase.debugPrint) {
                        console.info("MoveProxy()");
                    }
                    let newValues = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(BroadPhase.tlNewValues_$LI$());
                    let oldValues = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(BroadPhase.tlOldValues_$LI$());
                    if (proxyId === org.jbox2d.collision.PairManager.NULL_PROXY_$LI$() || org.jbox2d.common.Settings.maxProxies <= proxyId) {
                        return;
                    }
                    let boundCount = 2 * this.m_proxyCount;
                    let proxy = this.m_proxyPool[proxyId];
                    this.computeBounds(newValues.lowerValues, newValues.upperValues, aabb);
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            oldValues.lowerValues[axis] = this.m_bounds[axis][proxy.lowerBounds[axis]].value;
                            oldValues.upperValues[axis] = this.m_bounds[axis][proxy.upperBounds[axis]].value;
                        }
                        ;
                    }
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            let lowerIndex = proxy.lowerBounds[axis];
                            let upperIndex = proxy.upperBounds[axis];
                            let lowerValue = newValues.lowerValues[axis];
                            let upperValue = newValues.upperValues[axis];
                            let deltaLower = lowerValue - bounds[lowerIndex].value;
                            let deltaUpper = upperValue - bounds[upperIndex].value;
                            bounds[lowerIndex].value = lowerValue;
                            bounds[upperIndex].value = upperValue;
                            if (deltaLower < 0) {
                                let index = lowerIndex;
                                while ((index > 0 && lowerValue < bounds[index - 1].value)) {
                                    {
                                        let bound = bounds[index];
                                        let prevBound = bounds[index - 1];
                                        let prevProxyId = prevBound.proxyId;
                                        let prevProxy = this.m_proxyPool[prevBound.proxyId];
                                        ++prevBound.stabbingCount;
                                        if (prevBound.isUpper() === true) {
                                            if (this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(newValues, prevProxy)) {
                                                this.m_pairManager.addBufferedPair(proxyId, prevProxyId);
                                            }
                                            ++prevProxy.upperBounds[axis];
                                            ++bound.stabbingCount;
                                        }
                                        else {
                                            ++prevProxy.lowerBounds[axis];
                                            --bound.stabbingCount;
                                        }
                                        --proxy.lowerBounds[axis];
                                        bound.swap(prevBound);
                                        --index;
                                    }
                                }
                                ;
                            }
                            if (deltaUpper > 0) {
                                let index = upperIndex;
                                while ((index < boundCount - 1 && bounds[index + 1].value <= upperValue)) {
                                    {
                                        let bound = bounds[index];
                                        let nextBound = bounds[index + 1];
                                        let nextProxyId = nextBound.proxyId;
                                        let nextProxy = this.m_proxyPool[nextProxyId];
                                        ++nextBound.stabbingCount;
                                        if (nextBound.isLower() === true) {
                                            if (this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(newValues, nextProxy)) {
                                                this.m_pairManager.addBufferedPair(proxyId, nextProxyId);
                                            }
                                            --nextProxy.lowerBounds[axis];
                                            ++bound.stabbingCount;
                                        }
                                        else {
                                            --nextProxy.upperBounds[axis];
                                            --bound.stabbingCount;
                                        }
                                        ++proxy.upperBounds[axis];
                                        bound.swap(nextBound);
                                        ++index;
                                    }
                                }
                                ;
                            }
                            if (deltaLower > 0) {
                                let index = lowerIndex;
                                while ((index < boundCount - 1 && bounds[index + 1].value <= lowerValue)) {
                                    {
                                        let bound = bounds[index];
                                        let nextBound = bounds[index + 1];
                                        let nextProxyId = nextBound.proxyId;
                                        let nextProxy = this.m_proxyPool[nextProxyId];
                                        --nextBound.stabbingCount;
                                        if (nextBound.isUpper()) {
                                            if (this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(oldValues, nextProxy)) {
                                                this.m_pairManager.removeBufferedPair(proxyId, nextProxyId);
                                            }
                                            --nextProxy.upperBounds[axis];
                                            --bound.stabbingCount;
                                        }
                                        else {
                                            --nextProxy.lowerBounds[axis];
                                            ++bound.stabbingCount;
                                        }
                                        ++proxy.lowerBounds[axis];
                                        bound.swap(nextBound);
                                        ++index;
                                    }
                                }
                                ;
                            }
                            if (deltaUpper < 0) {
                                let index = upperIndex;
                                while ((index > 0 && upperValue < bounds[index - 1].value)) {
                                    {
                                        let bound = bounds[index];
                                        let prevBound = bounds[index - 1];
                                        let prevProxyId = prevBound.proxyId;
                                        let prevProxy = this.m_proxyPool[prevProxyId];
                                        --prevBound.stabbingCount;
                                        if (prevBound.isLower() === true) {
                                            if (this.testOverlap$org_jbox2d_collision_BoundValues$org_jbox2d_collision_Proxy(oldValues, prevProxy)) {
                                                this.m_pairManager.removeBufferedPair(proxyId, prevProxyId);
                                            }
                                            ++prevProxy.lowerBounds[axis];
                                            --bound.stabbingCount;
                                        }
                                        else {
                                            ++prevProxy.upperBounds[axis];
                                            ++bound.stabbingCount;
                                        }
                                        --proxy.upperBounds[axis];
                                        bound.swap(prevBound);
                                        --index;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                    if (BroadPhase.s_validate) {
                        this.validate();
                    }
                }
                commit() {
                    this.m_pairManager.commit();
                }
                query$org_jbox2d_collision_AABB$int(aabb, maxCount) {
                    if (BroadPhase.debugPrint) {
                        console.info("Query(2 args)");
                    }
                    let lowerValues = BroadPhase.tlUpperValues_$LI$().get(2);
                    let upperValues = BroadPhase.tlLowerValues_$LI$().get(2);
                    this.computeBounds(lowerValues, upperValues, aabb);
                    let indexes = BroadPhase.tlIndexes_$LI$().get(2);
                    this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
                    this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
                    let results = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(maxCount);
                    let count = 0;
                    for (let i = 0; i < this.m_queryResultCount && count < maxCount; ++i, ++count) {
                        {
                            let proxy = this.m_proxyPool[this.m_queryResults[i]];
                            proxy.isValid();
                            results[i] = proxy.userData;
                        }
                        ;
                    }
                    let copy = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(count);
                    /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                        while (--size >= 0)
                            dstPts[dstOff++] = srcPts[srcOff++];
                    }
                    else {
                        let tmp = srcPts.slice(srcOff, srcOff + size);
                        for (let i = 0; i < size; i++)
                            dstPts[dstOff++] = tmp[i];
                    } })(results, 0, copy, 0, count);
                    this.m_queryResultCount = 0;
                    this.incrementTimeStamp();
                    return copy;
                }
                validate() {
                    if (BroadPhase.debugPrint) {
                        console.info("Validate()");
                    }
                    for (let axis = 0; axis < 2; ++axis) {
                        {
                            let bounds = this.m_bounds[axis];
                            let boundCount = 2 * this.m_proxyCount;
                            let stabbingCount = 0;
                            for (let i = 0; i < boundCount; ++i) {
                                {
                                    let bound = bounds[i];
                                    if (bound.isLower() === true) {
                                        ++stabbingCount;
                                    }
                                    else {
                                        --stabbingCount;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                }
                /*private*/ computeBounds(lowerValues, upperValues, aabb) {
                    if (BroadPhase.debugPrint) {
                        console.info("ComputeBounds()");
                    }
                    let bx = aabb.lowerBound.x < this.m_worldAABB.upperBound.x ? aabb.lowerBound.x : this.m_worldAABB.upperBound.x;
                    let by = aabb.lowerBound.y < this.m_worldAABB.upperBound.y ? aabb.lowerBound.y : this.m_worldAABB.upperBound.y;
                    let minVertexX = this.m_worldAABB.lowerBound.x > bx ? this.m_worldAABB.lowerBound.x : bx;
                    let minVertexY = this.m_worldAABB.lowerBound.y > by ? this.m_worldAABB.lowerBound.y : by;
                    let b1x = aabb.upperBound.x < this.m_worldAABB.upperBound.x ? aabb.upperBound.x : this.m_worldAABB.upperBound.x;
                    let b1y = aabb.upperBound.y < this.m_worldAABB.upperBound.y ? aabb.upperBound.y : this.m_worldAABB.upperBound.y;
                    let maxVertexX = this.m_worldAABB.lowerBound.x > b1x ? this.m_worldAABB.lowerBound.x : b1x;
                    let maxVertexY = this.m_worldAABB.lowerBound.y > b1y ? this.m_worldAABB.lowerBound.y : b1y;
                    lowerValues[0] = ((Math.fround(this.m_quantizationFactor.x * (Math.fround(minVertexX - this.m_worldAABB.lowerBound.x)))) | 0) & (2147483647 - 1);
                    upperValues[0] = ((Math.fround(this.m_quantizationFactor.x * (Math.fround(maxVertexX - this.m_worldAABB.lowerBound.x)))) | 0) | 1;
                    lowerValues[1] = ((Math.fround(this.m_quantizationFactor.y * (Math.fround(minVertexY - this.m_worldAABB.lowerBound.y)))) | 0) & (2147483647 - 1);
                    upperValues[1] = ((Math.fround(this.m_quantizationFactor.y * (Math.fround(maxVertexY - this.m_worldAABB.lowerBound.y)))) | 0) | 1;
                }
                query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValue, upperValue, bounds, boundCount, axis) {
                    if (BroadPhase.debugPrint) {
                        console.info("Query(6 args)");
                    }
                    let lowerQuery = BroadPhase.binarySearch(bounds, boundCount, lowerValue);
                    let upperQuery = BroadPhase.binarySearch(bounds, boundCount, upperValue);
                    for (let i = lowerQuery; i < upperQuery; ++i) {
                        {
                            if (bounds[i].isLower()) {
                                this.incrementOverlapCount(bounds[i].proxyId);
                            }
                        }
                        ;
                    }
                    if (lowerQuery > 0) {
                        let i = lowerQuery - 1;
                        let s = bounds[i].stabbingCount;
                        while ((s !== 0)) {
                            {
                                if (bounds[i].isLower()) {
                                    let proxy = this.m_proxyPool[bounds[i].proxyId];
                                    if (lowerQuery <= proxy.upperBounds[axis]) {
                                        this.incrementOverlapCount(bounds[i].proxyId);
                                        --s;
                                    }
                                }
                                --i;
                            }
                        }
                        ;
                    }
                    indexes[0] = lowerQuery;
                    indexes[1] = upperQuery;
                }
                /**
                 * @param {Array} indexes
                 * out variable
                 * @param {number} lowerValue
                 * @param {number} upperValue
                 * @param {Array} bounds
                 * @param {number} boundCount
                 * @param {number} axis
                 * @private
                 */
                query(indexes, lowerValue, upperValue, bounds, boundCount, axis) {
                    if (((indexes != null && indexes instanceof Array && (indexes.length == 0 || indexes[0] == null || (typeof indexes[0] === 'number'))) || indexes === null) && ((typeof lowerValue === 'number') || lowerValue === null) && ((typeof upperValue === 'number') || upperValue === null) && ((bounds != null && bounds instanceof Array && (bounds.length == 0 || bounds[0] == null || (bounds[0] != null && bounds[0] instanceof org.jbox2d.collision.Bound))) || bounds === null) && ((typeof boundCount === 'number') || boundCount === null) && ((typeof axis === 'number') || axis === null)) {
                        return this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(indexes, lowerValue, upperValue, bounds, boundCount, axis);
                    }
                    else if (((indexes != null && indexes instanceof org.jbox2d.collision.AABB) || indexes === null) && ((typeof lowerValue === 'number') || lowerValue === null) && upperValue === undefined && bounds === undefined && boundCount === undefined && axis === undefined) {
                        return this.query$org_jbox2d_collision_AABB$int(indexes, lowerValue);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ incrementOverlapCount(proxyId) {
                    if (BroadPhase.debugPrint) {
                        console.info("IncrementOverlapCount()");
                    }
                    let proxy = this.m_proxyPool[proxyId];
                    if (proxy.timeStamp < this.m_timeStamp) {
                        proxy.timeStamp = this.m_timeStamp;
                        proxy.overlapCount = 1;
                    }
                    else {
                        proxy.overlapCount = 2;
                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                        ++this.m_queryResultCount;
                    }
                }
                /*private*/ incrementTimeStamp() {
                    if (BroadPhase.debugPrint) {
                        console.info("IncrementTimeStamp()");
                    }
                    if (this.m_timeStamp === 2147483647) {
                        for (let i = 0; i < org.jbox2d.common.Settings.maxProxies; ++i) {
                            {
                                this.m_proxyPool[i].timeStamp = 0;
                            }
                            ;
                        }
                        this.m_timeStamp = 1;
                    }
                    else {
                        ++this.m_timeStamp;
                    }
                }
                static binarySearch(bounds, count, value) {
                    if (BroadPhase.debugPrint) {
                        console.info("BinarySearch()");
                    }
                    let low = 0;
                    let high = count - 1;
                    while ((low <= high)) {
                        {
                            let mid = (low + high) >> 1;
                            if (bounds[mid].value > value) {
                                high = mid - 1;
                            }
                            else if (bounds[mid].value < value) {
                                low = mid + 1;
                            }
                            else {
                                return mid;
                            }
                        }
                    }
                    ;
                    return low;
                }
                inRange(aabb) {
                    let ax = Math.fround(aabb.lowerBound.x - this.m_worldAABB.upperBound.x);
                    let ay = Math.fround(aabb.lowerBound.y - this.m_worldAABB.upperBound.y);
                    let bx = Math.fround(this.m_worldAABB.lowerBound.x - aabb.upperBound.x);
                    let by = Math.fround(this.m_worldAABB.lowerBound.y - aabb.upperBound.y);
                    let dx = org.jbox2d.common.MathUtils.max$float$float(ax, bx);
                    let dy = org.jbox2d.common.MathUtils.max$float$float(ay, by);
                    return (org.jbox2d.common.MathUtils.max$float$float(dx, dy) < 0.0);
                }
                static tlResults_$LI$() { if (BroadPhase.tlResults == null)
                    BroadPhase.tlResults = new org.jbox2d.pooling.arrays.IntegerArray(); return BroadPhase.tlResults; }
                ;
                querySegment(segment, userData, maxCount, sortKey) {
                    let maxLambda = 1;
                    let dx = Math.fround((Math.fround(segment.p2.x - segment.p1.x)) * this.m_quantizationFactor.x);
                    let dy = Math.fround((Math.fround(segment.p2.y - segment.p1.y)) * this.m_quantizationFactor.y);
                    let sx = dx < -org.jbox2d.common.Settings.EPSILON ? -1 : (dx > org.jbox2d.common.Settings.EPSILON ? 1 : 0);
                    let sy = dy < -org.jbox2d.common.Settings.EPSILON ? -1 : (dy > org.jbox2d.common.Settings.EPSILON ? 1 : 0);
                    let p1x = Math.fround((Math.fround(segment.p1.x - this.m_worldAABB.lowerBound.x)) * this.m_quantizationFactor.x);
                    let p1y = Math.fround((Math.fround(segment.p1.y - this.m_worldAABB.lowerBound.y)) * this.m_quantizationFactor.y);
                    let startValues = [0, 0];
                    let startValues2 = [0, 0];
                    let xIndex;
                    let yIndex;
                    let proxyId;
                    let proxy = null;
                    startValues[0] = ((p1x) | 0) & (2147483647 - 1);
                    startValues2[0] = ((p1x) | 0) | 1;
                    startValues[1] = ((p1y) | 0) & (2147483647 - 1);
                    startValues2[1] = ((p1y) | 0) | 1;
                    let results = BroadPhase.tlResults_$LI$().get(2);
                    this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(results, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
                    if (sx >= 0)
                        xIndex = results[1] - 1;
                    else
                        xIndex = results[0];
                    this.query$java_lang_Integer_A$int$int$org_jbox2d_collision_Bound_A$int$int(results, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
                    if (sy >= 0)
                        yIndex = results[1] - 1;
                    else
                        yIndex = results[0];
                    if (sortKey != null) {
                        for (let i = 0; i < this.m_queryResultCount; i++) {
                            {
                                this.m_querySortKeys[i] = sortKey.apply(this.m_proxyPool[this.m_queryResults[i]].userData);
                            }
                            ;
                        }
                        let i = 0;
                        while ((i < this.m_queryResultCount - 1)) {
                            {
                                let a = this.m_querySortKeys[i];
                                let b = this.m_querySortKeys[i + 1];
                                if ((a < 0) ? (b >= 0) : (a > b && b >= 0)) {
                                    this.m_querySortKeys[i + 1] = a;
                                    this.m_querySortKeys[i] = b;
                                    let tempValue = this.m_queryResults[i + 1];
                                    this.m_queryResults[i + 1] = this.m_queryResults[i];
                                    this.m_queryResults[i] = tempValue;
                                    i--;
                                    if (i === -1)
                                        i = 1;
                                }
                                else {
                                    i++;
                                }
                            }
                        }
                        ;
                        while ((this.m_queryResultCount > 0 && this.m_querySortKeys[this.m_queryResultCount - 1] < 0)) {
                            this.m_queryResultCount--;
                        }
                        ;
                    }
                    for (;;) {
                        {
                            let xProgress = 0;
                            let yProgress = 0;
                            xIndex += sx >= 0 ? 1 : -1;
                            if (xIndex < 0 || xIndex >= this.m_proxyCount * 2)
                                break;
                            if (sx !== 0)
                                xProgress = Math.fround((Math.fround(this.m_bounds[0][xIndex].value - p1x)) / dx);
                            yIndex += sy >= 0 ? 1 : -1;
                            if (yIndex < 0 || yIndex >= this.m_proxyCount * 2)
                                break;
                            if (sy !== 0)
                                yProgress = Math.fround((Math.fround(this.m_bounds[1][yIndex].value - p1y)) / dy);
                            for (;;) {
                                {
                                    if (sy === 0 || (sx !== 0 && xProgress < yProgress)) {
                                        if (xProgress > maxLambda)
                                            break;
                                        if (sx > 0 ? this.m_bounds[0][xIndex].isLower() : this.m_bounds[0][xIndex].isUpper()) {
                                            proxyId = this.m_bounds[0][xIndex].proxyId;
                                            proxy = this.m_proxyPool[proxyId];
                                            if (sy >= 0) {
                                                if (proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
                                                    if (sortKey != null) {
                                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                                    }
                                                    else {
                                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                                        ++this.m_queryResultCount;
                                                    }
                                                }
                                            }
                                            else {
                                                if (proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
                                                    if (sortKey != null) {
                                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                                    }
                                                    else {
                                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                                        ++this.m_queryResultCount;
                                                    }
                                                }
                                            }
                                        }
                                        if (sortKey != null && this.m_queryResultCount === maxCount && this.m_queryResultCount > 0 && xProgress > this.m_querySortKeys[this.m_queryResultCount - 1])
                                            break;
                                        if (sx > 0) {
                                            xIndex++;
                                            if (xIndex === this.m_proxyCount * 2)
                                                break;
                                        }
                                        else {
                                            xIndex--;
                                            if (xIndex < 0)
                                                break;
                                        }
                                        xProgress = Math.fround((Math.fround(this.m_bounds[0][xIndex].value - p1x)) / dx);
                                    }
                                    else {
                                        if (yProgress > maxLambda)
                                            break;
                                        if (sy > 0 ? this.m_bounds[1][yIndex].isLower() : this.m_bounds[1][yIndex].isUpper()) {
                                            proxyId = this.m_bounds[1][yIndex].proxyId;
                                            proxy = this.m_proxyPool[proxyId];
                                            if (sx >= 0) {
                                                if (proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
                                                    if (sortKey != null) {
                                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                                    }
                                                    else {
                                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                                        ++this.m_queryResultCount;
                                                    }
                                                }
                                            }
                                            else {
                                                if (proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
                                                    if (sortKey != null) {
                                                        this.addProxyResult(proxyId, proxy, maxCount, sortKey);
                                                    }
                                                    else {
                                                        this.m_queryResults[this.m_queryResultCount] = proxyId;
                                                        ++this.m_queryResultCount;
                                                    }
                                                }
                                            }
                                        }
                                        if (sortKey != null && this.m_queryResultCount === maxCount && this.m_queryResultCount > 0 && yProgress > this.m_querySortKeys[this.m_queryResultCount - 1])
                                            break;
                                        if (sy > 0) {
                                            yIndex++;
                                            if (yIndex === this.m_proxyCount * 2)
                                                break;
                                        }
                                        else {
                                            yIndex--;
                                            if (yIndex < 0)
                                                break;
                                        }
                                        yProgress = Math.fround((Math.fround(this.m_bounds[1][yIndex].value - p1y)) / dy);
                                    }
                                }
                                ;
                            }
                            break;
                        }
                        ;
                    }
                    let count = 0;
                    for (let i = 0; i < this.m_queryResultCount && count < maxCount; ++i, ++count) {
                        {
                            let proxya = this.m_proxyPool[this.m_queryResults[i]];
                            userData[i] = proxya.userData;
                        }
                        ;
                    }
                    this.m_queryResultCount = 0;
                    this.incrementTimeStamp();
                    return count;
                }
                /*private*/ addProxyResult(proxyId, proxy, maxCount, sortKey) {
                    let key = sortKey.apply(proxy.userData);
                    if (key < 0)
                        return;
                    let i = 0;
                    while ((i < this.m_queryResultCount && this.m_querySortKeys[i] < key)) {
                        ++i;
                    }
                    ;
                    if (maxCount === this.m_queryResultCount && i === this.m_queryResultCount)
                        return;
                    if (maxCount === this.m_queryResultCount)
                        this.m_queryResultCount--;
                    for (let j = this.m_queryResultCount + 1; j > i; --j) {
                        {
                            this.m_querySortKeys[j] = this.m_querySortKeys[j - 1];
                            this.m_queryResults[j] = this.m_queryResults[j - 1];
                        }
                        ;
                    }
                    this.m_querySortKeys[i] = key;
                    this.m_queryResults[i] = proxyId;
                    this.m_queryResultCount++;
                }
            }
            BroadPhase.debugPrint = false;
            BroadPhase.s_validate = false;
            collision.BroadPhase = BroadPhase;
            BroadPhase["__class"] = "org.jbox2d.collision.BroadPhase";
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            var joints;
            (function (joints) {
                class ConstantVolumeJoint extends org.jbox2d.dynamics.joints.Joint {
                    constructor(def) {
                        super(def);
                        /*private*/ this.m_impulse = 0.0;
                        if (this.bodies === undefined)
                            this.bodies = null;
                        if (this.targetLengths === undefined)
                            this.targetLengths = null;
                        if (this.targetVolume === undefined)
                            this.targetVolume = 0;
                        if (this.world === undefined)
                            this.world = null;
                        if (this.normals === undefined)
                            this.normals = null;
                        if (this.m_step === undefined)
                            this.m_step = null;
                        if (this.distanceJoints === undefined)
                            this.distanceJoints = null;
                        if (def.bodies.length <= 2) {
                            throw Object.defineProperty(new Error("You cannot create a constant volume joint with less than three bodies."), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception'] });
                        }
                        this.world = def.bodies[0].getWorld();
                        this.bodies = def.bodies;
                        this.targetLengths = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(this.bodies.length);
                        for (let i = 0; i < this.targetLengths.length; ++i) {
                            {
                                let next = (i === this.targetLengths.length - 1) ? 0 : i + 1;
                                let dist = this.bodies[i].getMemberWorldCenter().sub(this.bodies[next].getMemberWorldCenter()).length();
                                this.targetLengths[i] = dist;
                            }
                            ;
                        }
                        this.targetVolume = this.getArea();
                        this.distanceJoints = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.bodies.length);
                        for (let i = 0; i < this.targetLengths.length; ++i) {
                            {
                                let next = (i === this.targetLengths.length - 1) ? 0 : i + 1;
                                let djd = new org.jbox2d.dynamics.joints.DistanceJointDef();
                                djd.frequencyHz = def.frequencyHz;
                                djd.dampingRatio = def.dampingRatio;
                                djd.initialize(this.bodies[i], this.bodies[next], this.bodies[i].getMemberWorldCenter(), this.bodies[next].getMemberWorldCenter());
                                this.distanceJoints[i] = this.world.createJoint(djd);
                            }
                            ;
                        }
                        this.normals = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.bodies.length);
                        for (let i = 0; i < this.normals.length; ++i) {
                            {
                                this.normals[i] = new org.jbox2d.common.Vec2();
                            }
                            ;
                        }
                        this.m_body1 = this.bodies[0];
                        this.m_body2 = this.bodies[1];
                        this.m_collideConnected = false;
                    }
                    getBodies() {
                        return this.bodies;
                    }
                    inflate(factor) {
                        this.targetVolume *= factor;
                    }
                    /**
                     *
                     */
                    destructor() {
                        for (let i = 0; i < this.distanceJoints.length; ++i) {
                            {
                                this.world.destroyJoint(this.distanceJoints[i]);
                            }
                            ;
                        }
                    }
                    /*private*/ getArea() {
                        let area = 0.0;
                        area += Math.fround(Math.fround(this.bodies[this.bodies.length - 1].getMemberWorldCenter().x * this.bodies[0].getMemberWorldCenter().y) - Math.fround(this.bodies[0].getMemberWorldCenter().x * this.bodies[this.bodies.length - 1].getMemberWorldCenter().y));
                        for (let i = 0; i < this.bodies.length - 1; ++i) {
                            {
                                area += Math.fround(Math.fround(this.bodies[i].getMemberWorldCenter().x * this.bodies[i + 1].getMemberWorldCenter().y) - Math.fround(this.bodies[i + 1].getMemberWorldCenter().x * this.bodies[i].getMemberWorldCenter().y));
                            }
                            ;
                        }
                        area *= 0.5;
                        return area;
                    }
                    /**
                     * Apply the position correction to the particles.
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     * @return {boolean}
                     */
                    constrainEdges(step) {
                        let perimeter = 0.0;
                        for (let i = 0; i < this.bodies.length; ++i) {
                            {
                                let next = (i === this.bodies.length - 1) ? 0 : i + 1;
                                let dx = Math.fround(this.bodies[next].getMemberWorldCenter().x - this.bodies[i].getMemberWorldCenter().x);
                                let dy = Math.fround(this.bodies[next].getMemberWorldCenter().y - this.bodies[i].getMemberWorldCenter().y);
                                let dist = org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy)));
                                if (dist < org.jbox2d.common.Settings.EPSILON) {
                                    dist = 1.0;
                                }
                                this.normals[i].x = Math.fround(dy / dist);
                                this.normals[i].y = Math.fround(-dx / dist);
                                perimeter += dist;
                            }
                            ;
                        }
                        let deltaArea = Math.fround(this.targetVolume - this.getArea());
                        let toExtrude = Math.fround(Math.fround(0.5 * deltaArea) / perimeter);
                        let done = true;
                        for (let i = 0; i < this.bodies.length; ++i) {
                            {
                                let next = (i === this.bodies.length - 1) ? 0 : i + 1;
                                let delta = new org.jbox2d.common.Vec2(Math.fround(toExtrude * (Math.fround(this.normals[i].x + this.normals[next].x))), Math.fround(toExtrude * (Math.fround(this.normals[i].y + this.normals[next].y))));
                                let norm = delta.length();
                                if (norm > org.jbox2d.common.Settings.maxLinearCorrection_$LI$()) {
                                    delta.mulLocal(Math.fround(org.jbox2d.common.Settings.maxLinearCorrection_$LI$() / norm));
                                }
                                if (norm > org.jbox2d.common.Settings.linearSlop_$LI$()) {
                                    done = false;
                                }
                                this.bodies[next].m_sweep.c.x += delta.x;
                                this.bodies[next].m_sweep.c.y += delta.y;
                                this.bodies[next].synchronizeTransform();
                            }
                            ;
                        }
                        return done;
                    }
                    static tlD_$LI$() { if (ConstantVolumeJoint.tlD == null)
                        ConstantVolumeJoint.tlD = new org.jbox2d.pooling.arrays.Vec2Array(); return ConstantVolumeJoint.tlD; }
                    ;
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    initVelocityConstraints(step) {
                        this.m_step = step;
                        let d = ConstantVolumeJoint.tlD_$LI$().get(this.bodies.length);
                        for (let i = 0; i < this.bodies.length; ++i) {
                            {
                                let prev = (i === 0) ? this.bodies.length - 1 : i - 1;
                                let next = (i === this.bodies.length - 1) ? 0 : i + 1;
                                d[i].set$org_jbox2d_common_Vec2(this.bodies[next].getMemberWorldCenter());
                                d[i].subLocal(this.bodies[prev].getMemberWorldCenter());
                            }
                            ;
                        }
                        if (step.warmStarting) {
                            this.m_impulse *= step.dtRatio;
                            for (let i = 0; i < this.bodies.length; ++i) {
                                {
                                    this.bodies[i].m_linearVelocity.x += Math.fround(Math.fround(Math.fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * this.m_impulse);
                                    this.bodies[i].m_linearVelocity.y += Math.fround(Math.fround(Math.fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * this.m_impulse);
                                }
                                ;
                            }
                        }
                        else {
                            this.m_impulse = 0.0;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    solvePositionConstraints() {
                        return this.constrainEdges(this.m_step);
                    }
                    /**
                     *
                     * @param {org.jbox2d.dynamics.TimeStep} step
                     */
                    solveVelocityConstraints(step) {
                        let crossMassSum = 0.0;
                        let dotMassSum = 0.0;
                        let d = ConstantVolumeJoint.tlD_$LI$().get(this.bodies.length);
                        for (let i = 0; i < this.bodies.length; ++i) {
                            {
                                let prev = (i === 0) ? this.bodies.length - 1 : i - 1;
                                let next = (i === this.bodies.length - 1) ? 0 : i + 1;
                                d[i].set$org_jbox2d_common_Vec2(this.bodies[next].getMemberWorldCenter());
                                d[i].subLocal(this.bodies[prev].getMemberWorldCenter());
                                dotMassSum += Math.fround((d[i].lengthSquared()) / this.bodies[i].getMass());
                                crossMassSum += org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.bodies[i].getLinearVelocity(), d[i]);
                            }
                            ;
                        }
                        let lambda = Math.fround(Math.fround(-2.0 * crossMassSum) / dotMassSum);
                        this.m_impulse += lambda;
                        for (let i = 0; i < this.bodies.length; ++i) {
                            {
                                this.bodies[i].m_linearVelocity.x += Math.fround(Math.fround(Math.fround(this.bodies[i].m_invMass * d[i].y) * 0.5) * lambda);
                                this.bodies[i].m_linearVelocity.y += Math.fround(Math.fround(Math.fround(this.bodies[i].m_invMass * -d[i].x) * 0.5) * lambda);
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor1() {
                        return null;
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getAnchor2() {
                        return null;
                    }
                    /**
                     *
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getReactionForce() {
                        return null;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getReactionTorque() {
                        return 0;
                    }
                }
                joints.ConstantVolumeJoint = ConstantVolumeJoint;
                ConstantVolumeJoint["__class"] = "org.jbox2d.dynamics.joints.ConstantVolumeJoint";
            })(joints = dynamics.joints || (dynamics.joints = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * TODO djm: make this so it isn't created every time step
             * @class
             */
            class Island {
                constructor() {
                    if (this.m_bodies === undefined)
                        this.m_bodies = null;
                    if (this.m_contacts === undefined)
                        this.m_contacts = null;
                    if (this.m_joints === undefined)
                        this.m_joints = null;
                    if (this.m_bodyCount === undefined)
                        this.m_bodyCount = 0;
                    if (this.m_jointCount === undefined)
                        this.m_jointCount = 0;
                    if (this.m_contactCount === undefined)
                        this.m_contactCount = 0;
                    if (this.m_bodyCapacity === undefined)
                        this.m_bodyCapacity = 0;
                    if (this.m_contactCapacity === undefined)
                        this.m_contactCapacity = 0;
                    if (this.m_jointCapacity === undefined)
                        this.m_jointCapacity = 0;
                    if (this.m_positionError === undefined)
                        this.m_positionError = 0;
                    if (this.m_listener === undefined)
                        this.m_listener = null;
                }
                clear() {
                    this.m_bodyCount = 0;
                    this.m_contactCount = 0;
                    this.m_jointCount = 0;
                }
                add$org_jbox2d_dynamics_Body(body) {
                    this.m_bodies[this.m_bodyCount++] = body;
                }
                add(body) {
                    if (((body != null && body instanceof org.jbox2d.dynamics.Body) || body === null)) {
                        return this.add$org_jbox2d_dynamics_Body(body);
                    }
                    else if (((body != null && body instanceof org.jbox2d.dynamics.contacts.Contact) || body === null)) {
                        return this.add$org_jbox2d_dynamics_contacts_Contact(body);
                    }
                    else if (((body != null && body instanceof org.jbox2d.dynamics.joints.Joint) || body === null)) {
                        return this.add$org_jbox2d_dynamics_joints_Joint(body);
                    }
                    else
                        throw new Error('invalid overload');
                }
                add$org_jbox2d_dynamics_contacts_Contact(contact) {
                    this.m_contacts[this.m_contactCount++] = contact;
                }
                add$org_jbox2d_dynamics_joints_Joint(joint) {
                    this.m_joints[this.m_jointCount++] = joint;
                }
                init(bodyCapacity, contactCapacity, jointCapacity, listener) {
                    this.m_bodyCapacity = bodyCapacity;
                    this.m_contactCapacity = contactCapacity;
                    this.m_jointCapacity = jointCapacity;
                    this.m_bodyCount = 0;
                    this.m_contactCount = 0;
                    this.m_jointCount = 0;
                    this.m_listener = listener;
                    this.m_bodies = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(bodyCapacity);
                    this.m_contacts = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(contactCapacity);
                    this.m_joints = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(jointCapacity);
                    Island.m_positionIterationCount = 0;
                }
                static contactSolvers_$LI$() { if (Island.contactSolvers == null)
                    Island.contactSolvers = new org.jbox2d.pooling.stacks.ContactSolverStack(); return Island.contactSolvers; }
                ;
                solve(step, gravity, correctPositions, allowSleep) {
                    for (let i = 0; i < this.m_bodyCount; ++i) {
                        {
                            let b = this.m_bodies[i];
                            if (b.isStatic()) {
                                continue;
                            }
                            b.m_linearVelocity.x += Math.fround(step.dt * (Math.fround(gravity.x + Math.fround(b.m_invMass * b.m_force.x))));
                            b.m_linearVelocity.y += Math.fround(step.dt * (Math.fround(gravity.y + Math.fround(b.m_invMass * b.m_force.y))));
                            b.m_angularVelocity += Math.fround(Math.fround(step.dt * b.m_invI) * b.m_torque);
                            b.m_force.set$float$float(0.0, 0.0);
                            b.m_torque = 0.0;
                            b.m_linearVelocity.mulLocal(org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(1.0 - Math.fround(step.dt * b.m_linearDamping)), 0.0, 1.0));
                            b.m_angularVelocity *= org.jbox2d.common.MathUtils.clamp$float$float$float(Math.fround(1.0 - Math.fround(step.dt * b.m_angularDamping)), 0.0, 1.0);
                            if (org.jbox2d.common.Vec2.dot(b.m_linearVelocity, b.m_linearVelocity) > org.jbox2d.common.Settings.maxLinearVelocitySquared_$LI$()) {
                                b.m_linearVelocity.normalize();
                                b.m_linearVelocity.mulLocal(org.jbox2d.common.Settings.maxLinearVelocity);
                            }
                            if (Math.fround(b.m_angularVelocity * b.m_angularVelocity) > org.jbox2d.common.Settings.maxAngularVelocitySquared_$LI$()) {
                                if (b.m_angularVelocity < 0.0) {
                                    b.m_angularVelocity = -org.jbox2d.common.Settings.maxAngularVelocity;
                                }
                                else {
                                    b.m_angularVelocity = org.jbox2d.common.Settings.maxAngularVelocity;
                                }
                            }
                        }
                        ;
                    }
                    let contactSolver = Island.contactSolvers_$LI$().get();
                    contactSolver.init(step, this.m_contacts, this.m_contactCount);
                    contactSolver.initVelocityConstraints(step);
                    for (let i = 0; i < this.m_jointCount; ++i) {
                        {
                            this.m_joints[i].initVelocityConstraints(step);
                        }
                        ;
                    }
                    for (let i = 0; i < step.maxIterations; ++i) {
                        {
                            contactSolver.solveVelocityConstraints();
                            for (let j = 0; j < this.m_jointCount; ++j) {
                                {
                                    this.m_joints[j].solveVelocityConstraints(step);
                                }
                                ;
                            }
                        }
                        ;
                    }
                    contactSolver.finalizeVelocityConstraints();
                    for (let i = 0; i < this.m_bodyCount; ++i) {
                        {
                            let b = this.m_bodies[i];
                            if (b.isStatic()) {
                                continue;
                            }
                            b.m_sweep.c0.set$org_jbox2d_common_Vec2(b.m_sweep.c);
                            b.m_sweep.a0 = b.m_sweep.a;
                            b.m_sweep.c.x += Math.fround(step.dt * b.m_linearVelocity.x);
                            b.m_sweep.c.y += Math.fround(step.dt * b.m_linearVelocity.y);
                            b.m_sweep.a += Math.fround(step.dt * b.m_angularVelocity);
                            b.synchronizeTransform();
                        }
                        ;
                    }
                    if (correctPositions) {
                        for (let i = 0; i < this.m_jointCount; ++i) {
                            {
                                this.m_joints[i].initPositionConstraints();
                            }
                            ;
                        }
                        for (Island.m_positionIterationCount = 0; Island.m_positionIterationCount < step.maxIterations; ++Island.m_positionIterationCount) {
                            {
                                let contactsOkay = contactSolver.solvePositionConstraints(org.jbox2d.common.Settings.contactBaumgarte);
                                let jointsOkay = true;
                                for (let i = 0; i < this.m_jointCount; ++i) {
                                    {
                                        let jointOkay = this.m_joints[i].solvePositionConstraints();
                                        jointsOkay = jointsOkay && jointOkay;
                                    }
                                    ;
                                }
                                if (contactsOkay && jointsOkay) {
                                    break;
                                }
                            }
                            ;
                        }
                    }
                    this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(contactSolver.m_constraints);
                    if (allowSleep) {
                        let minSleepTime = 3.4028235E38;
                        let linTolSqr = Math.fround(org.jbox2d.common.Settings.linearSleepTolerance_$LI$() * org.jbox2d.common.Settings.linearSleepTolerance_$LI$());
                        let angTolSqr = Math.fround(org.jbox2d.common.Settings.angularSleepTolerance_$LI$() * org.jbox2d.common.Settings.angularSleepTolerance_$LI$());
                        for (let i = 0; i < this.m_bodyCount; ++i) {
                            {
                                let b = this.m_bodies[i];
                                if (b.m_invMass === 0.0) {
                                    continue;
                                }
                                if ((b.m_flags & org.jbox2d.dynamics.Body.e_allowSleepFlag) === 0 || Math.fround(b.m_angularVelocity * b.m_angularVelocity) > angTolSqr || org.jbox2d.common.Vec2.dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                                    b.m_sleepTime = 0.0;
                                    minSleepTime = 0.0;
                                }
                                else {
                                    b.m_sleepTime += step.dt;
                                    minSleepTime = org.jbox2d.common.MathUtils.min(minSleepTime, b.m_sleepTime);
                                }
                            }
                            ;
                        }
                        if (minSleepTime >= org.jbox2d.common.Settings.timeToSleep_$LI$()) {
                            for (let i = 0; i < this.m_bodyCount; ++i) {
                                {
                                    let b = this.m_bodies[i];
                                    b.m_flags |= org.jbox2d.dynamics.Body.e_sleepFlag;
                                    b.m_linearVelocity.setZero();
                                    b.m_angularVelocity = 0.0;
                                }
                                ;
                            }
                        }
                    }
                    Island.contactSolvers_$LI$().recycle(contactSolver);
                }
                solveTOI(subStep) {
                    let contactSolver = Island.contactSolvers_$LI$().get();
                    contactSolver.init(subStep, this.m_contacts, this.m_contactCount);
                    if (org.jbox2d.common.Settings.maxTOIJointsPerIsland > 0) {
                        subStep.warmStarting = true;
                        for (let i = this.m_jointCount - 1; i >= 0; --i) {
                            {
                                this.m_joints[i].initVelocityConstraints(subStep);
                            }
                            ;
                        }
                        subStep.warmStarting = false;
                    }
                    for (let i = 0; i < subStep.maxIterations; ++i) {
                        {
                            contactSolver.solveVelocityConstraints();
                            for (let j = this.m_jointCount - 1; j >= 0; --j) {
                                {
                                    this.m_joints[j].solveVelocityConstraints(subStep);
                                }
                                ;
                            }
                        }
                        ;
                    }
                    for (let i = 0; i < this.m_bodyCount; ++i) {
                        {
                            let b = this.m_bodies[i];
                            if (b.isStatic()) {
                                continue;
                            }
                            b.m_sweep.c0.set$org_jbox2d_common_Vec2(b.m_sweep.c);
                            b.m_sweep.a0 = b.m_sweep.a;
                            b.m_sweep.c.x += Math.fround(subStep.dt * b.m_linearVelocity.x);
                            b.m_sweep.c.y += Math.fround(subStep.dt * b.m_linearVelocity.y);
                            b.m_sweep.a += Math.fround(subStep.dt * b.m_angularVelocity);
                            b.synchronizeTransform();
                        }
                        ;
                    }
                    let k_toiBaumgarte = 0.75;
                    for (let i = 0; i < subStep.maxIterations; ++i) {
                        {
                            let contactsOkay = contactSolver.solvePositionConstraints(k_toiBaumgarte);
                            let jointsOkay = true;
                            for (let j = this.m_jointCount - 1; j >= 0; --j) {
                                {
                                    let jointOkay = this.m_joints[j].solvePositionConstraints();
                                    jointsOkay = jointsOkay && jointOkay;
                                }
                                ;
                            }
                            if (contactsOkay && jointsOkay) {
                                break;
                            }
                        }
                        ;
                    }
                    this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(contactSolver.m_constraints);
                    Island.contactSolvers_$LI$().recycle(contactSolver);
                }
                report$java_util_List(constraints) {
                    let cc = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(/* size */ constraints.length);
                    for (let i = 0; i < cc.length; ++i) {
                        {
                            cc[i] = constraints[i];
                        }
                        ;
                    }
                    this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(cc);
                }
                report(constraints) {
                    if (((constraints != null && (constraints instanceof Array)) || constraints === null)) {
                        return this.report$java_util_List(constraints);
                    }
                    else if (((constraints != null && constraints instanceof Array && (constraints.length == 0 || constraints[0] == null || (constraints[0] != null && constraints[0] instanceof org.jbox2d.dynamics.contacts.ContactConstraint))) || constraints === null)) {
                        return this.report$org_jbox2d_dynamics_contacts_ContactConstraint_A(constraints);
                    }
                    else
                        throw new Error('invalid overload');
                }
                report$org_jbox2d_dynamics_contacts_ContactConstraint_A(constraints) {
                    if (this.m_listener == null) {
                        return;
                    }
                    for (let i = 0; i < this.m_contactCount; ++i) {
                        {
                            let c = this.m_contacts[i];
                            let cc = constraints[i];
                            let cr = new org.jbox2d.dynamics.contacts.ContactResult();
                            cr.shape1 = c.getShape1();
                            cr.shape2 = c.getShape2();
                            let b1 = cr.shape1.getBody();
                            let manifoldCount = c.getManifoldCount();
                            let manifolds = c.getManifolds();
                            for (let j = 0; j < manifoldCount; ++j) {
                                {
                                    let manifold = manifolds[j];
                                    cr.normal.set$org_jbox2d_common_Vec2(manifold.normal);
                                    for (let k = 0; k < manifold.pointCount; ++k) {
                                        {
                                            let point = manifold.points[k];
                                            let ccp = cc.points[k];
                                            org.jbox2d.common.XForm.mulToOut(b1.getMemberXForm(), point.localPoint1, cr.position);
                                            cr.normalImpulse = ccp.normalImpulse;
                                            cr.tangentImpulse = ccp.tangentImpulse;
                                            cr.id.set(point.id);
                                            this.m_listener.result(cr);
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                }
            }
            Island.m_positionIterationCount = 0;
            dynamics.Island = Island;
            Island["__class"] = "org.jbox2d.dynamics.Island";
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var dynamics;
        (function (dynamics) {
            /**
             * Construct a world object.
             * @param {org.jbox2d.collision.AABB} worldAABB a bounding box that completely encompasses all your shapes.
             * @param {org.jbox2d.common.Vec2} gravity the world gravity vector.
             * @param {boolean} doSleep improve performance by not simulating inactive bodies.
             * @class
             */
            class World {
                constructor(worldAABB, gravity, doSleep) {
                    /*private*/ this.autoDebugDraw = true;
                    /*private*/ this.liquidLength = 0.12;
                    /*private*/ this.averageLinearVel = -1;
                    /*private*/ this.coreColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.6), Math.fround(255.0 * 0.6));
                    /*private*/ this.drawingCenter = new org.jbox2d.common.Vec2();
                    /*private*/ this.liquidOffset = new org.jbox2d.common.Vec2();
                    /*private*/ this.circCenterMoved = new org.jbox2d.common.Vec2();
                    /*private*/ this.liquidColor = new org.jbox2d.common.Color3f(80.0, 80.0, 255.0);
                    /*private*/ this.segLeft = new org.jbox2d.common.Vec2();
                    /*private*/ this.segRight = new org.jbox2d.common.Vec2();
                    /*private*/ this.jointColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.5), Math.fround(255.0 * 0.8), Math.fround(255.0 * 0.8));
                    /*private*/ this.staticColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.5), Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.5));
                    /*private*/ this.sleepingColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.5), Math.fround(255.0 * 0.5), Math.fround(255.0 * 0.9));
                    /*private*/ this.activeColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.9));
                    /*private*/ this.pairColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.3));
                    /*private*/ this.aabbColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.3), Math.fround(255.0 * 0.9));
                    /*private*/ this.obbColor = new org.jbox2d.common.Color3f(0.5, 0.3, 0.5);
                    /*private*/ this.worldColor = new org.jbox2d.common.Color3f(Math.fround(255.0 * 0.3), Math.fround(255.0 * 0.9), Math.fround(255.0 * 0.9));
                    /*private*/ this.pairB1 = new org.jbox2d.collision.AABB();
                    /*private*/ this.pairB2 = new org.jbox2d.collision.AABB();
                    /*private*/ this.pairX1 = new org.jbox2d.common.Vec2();
                    /*private*/ this.pairX2 = new org.jbox2d.common.Vec2();
                    /*private*/ this.aabbB = new org.jbox2d.collision.AABB();
                    /*private*/ this.cornerVecs = [new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2(), new org.jbox2d.common.Vec2()];
                    /*private*/ this.raycastSortKey = new World.World$0(this);
                    if (this.m_lock === undefined)
                        this.m_lock = false;
                    if (this.m_broadPhase === undefined)
                        this.m_broadPhase = null;
                    if (this.m_contactManager === undefined)
                        this.m_contactManager = null;
                    if (this.m_bodyList === undefined)
                        this.m_bodyList = null;
                    if (this.m_contactList === undefined)
                        this.m_contactList = null;
                    if (this.m_jointList === undefined)
                        this.m_jointList = null;
                    if (this.m_controllerList === undefined)
                        this.m_controllerList = null;
                    if (this.m_controllerCount === undefined)
                        this.m_controllerCount = 0;
                    if (this.m_bodyCount === undefined)
                        this.m_bodyCount = 0;
                    if (this.m_contactCount === undefined)
                        this.m_contactCount = 0;
                    if (this.m_jointCount === undefined)
                        this.m_jointCount = 0;
                    if (this.m_gravity === undefined)
                        this.m_gravity = null;
                    if (this.m_allowSleep === undefined)
                        this.m_allowSleep = false;
                    if (this.m_groundBody === undefined)
                        this.m_groundBody = null;
                    if (this.m_positionIterationCount === undefined)
                        this.m_positionIterationCount = 0;
                    if (this.m_positionCorrection === undefined)
                        this.m_positionCorrection = false;
                    if (this.m_warmStarting === undefined)
                        this.m_warmStarting = false;
                    if (this.m_continuousPhysics === undefined)
                        this.m_continuousPhysics = false;
                    if (this.m_destructionListener === undefined)
                        this.m_destructionListener = null;
                    if (this.m_boundaryListener === undefined)
                        this.m_boundaryListener = null;
                    if (this.m_contactFilter === undefined)
                        this.m_contactFilter = null;
                    if (this.m_contactListener === undefined)
                        this.m_contactListener = null;
                    if (this.m_debugDraw === undefined)
                        this.m_debugDraw = null;
                    if (this.m_drawDebugData === undefined)
                        this.m_drawDebugData = false;
                    if (this.m_inv_dt0 === undefined)
                        this.m_inv_dt0 = 0;
                    if (this.postStepList === undefined)
                        this.postStepList = null;
                    if (this.m_raycastSegment === undefined)
                        this.m_raycastSegment = null;
                    if (this.m_raycastNormal === undefined)
                        this.m_raycastNormal = null;
                    if (this.m_raycastUserData === undefined)
                        this.m_raycastUserData = null;
                    if (this.m_raycastSolidShape === undefined)
                        this.m_raycastSolidShape = false;
                    this.m_positionCorrection = true;
                    this.m_warmStarting = true;
                    this.m_continuousPhysics = true;
                    this.m_destructionListener = null;
                    this.m_boundaryListener = null;
                    this.m_contactFilter = org.jbox2d.dynamics.ContactFilter.DEFAULT_FILTER_$LI$();
                    this.m_contactListener = null;
                    this.m_debugDraw = null;
                    this.m_inv_dt0 = 0.0;
                    this.m_bodyList = null;
                    this.m_contactList = null;
                    this.m_jointList = null;
                    this.m_controllerList = null;
                    this.m_bodyCount = 0;
                    this.m_contactCount = 0;
                    this.m_jointCount = 0;
                    this.m_controllerCount = 0;
                    this.m_lock = false;
                    this.m_allowSleep = doSleep;
                    this.m_gravity = gravity;
                    this.m_contactManager = new org.jbox2d.dynamics.ContactManager();
                    this.m_contactManager.m_world = this;
                    this.m_broadPhase = new org.jbox2d.collision.BroadPhase(worldAABB, this.m_contactManager);
                    let bd = new org.jbox2d.dynamics.BodyDef();
                    this.m_groundBody = this.createBody(bd);
                    this.postStepList = ([]);
                    this.setDrawDebugData(true);
                }
                /**
                 * @return {boolean} the autoDebugDraw
                 */
                isAutoDebugDraw() {
                    return this.autoDebugDraw;
                }
                /**
                 * @param {boolean} autoDebugDraw the autoDebugDraw to set
                 */
                setAutoDebugDraw(autoDebugDraw) {
                    this.autoDebugDraw = autoDebugDraw;
                }
                setDrawDebugData(tf) {
                    this.m_drawDebugData = tf;
                }
                isDrawingDebugData() {
                    return this.m_drawDebugData;
                }
                /**
                 * Get the number of bodies.
                 * @return {number}
                 */
                getBodyCount() {
                    return this.m_bodyCount;
                }
                /**
                 * Get the number of joints.
                 * @return {number}
                 */
                getJointCount() {
                    return this.m_jointCount;
                }
                /**
                 * Get the number of contacts (each may have 0 or more contact points).
                 * @return {number}
                 */
                getContactCount() {
                    return this.m_contactCount;
                }
                /**
                 * Change the global gravity vector.
                 * @param {org.jbox2d.common.Vec2} gravity
                 */
                setGravity(gravity) {
                    this.m_gravity = gravity;
                }
                /**
                 * Get a clone of the global gravity vector.
                 * @return {org.jbox2d.common.Vec2} Clone of gravity vector
                 */
                getGravity() {
                    return ((o) => { if (o.clone != undefined) {
                        return o.clone();
                    }
                    else {
                        let clone = Object.create(o);
                        for (let p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this.m_gravity);
                }
                /**
                 * The world provides a single static ground body with no collision shapes.
                 * You can use this to simplify the creation of joints and static shapes.
                 * @return {org.jbox2d.dynamics.Body}
                 */
                getGroundBody() {
                    return this.m_groundBody;
                }
                /**
                 * Get the world body list. With the returned body, use Body.getNext() to get
                 * the next body in the world list. A NULL body indicates the end of the list.
                 * @return {org.jbox2d.dynamics.Body} the head of the world body list.
                 */
                getBodyList() {
                    return this.m_bodyList;
                }
                /**
                 * Get the world joint list. With the returned joint, use Joint.getNext() to get
                 * the next joint in the world list. A NULL joint indicates the end of the list.
                 * @return {org.jbox2d.dynamics.joints.Joint} the head of the world joint list.
                 */
                getJointList() {
                    return this.m_jointList;
                }
                /**
                 * Register a destruction listener.
                 * @param {*} listener
                 */
                setDestructionListener(listener) {
                    this.m_destructionListener = listener;
                }
                /**
                 * Register a broad-phase boundary listener.
                 * @param {*} listener
                 */
                setBoundaryListener(listener) {
                    this.m_boundaryListener = listener;
                }
                /**
                 * Register a contact event listener
                 * @param {*} listener
                 */
                setContactListener(listener) {
                    this.m_contactListener = listener;
                }
                /**
                 * Register a contact filter to provide specific control over collision.
                 * Otherwise the default filter is used (b2_defaultFilter).
                 * @param {*} filter
                 */
                setContactFilter(filter) {
                    this.m_contactFilter = filter;
                }
                /**
                 * Register a routine for debug drawing. The debug draw functions are called
                 * inside the World.step() method, so make sure your renderer is ready to
                 * consume draw commands when you call step().
                 * @param {org.jbox2d.dynamics.DebugDraw} debugDraw
                 */
                setDebugDraw(debugDraw) {
                    this.m_debugDraw = debugDraw;
                }
                getDebugDraw() {
                    return this.m_debugDraw;
                }
                /**
                 * Create a body given a definition. No reference to the definition
                 * is retained.  Body will be static unless mass is nonzero.
                 * <BR><em>Warning</em>: This function is locked during callbacks.
                 * @param {org.jbox2d.dynamics.BodyDef} def
                 * @return {org.jbox2d.dynamics.Body}
                 */
                createBody(def) {
                    if (this.m_lock === true) {
                        return null;
                    }
                    let b = new org.jbox2d.dynamics.Body(def, this);
                    b.m_prev = null;
                    b.m_next = this.m_bodyList;
                    if (this.m_bodyList != null) {
                        this.m_bodyList.m_prev = b;
                    }
                    this.m_bodyList = b;
                    ++this.m_bodyCount;
                    return b;
                }
                /**
                 * Destroy a rigid body given a definition. No reference to the definition
                 * is retained. This function is locked during callbacks.
                 * <BR><em>Warning</em>: This automatically deletes all associated shapes and joints.
                 * <BR><em>Warning</em>: This function is locked during callbacks.
                 * @param {org.jbox2d.dynamics.Body} b
                 */
                destroyBody(b) {
                    if (this.m_lock === true) {
                        return;
                    }
                    let jn = b.m_jointList;
                    while ((jn != null)) {
                        {
                            let jn0 = jn;
                            jn = jn.next;
                            if (this.m_destructionListener != null) {
                                this.m_destructionListener['sayGoodbye$org_jbox2d_dynamics_joints_Joint'](jn0.joint);
                            }
                            this.destroyJoint(jn0.joint);
                        }
                    }
                    ;
                    let ce = b.m_controllerList;
                    while ((ce != null)) {
                        {
                            let ce0 = ce;
                            ce = ce.nextController;
                            ce0.controller.removeBody(b);
                        }
                    }
                    ;
                    let s = b.m_shapeList;
                    while ((s != null)) {
                        {
                            let s0 = s;
                            s = s.m_next;
                            if (this.m_destructionListener != null) {
                                this.m_destructionListener['sayGoodbye$org_jbox2d_collision_shapes_Shape'](s0);
                            }
                            s0.destroyProxy(this.m_broadPhase);
                            org.jbox2d.collision.shapes.Shape.destroy(s0);
                        }
                    }
                    ;
                    if (b.m_prev != null) {
                        b.m_prev.m_next = b.m_next;
                    }
                    if (b.m_next != null) {
                        b.m_next.m_prev = b.m_prev;
                    }
                    if (b === this.m_bodyList) {
                        this.m_bodyList = b.m_next;
                    }
                    --this.m_bodyCount;
                }
                /**
                 * Create a joint to constrain bodies together. No reference to the definition
                 * is retained. This may cause the connected bodies to cease colliding.
                 * <BR><em>Warning</em> This function is locked during callbacks.
                 * @param {org.jbox2d.dynamics.joints.JointDef} def
                 * @return {org.jbox2d.dynamics.joints.Joint}
                 */
                createJoint(def) {
                    let j = org.jbox2d.dynamics.joints.Joint.create(def);
                    j.m_prev = null;
                    j.m_next = this.m_jointList;
                    if (this.m_jointList != null) {
                        this.m_jointList.m_prev = j;
                    }
                    this.m_jointList = j;
                    ++this.m_jointCount;
                    j.m_node1.joint = j;
                    j.m_node1.other = j.m_body2;
                    j.m_node1.prev = null;
                    j.m_node1.next = j.m_body1.m_jointList;
                    if (j.m_body1.m_jointList != null) {
                        j.m_body1.m_jointList.prev = j.m_node1;
                    }
                    j.m_body1.m_jointList = j.m_node1;
                    j.m_node2.joint = j;
                    j.m_node2.other = j.m_body1;
                    j.m_node2.prev = null;
                    j.m_node2.next = j.m_body2.m_jointList;
                    if (j.m_body2.m_jointList != null) {
                        j.m_body2.m_jointList.prev = j.m_node2;
                    }
                    j.m_body2.m_jointList = j.m_node2;
                    if (def.collideConnected === false) {
                        let b = def.body1.m_shapeCount < def.body2.m_shapeCount ? def.body1 : def.body2;
                        for (let s = b.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.refilterProxy(this.m_broadPhase, b.getMemberXForm());
                            }
                            ;
                        }
                    }
                    return j;
                }
                /**
                 * Destroy a joint. This may cause the connected bodies to begin colliding.
                 * <BR><em>Warning</em>: This function is locked during callbacks.
                 * @param {org.jbox2d.dynamics.joints.Joint} j
                 */
                destroyJoint(j) {
                    let collideConnected = j.m_collideConnected;
                    if (j.m_prev != null) {
                        j.m_prev.m_next = j.m_next;
                    }
                    if (j.m_next != null) {
                        j.m_next.m_prev = j.m_prev;
                    }
                    if (j === this.m_jointList) {
                        this.m_jointList = j.m_next;
                    }
                    let body1 = j.m_body1;
                    let body2 = j.m_body2;
                    body1.wakeUp();
                    body2.wakeUp();
                    if (j.m_node1.prev != null) {
                        j.m_node1.prev.next = j.m_node1.next;
                    }
                    if (j.m_node1.next != null) {
                        j.m_node1.next.prev = j.m_node1.prev;
                    }
                    if (j.m_node1 === body1.m_jointList) {
                        body1.m_jointList = j.m_node1.next;
                    }
                    j.m_node1.prev = null;
                    j.m_node1.next = null;
                    if (j.m_node2.prev != null) {
                        j.m_node2.prev.next = j.m_node2.next;
                    }
                    if (j.m_node2.next != null) {
                        j.m_node2.next.prev = j.m_node2.prev;
                    }
                    if (j.m_node2 === body2.m_jointList) {
                        body2.m_jointList = j.m_node2.next;
                    }
                    j.m_node2.prev = null;
                    j.m_node2.next = null;
                    org.jbox2d.dynamics.joints.Joint.destroy(j);
                    --this.m_jointCount;
                    if (collideConnected === false) {
                        let b = body1.m_shapeCount < body2.m_shapeCount ? body1 : body2;
                        for (let s = b.m_shapeList; s != null; s = s.m_next) {
                            {
                                s.refilterProxy(this.m_broadPhase, b.getMemberXForm());
                            }
                            ;
                        }
                    }
                }
                createController(def) {
                    let controller = def.create();
                    controller.m_next = this.m_controllerList;
                    controller.m_prev = null;
                    if (this.m_controllerList != null) {
                        this.m_controllerList.m_prev = controller;
                    }
                    this.m_controllerList = controller;
                    ++this.m_controllerCount;
                    controller.m_world = this;
                    return controller;
                }
                destroyController(controller) {
                    if (controller.m_next != null) {
                        controller.m_next.m_prev = controller.m_prev;
                    }
                    if (controller.m_prev != null) {
                        controller.m_prev.m_next = controller.m_next;
                    }
                    if (controller === this.m_controllerList) {
                        this.m_controllerList = controller.m_next;
                    }
                    --this.m_controllerCount;
                }
                static tlStep_$LI$() { if (World.tlStep == null)
                    World.tlStep = (() => { let __o = new org.jbox2d.pooling.TLTimeStep(); __o.__delegate = new org.jbox2d.pooling.TLTimeStep(); return __o; })(); return World.tlStep; }
                ;
                /**
                 * Take a time step. This performs collision detection, integration,
                 * and constraint solution.
                 * @param {number} dt the amount of time to simulate, this should not vary.
                 * @param {number} iterations the number of iterations to be used by the constraint solver.
                 */
                step(dt, iterations) {
                    this.m_lock = true;
                    let step = ((tlObj) => { if (tlObj.___value) {
                        return tlObj.___value;
                    }
                    else {
                        return tlObj.___value = tlObj.initialValue();
                    } })(World.tlStep_$LI$());
                    step.dt = dt;
                    step.maxIterations = iterations;
                    if (dt > 0.0) {
                        step.inv_dt = Math.fround(1.0 / dt);
                    }
                    else {
                        step.inv_dt = 0.0;
                    }
                    step.dtRatio = Math.fround(this.m_inv_dt0 * dt);
                    step.positionCorrection = this.m_positionCorrection;
                    step.warmStarting = this.m_warmStarting;
                    this.m_contactManager.collide();
                    if (step.dt > 0.0) {
                        this.solve(step);
                    }
                    if (this.m_continuousPhysics && step.dt > 0.0) {
                        this.solveTOI(step);
                    }
                    if (this.autoDebugDraw) {
                        this.drawDebugData();
                    }
                    this.m_inv_dt0 = step.inv_dt;
                    this.m_lock = false;
                    this.postStep(dt, iterations);
                }
                /**
                 * Goes through the registered postStep functions and calls them.
                 * @param {number} dt
                 * @param {number} iterations
                 * @private
                 */
                /*private*/ postStep(dt, iterations) {
                    for (let index136 = 0; index136 < this.postStepList.length; index136++) {
                        let s = this.postStepList[index136];
                        {
                            s.step(dt, iterations);
                        }
                    }
                }
                /**
                 * Registers a Steppable object to be stepped
                 * immediately following the physics step, once
                 * the locks are lifted.
                 * @param {*} s
                 */
                registerPostStep(s) {
                    /* add */ (this.postStepList.push(s) > 0);
                }
                /**
                 * Unregisters a method from post-stepping.
                 * Fails silently if method is not found.
                 * @param {*} s
                 */
                unregisterPostStep(s) {
                    if (this.postStepList != null) {
                        /* remove */ (a => { let index = a.indexOf(s); if (index >= 0) {
                            a.splice(index, 1);
                            return true;
                        }
                        else {
                            return false;
                        } })(this.postStepList);
                    }
                }
                /**
                 * Re-filter a shape. This re-runs contact filtering on a shape.
                 * @param {org.jbox2d.collision.shapes.Shape} shape
                 */
                refilter(shape) {
                    shape.refilterProxy(this.m_broadPhase, shape.getBody().getMemberXForm());
                }
                /**
                 * Query the world for all shapes that potentially overlap the
                 * provided AABB up to max count.
                 * The number of shapes found is returned.
                 * @param {org.jbox2d.collision.AABB} aabb the query box.
                 * @param {number} maxCount the capacity of the shapes array.
                 * @return {Array} array of shapes overlapped, up to maxCount in length
                 */
                query(aabb, maxCount) {
                    let objs = this.m_broadPhase.query$org_jbox2d_collision_AABB$int(aabb, maxCount);
                    let ret = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(objs.length);
                    /* arraycopy */ ((srcPts, srcOff, dstPts, dstOff, size) => { if (srcPts !== dstPts || dstOff >= srcOff + size) {
                        while (--size >= 0)
                            dstPts[dstOff++] = srcPts[srcOff++];
                    }
                    else {
                        let tmp = srcPts.slice(srcOff, srcOff + size);
                        for (let i = 0; i < size; i++)
                            dstPts[dstOff++] = tmp[i];
                    } })(objs, 0, ret, 0, objs.length);
                    return ret;
                }
                static islands_$LI$() { if (World.islands == null)
                    World.islands = new org.jbox2d.pooling.stacks.IslandStack(); return World.islands; }
                ;
                /**
                 * For internal use
                 * @param {org.jbox2d.dynamics.TimeStep} step
                 */
                solve(step) {
                    this.m_positionIterationCount = 0;
                    for (let controller = this.m_controllerList; controller != null; controller = controller.m_next) {
                        {
                            controller.step(step);
                        }
                        ;
                    }
                    let island = World.islands_$LI$().get();
                    island.init(this.m_bodyCount, this.m_contactCount, this.m_jointCount, this.m_contactListener);
                    for (let b = this.m_bodyList; b != null; b = b.m_next) {
                        {
                            b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                        }
                        ;
                    }
                    for (let c = this.m_contactList; c != null; c = c.m_next) {
                        {
                            c.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
                        }
                        ;
                    }
                    for (let j = this.m_jointList; j != null; j = j.m_next) {
                        {
                            j.m_islandFlag = false;
                        }
                        ;
                    }
                    let stackSize = this.m_bodyCount;
                    let stack = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(stackSize);
                    for (let seed = this.m_bodyList; seed != null; seed = seed.m_next) {
                        {
                            if ((seed.m_flags & (org.jbox2d.dynamics.Body.e_islandFlag | org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) > 0) {
                                continue;
                            }
                            if (seed.isStatic()) {
                                continue;
                            }
                            island.clear();
                            let stackCount = 0;
                            stack[stackCount++] = seed;
                            seed.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                            while ((stackCount > 0)) {
                                {
                                    let b = stack[--stackCount];
                                    island.add$org_jbox2d_dynamics_Body(b);
                                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_sleepFlag;
                                    if (b.isStatic()) {
                                        continue;
                                    }
                                    for (let cn = b.m_contactList; cn != null; cn = cn.next) {
                                        {
                                            if ((cn.contact.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_islandFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) > 0) {
                                                continue;
                                            }
                                            if (cn.contact.getManifoldCount() === 0) {
                                                continue;
                                            }
                                            island.add$org_jbox2d_dynamics_contacts_Contact(cn.contact);
                                            cn.contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
                                            let other = cn.other;
                                            if ((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                                                continue;
                                            }
                                            stack[stackCount++] = other;
                                            other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                                        }
                                        ;
                                    }
                                    for (let jn = b.m_jointList; jn != null; jn = jn.next) {
                                        {
                                            if (jn.joint.m_islandFlag === true) {
                                                continue;
                                            }
                                            island.add$org_jbox2d_dynamics_joints_Joint(jn.joint);
                                            jn.joint.m_islandFlag = true;
                                            let other = jn.other;
                                            if ((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                                                continue;
                                            }
                                            stack[stackCount++] = other;
                                            other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                            island.solve(step, this.m_gravity, this.m_positionCorrection, this.m_allowSleep);
                            this.m_positionIterationCount = org.jbox2d.common.MathUtils.max$int$int(this.m_positionIterationCount, org.jbox2d.dynamics.Island.m_positionIterationCount);
                            for (let i = 0; i < island.m_bodyCount; ++i) {
                                {
                                    let b = island.m_bodies[i];
                                    if (b.isStatic()) {
                                        b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                                    }
                                }
                                ;
                            }
                        }
                        ;
                    }
                    for (let b = this.m_bodyList; b != null; b = b.getNext()) {
                        {
                            if ((b.m_flags & (org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) !== 0) {
                                continue;
                            }
                            if (b.isStatic()) {
                                continue;
                            }
                            let inRange = b.synchronizeShapes();
                            if (inRange === false && this.m_boundaryListener != null) {
                                this.m_boundaryListener.violation(b);
                            }
                        }
                        ;
                    }
                    this.m_broadPhase.commit();
                    World.islands_$LI$().recycle(island);
                }
                static steps_$LI$() { if (World.steps == null)
                    World.steps = new org.jbox2d.pooling.stacks.TimeStepStack(); return World.steps; }
                ;
                /**
                 * For internal use: find TOI contacts and solve them.
                 * @param {org.jbox2d.dynamics.TimeStep} step
                 */
                solveTOI(step) {
                    let island = World.islands_$LI$().get();
                    island.init(this.m_bodyCount, org.jbox2d.common.Settings.maxTOIContactsPerIsland, org.jbox2d.common.Settings.maxTOIJointsPerIsland, this.m_contactListener);
                    let queueCapacity = this.m_bodyCount;
                    let queue = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(queueCapacity);
                    for (let b = this.m_bodyList; b != null; b = b.m_next) {
                        {
                            b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                            b.m_sweep.t0 = 0.0;
                        }
                        ;
                    }
                    for (let c = this.m_contactList; c != null; c = c.m_next) {
                        {
                            c.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.e_toiFlag | org.jbox2d.dynamics.contacts.Contact.e_islandFlag);
                        }
                        ;
                    }
                    for (let j = this.m_jointList; j != null; j = j.m_next) {
                        {
                            j.m_islandFlag = false;
                        }
                        ;
                    }
                    while ((true)) {
                        {
                            let minContact = null;
                            let minTOI = 1.0;
                            for (let c = this.m_contactList; c != null; c = c.m_next) {
                                {
                                    if ((c.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_slowFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) !== 0) {
                                        continue;
                                    }
                                    let toi = 1.0;
                                    if ((c.m_flags & org.jbox2d.dynamics.contacts.Contact.e_toiFlag) !== 0) {
                                        toi = c.m_toi;
                                    }
                                    else {
                                        let s1 = c.getShape1();
                                        let s2 = c.getShape2();
                                        let b1 = s1.getBody();
                                        let b2 = s2.getBody();
                                        if ((b1.isStatic() || b1.isSleeping()) && (b2.isStatic() || b2.isSleeping())) {
                                            continue;
                                        }
                                        let t0 = b1.m_sweep.t0;
                                        if (b1.m_sweep.t0 < b2.m_sweep.t0) {
                                            t0 = b2.m_sweep.t0;
                                            b1.m_sweep.advance(t0);
                                        }
                                        else if (b2.m_sweep.t0 < b1.m_sweep.t0) {
                                            t0 = b1.m_sweep.t0;
                                            b2.m_sweep.advance(t0);
                                        }
                                        toi = org.jbox2d.collision.TOI.timeOfImpact(c.m_shape1, b1.m_sweep, c.m_shape2, b2.m_sweep);
                                        if (toi > 0.0 && toi < 1.0) {
                                            toi = org.jbox2d.common.MathUtils.min(Math.fround(Math.fround((Math.fround(1.0 - toi)) * t0) + toi), 1.0);
                                        }
                                        c.m_toi = toi;
                                        c.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                                    }
                                    if (org.jbox2d.common.Settings.EPSILON < toi && toi < minTOI) {
                                        minContact = c;
                                        minTOI = toi;
                                    }
                                }
                                ;
                            }
                            if (minContact == null || Math.fround(1.0 - Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON)) < minTOI) {
                                break;
                            }
                            let s1 = minContact.getShape1();
                            let s2 = minContact.getShape2();
                            let b1 = s1.getBody();
                            let b2 = s2.getBody();
                            b1.advance(minTOI);
                            b2.advance(minTOI);
                            minContact.update(this.m_contactListener);
                            minContact.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                            if (minContact.getManifoldCount() === 0) {
                                continue;
                            }
                            let seed = b1;
                            if (seed.isStatic()) {
                                seed = b2;
                            }
                            island.clear();
                            let queueStart = 0;
                            let queueSize = 0;
                            queue[queueStart + queueSize++] = seed;
                            seed.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                            while ((queueSize > 0)) {
                                {
                                    let b = queue[queueStart++];
                                    --queueSize;
                                    island.add$org_jbox2d_dynamics_Body(b);
                                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_sleepFlag;
                                    if (b.isStatic()) {
                                        continue;
                                    }
                                    for (let cn = b.m_contactList; cn != null; cn = cn.next) {
                                        {
                                            if (island.m_contactCount === island.m_contactCapacity) {
                                                continue;
                                            }
                                            if ((cn.contact.m_flags & (org.jbox2d.dynamics.contacts.Contact.e_islandFlag | org.jbox2d.dynamics.contacts.Contact.e_slowFlag | org.jbox2d.dynamics.contacts.Contact.e_nonSolidFlag)) !== 0) {
                                                continue;
                                            }
                                            if (cn.contact.getManifoldCount() === 0) {
                                                continue;
                                            }
                                            island.add$org_jbox2d_dynamics_contacts_Contact(cn.contact);
                                            cn.contact.m_flags |= org.jbox2d.dynamics.contacts.Contact.e_islandFlag;
                                            let other = cn.other;
                                            if ((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) !== 0) {
                                                continue;
                                            }
                                            if (other.isStatic() === false) {
                                                other.advance(minTOI);
                                                other.wakeUp();
                                            }
                                            queue[queueStart + queueSize++] = other;
                                            other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                                        }
                                        ;
                                    }
                                    for (let jn = b.m_jointList; jn != null; jn = jn.next) {
                                        {
                                            if (island.m_jointCount === island.m_jointCapacity) {
                                                continue;
                                            }
                                            if (jn.joint.m_islandFlag === true) {
                                                continue;
                                            }
                                            island.add$org_jbox2d_dynamics_joints_Joint(jn.joint);
                                            jn.joint.m_islandFlag = true;
                                            let other = jn.other;
                                            if ((other.m_flags & org.jbox2d.dynamics.Body.e_islandFlag) > 0) {
                                                continue;
                                            }
                                            if (other.isStatic() === false) {
                                                other.advance(minTOI);
                                                other.wakeUp();
                                            }
                                            queue[queueStart + queueSize++] = other;
                                            other.m_flags |= org.jbox2d.dynamics.Body.e_islandFlag;
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                            let subStep = World.steps_$LI$().get();
                            subStep.warmStarting = false;
                            subStep.dt = Math.fround((Math.fround(1.0 - minTOI)) * step.dt);
                            subStep.inv_dt = Math.fround(1.0 / subStep.dt);
                            subStep.maxIterations = step.maxIterations;
                            island.solveTOI(subStep);
                            World.steps_$LI$().recycle(subStep);
                            for (let i = 0; i < island.m_bodyCount; ++i) {
                                {
                                    let b = island.m_bodies[i];
                                    b.m_flags &= ~org.jbox2d.dynamics.Body.e_islandFlag;
                                    if ((b.m_flags & (org.jbox2d.dynamics.Body.e_sleepFlag | org.jbox2d.dynamics.Body.e_frozenFlag)) !== 0) {
                                        continue;
                                    }
                                    if (b.isStatic()) {
                                        continue;
                                    }
                                    let inRange = b.synchronizeShapes();
                                    if (inRange === false && this.m_boundaryListener != null) {
                                        this.m_boundaryListener.violation(b);
                                    }
                                    for (let cn = b.m_contactList; cn != null; cn = cn.next) {
                                        {
                                            cn.contact.m_flags &= ~org.jbox2d.dynamics.contacts.Contact.e_toiFlag;
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                            for (let i = 0; i < island.m_contactCount; ++i) {
                                {
                                    let c = island.m_contacts[i];
                                    c.m_flags &= ~(org.jbox2d.dynamics.contacts.Contact.e_toiFlag | org.jbox2d.dynamics.contacts.Contact.e_islandFlag);
                                }
                                ;
                            }
                            for (let i = 0; i < island.m_jointCount; ++i) {
                                {
                                    let j = island.m_joints[i];
                                    j.m_islandFlag = false;
                                }
                                ;
                            }
                            this.m_broadPhase.commit();
                        }
                    }
                    ;
                    World.islands_$LI$().recycle(island);
                }
                static LIQUID_INT_$LI$() { if (World.LIQUID_INT == null)
                    World.LIQUID_INT = new Number(12345).valueOf(); return World.LIQUID_INT; }
                ;
                /**
                 * For internal use
                 * @param {org.jbox2d.collision.shapes.Shape} shape
                 * @param {org.jbox2d.common.XForm} xf
                 * @param {org.jbox2d.common.Color3f} color
                 * @param {boolean} core
                 */
                drawShape(shape, xf, color, core) {
                    if (shape.getType() === org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE) {
                        let circle = shape;
                        org.jbox2d.common.XForm.mulToOut(xf, circle.getMemberLocalPosition(), this.drawingCenter);
                        let radius = circle.getRadius();
                        let axis = xf.R.col1;
                        if (circle.getUserData() != null && ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(circle.getUserData(), World.LIQUID_INT_$LI$())) {
                            let b = circle.getBody();
                            this.liquidOffset.set$org_jbox2d_common_Vec2(b.m_linearVelocity);
                            let linVelLength = b.m_linearVelocity.length();
                            if (this.averageLinearVel === -1) {
                                this.averageLinearVel = linVelLength;
                            }
                            else {
                                this.averageLinearVel = Math.fround(Math.fround(0.98 * this.averageLinearVel) + Math.fround(0.02 * linVelLength));
                            }
                            this.liquidOffset.mulLocal(Math.fround(Math.fround(this.liquidLength / this.averageLinearVel) / 2));
                            this.circCenterMoved.set$org_jbox2d_common_Vec2(this.drawingCenter).addLocal$org_jbox2d_common_Vec2(this.liquidOffset);
                            this.drawingCenter.subLocal(this.liquidOffset);
                            this.m_debugDraw.drawSegment(this.drawingCenter, this.circCenterMoved, this.liquidColor);
                            return;
                        }
                        this.m_debugDraw.drawSolidCircle(this.drawingCenter, radius, axis, color);
                        if (core) {
                            this.m_debugDraw.drawCircle(this.drawingCenter, Math.fround(radius - org.jbox2d.common.Settings.toiSlop_$LI$()), this.coreColor);
                        }
                    }
                    else if (shape.getType() === org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE) {
                        let point = shape;
                        org.jbox2d.common.XForm.mulToOut(xf, point.getMemberLocalPosition(), this.drawingCenter);
                        this.m_debugDraw.drawPoint(this.drawingCenter, 0.0, color);
                    }
                    else if (shape.getType() === org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                        let poly = shape;
                        let vertexCount = poly.getVertexCount();
                        let localVertices = poly.getVertices();
                        let vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(vertexCount);
                        for (let i = 0; i < vertexCount; ++i) {
                            {
                                vertices[i] = org.jbox2d.common.XForm.mul(xf, localVertices[i]);
                            }
                            ;
                        }
                        this.m_debugDraw.drawSolidPolygon(vertices, vertexCount, color);
                        if (core) {
                            let localCoreVertices = poly.getCoreVertices();
                            for (let i = 0; i < vertexCount; ++i) {
                                {
                                    vertices[i] = org.jbox2d.common.XForm.mul(xf, localCoreVertices[i]);
                                }
                                ;
                            }
                            this.m_debugDraw.drawPolygon(vertices, vertexCount, this.coreColor);
                        }
                    }
                    else if (shape.getType() === org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE) {
                        let edge = shape;
                        org.jbox2d.common.XForm.mulToOut(xf, edge.getVertex1(), this.segLeft);
                        org.jbox2d.common.XForm.mulToOut(xf, edge.getVertex2(), this.segRight);
                        this.m_debugDraw.drawSegment(this.segLeft, this.segRight, color);
                        if (core) {
                            org.jbox2d.common.XForm.mulToOut(xf, edge.getCoreVertex1(), this.segLeft);
                            org.jbox2d.common.XForm.mulToOut(xf, edge.getCoreVertex2(), this.segRight);
                            this.m_debugDraw.drawSegment(this.segLeft, this.segRight, this.coreColor);
                        }
                    }
                }
                /**
                 * For internal use
                 * @param {org.jbox2d.dynamics.joints.Joint} joint
                 */
                drawJoint(joint) {
                    let b1 = joint.getBody1();
                    let b2 = joint.getBody2();
                    let xf1 = b1.getMemberXForm();
                    let xf2 = b2.getMemberXForm();
                    let x1 = xf1.position;
                    let x2 = xf2.position;
                    let p1 = joint.getAnchor1();
                    let p2 = joint.getAnchor2();
                    let type = joint.getType();
                    if (type === org.jbox2d.dynamics.joints.JointType.DISTANCE_JOINT) {
                        this.m_debugDraw.drawSegment(p1, p2, this.jointColor);
                    }
                    else if (type === org.jbox2d.dynamics.joints.JointType.PULLEY_JOINT) {
                        let pulley = joint;
                        let s1 = pulley.getGroundAnchor1();
                        let s2 = pulley.getGroundAnchor2();
                        this.m_debugDraw.drawSegment(s1, p1, this.jointColor);
                        this.m_debugDraw.drawSegment(s2, p2, this.jointColor);
                        this.m_debugDraw.drawSegment(s1, s2, this.jointColor);
                    }
                    else if (type === org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
                    }
                    else if (type === org.jbox2d.dynamics.joints.JointType.CONSTANT_VOLUME_JOINT) {
                        let cvj = joint;
                        let bodies = cvj.getBodies();
                        for (let i = 0; i < bodies.length; ++i) {
                            {
                                let next = (i === bodies.length - 1) ? 0 : i + 1;
                                let first = bodies[i].getMemberWorldCenter();
                                let nextV = bodies[next].getMemberWorldCenter();
                                this.m_debugDraw.drawSegment(first, nextV, this.jointColor);
                            }
                            ;
                        }
                    }
                    else {
                        this.m_debugDraw.drawSegment(x1, p1, this.jointColor);
                        this.m_debugDraw.drawSegment(p1, p2, this.jointColor);
                        this.m_debugDraw.drawSegment(x2, p2, this.jointColor);
                    }
                }
                /**
                 * For internal use
                 */
                drawDebugData() {
                    if (this.m_debugDraw == null || this.m_drawDebugData === false) {
                        return;
                    }
                    let flags = this.m_debugDraw.getFlags();
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_shapeBit) !== 0) {
                        let core = (flags & org.jbox2d.dynamics.DebugDraw.e_coreShapeBit) === org.jbox2d.dynamics.DebugDraw.e_coreShapeBit;
                        for (let b = this.m_bodyList; b != null; b = b.getNext()) {
                            {
                                let xf = b.getMemberXForm();
                                for (let s = b.getShapeList(); s != null; s = s.getNext()) {
                                    {
                                        if (b.isStatic()) {
                                            this.drawShape(s, xf, this.staticColor, core);
                                        }
                                        else if (b.isSleeping()) {
                                            this.drawShape(s, xf, this.sleepingColor, core);
                                        }
                                        else {
                                            this.drawShape(s, xf, this.activeColor, core);
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_jointBit) !== 0) {
                        for (let j = this.m_jointList; j != null; j = j.getNext()) {
                            {
                                if (j.getType() !== org.jbox2d.dynamics.joints.JointType.MOUSE_JOINT) {
                                    this.drawJoint(j);
                                }
                            }
                            ;
                        }
                    }
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_pairBit) !== 0) {
                        let bp = this.m_broadPhase;
                        let invQ = new org.jbox2d.common.Vec2(0.0, 0.0);
                        invQ.set$float$float(Math.fround(1.0 / bp.m_quantizationFactor.x), Math.fround(1.0 / bp.m_quantizationFactor.y));
                        for (let i = 0; i < org.jbox2d.collision.PairManager.TABLE_CAPACITY_$LI$(); ++i) {
                            {
                                let index = bp.m_pairManager.m_hashTable[i];
                                while ((index !== org.jbox2d.collision.PairManager.NULL_PAIR_$LI$())) {
                                    {
                                        let pair = bp.m_pairManager.m_pairs[index];
                                        let p1 = bp.m_proxyPool[pair.proxyId1];
                                        let p2 = bp.m_proxyPool[pair.proxyId2];
                                        this.pairB1.lowerBound.x = Math.fround(bp.m_worldAABB.lowerBound.x + Math.fround(invQ.x * bp.m_bounds[0][p1.lowerBounds[0]].value));
                                        this.pairB1.lowerBound.y = Math.fround(bp.m_worldAABB.lowerBound.y + Math.fround(invQ.y * bp.m_bounds[1][p1.lowerBounds[1]].value));
                                        this.pairB1.upperBound.x = Math.fround(bp.m_worldAABB.lowerBound.x + Math.fround(invQ.x * bp.m_bounds[0][p1.upperBounds[0]].value));
                                        this.pairB1.upperBound.y = Math.fround(bp.m_worldAABB.lowerBound.y + Math.fround(invQ.y * bp.m_bounds[1][p1.upperBounds[1]].value));
                                        this.pairB2.lowerBound.x = Math.fround(bp.m_worldAABB.lowerBound.x + Math.fround(invQ.x * bp.m_bounds[0][p2.lowerBounds[0]].value));
                                        this.pairB2.lowerBound.y = Math.fround(bp.m_worldAABB.lowerBound.y + Math.fround(invQ.y * bp.m_bounds[1][p2.lowerBounds[1]].value));
                                        this.pairB2.upperBound.x = Math.fround(bp.m_worldAABB.lowerBound.x + Math.fround(invQ.x * bp.m_bounds[0][p2.upperBounds[0]].value));
                                        this.pairB2.upperBound.y = Math.fround(bp.m_worldAABB.lowerBound.y + Math.fround(invQ.y * bp.m_bounds[1][p2.upperBounds[1]].value));
                                        this.pairX1.x = Math.fround(0.5 * (Math.fround(this.pairB1.lowerBound.x + this.pairB1.upperBound.x)));
                                        this.pairX1.y = Math.fround(0.5 * (Math.fround(this.pairB1.lowerBound.y + this.pairB1.upperBound.y)));
                                        this.pairX2.x = Math.fround(0.5 * (Math.fround(this.pairB2.lowerBound.x + this.pairB2.upperBound.x)));
                                        this.pairX2.y = Math.fround(0.5 * (Math.fround(this.pairB2.lowerBound.y + this.pairB2.upperBound.y)));
                                        this.m_debugDraw.drawSegment(this.pairX1, this.pairX1, this.pairColor);
                                        index = pair.next;
                                    }
                                }
                                ;
                            }
                            ;
                        }
                    }
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_controllerBit) !== 0) {
                        for (let c = this.m_controllerList; c != null; c = c.getNext()) {
                            {
                                c.draw(this.m_debugDraw);
                            }
                            ;
                        }
                    }
                    let bp = this.m_broadPhase;
                    let worldLower = bp.m_worldAABB.lowerBound;
                    let worldUpper = bp.m_worldAABB.upperBound;
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_aabbBit) !== 0) {
                        let invQ = new org.jbox2d.common.Vec2();
                        invQ.set$float$float(Math.fround(1.0 / bp.m_quantizationFactor.x), Math.fround(1.0 / bp.m_quantizationFactor.y));
                        for (let i = 0; i < org.jbox2d.common.Settings.maxProxies; ++i) {
                            {
                                let p = bp.m_proxyPool[i];
                                if (p.isValid() === false) {
                                    continue;
                                }
                                this.aabbB.lowerBound.x = Math.fround(worldLower.x + Math.fround(invQ.x * bp.m_bounds[0][p.lowerBounds[0]].value));
                                this.aabbB.lowerBound.y = Math.fround(worldLower.y + Math.fround(invQ.y * bp.m_bounds[1][p.lowerBounds[1]].value));
                                this.aabbB.upperBound.x = Math.fround(worldLower.x + Math.fround(invQ.x * bp.m_bounds[0][p.upperBounds[0]].value));
                                this.aabbB.upperBound.y = Math.fround(worldLower.y + Math.fround(invQ.y * bp.m_bounds[1][p.upperBounds[1]].value));
                                this.cornerVecs[0].set$float$float(this.aabbB.lowerBound.x, this.aabbB.lowerBound.y);
                                this.cornerVecs[1].set$float$float(this.aabbB.upperBound.x, this.aabbB.lowerBound.y);
                                this.cornerVecs[2].set$float$float(this.aabbB.upperBound.x, this.aabbB.upperBound.y);
                                this.cornerVecs[3].set$float$float(this.aabbB.lowerBound.x, this.aabbB.upperBound.y);
                                this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.aabbColor);
                            }
                            ;
                        }
                    }
                    this.cornerVecs[0].set$float$float(worldLower.x, worldLower.y);
                    this.cornerVecs[1].set$float$float(worldUpper.x, worldLower.y);
                    this.cornerVecs[2].set$float$float(worldUpper.x, worldUpper.y);
                    this.cornerVecs[3].set$float$float(worldLower.x, worldUpper.y);
                    this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.worldColor);
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_obbBit) !== 0) {
                        for (let b = this.m_bodyList; b != null; b = b.getNext()) {
                            {
                                let xf = b.getMemberXForm();
                                for (let s = b.getShapeList(); s != null; s = s.getNext()) {
                                    {
                                        if (s.getType() !== org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE) {
                                            continue;
                                        }
                                        let poly = s;
                                        let obb = poly.getOBB();
                                        let h = obb.extents;
                                        this.cornerVecs[0].set$float$float(-h.x, -h.y);
                                        this.cornerVecs[1].set$float$float(h.x, -h.y);
                                        this.cornerVecs[2].set$float$float(h.x, h.y);
                                        this.cornerVecs[3].set$float$float(-h.x, h.y);
                                        for (let i = 0; i < this.cornerVecs.length; ++i) {
                                            {
                                                org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(obb.R, this.cornerVecs[i], this.cornerVecs[i]);
                                                org.jbox2d.common.XForm.mulToOut(xf, this.cornerVecs[i], this.cornerVecs[i]);
                                            }
                                            ;
                                        }
                                        this.m_debugDraw.drawPolygon(this.cornerVecs, 4, this.obbColor);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    if ((flags & org.jbox2d.dynamics.DebugDraw.e_centerOfMassBit) !== 0) {
                        for (let b = this.m_bodyList; b != null; b = b.getNext()) {
                            {
                                let xf = b.getMemberXForm();
                                xf.position = b.getMemberWorldCenter();
                                this.m_debugDraw.drawXForm(xf);
                            }
                            ;
                        }
                    }
                }
                /**
                 * Enable/disable warm starting. For testing.
                 * @param {boolean} flag
                 */
                setWarmStarting(flag) {
                    this.m_warmStarting = flag;
                }
                /**
                 * Enable/disable position correction. For testing.
                 * @param {boolean} flag
                 */
                setPositionCorrection(flag) {
                    this.m_positionCorrection = flag;
                }
                /**
                 * Enable/disable continuous physics. For testing.
                 * @param {boolean} flag
                 */
                setContinuousPhysics(flag) {
                    this.m_continuousPhysics = flag;
                }
                /**
                 * Perform validation of internal data structures.
                 */
                validate() {
                    this.m_broadPhase.validate();
                }
                /**
                 * Get the number of broad-phase proxies.
                 * @return {number}
                 */
                getProxyCount() {
                    return this.m_broadPhase.m_proxyCount;
                }
                /**
                 * Get the number of broad-phase pairs.
                 * @return {number}
                 */
                getPairCount() {
                    return this.m_broadPhase.m_pairManager.m_pairCount;
                }
                /**
                 * Get the world bounding box.
                 * @return {org.jbox2d.collision.AABB}
                 */
                getWorldAABB() {
                    return this.m_broadPhase.m_worldAABB;
                }
                /**
                 * Return true if the bounding box is within range of the world AABB.
                 * @param {org.jbox2d.collision.AABB} aabb
                 * @return {boolean}
                 */
                inRange(aabb) {
                    return this.m_broadPhase.inRange(aabb);
                }
                /**
                 *
                 * Query the world for all fixtures that intersect a given segment. You provide a shape
                 * pointer buffer of specified size. The number of shapes found is returned, and the buffer
                 * is filled in order of intersection
                 * @param {org.jbox2d.collision.Segment} segment defines the begin and end point of the ray cast, from p1 to p2.
                 * @param {Array} shapes a user allocated shape pointer array of size maxCount (or greater).
                 * @param {number} maxCount the capacity of the shapes array
                 * @param {boolean} solidShapes determines if shapes that the ray starts in are counted as hits.
                 * @param {*} userData passed through the worlds contact filter, with method RayCollide. This can be used to filter valid shapes
                 * @return {number} the number of shapes found
                 */
                raycast(segment, shapes, maxCount, solidShapes, userData) {
                    this.m_raycastSegment = segment;
                    this.m_raycastUserData = userData;
                    this.m_raycastSolidShape = solidShapes;
                    let results = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(maxCount);
                    let count = this.m_broadPhase.querySegment(segment, results, maxCount, this.raycastSortKey);
                    for (let i = 0; i < count; ++i) {
                        {
                            shapes[i] = results[i];
                        }
                        ;
                    }
                    return count;
                }
                /**
                 *
                 * Performs a ray-cast as with {@link #raycast(Segment, Shape[], int, boolean, Object)}, finding the first intersecting shape
                 * @param {org.jbox2d.collision.Segment} segment defines the begin and end point of the ray cast, from p1 to p2
                 * @param lambda returns the hit fraction. You can use this to compute the contact point
                 * p = (1 - lambda) * segment.p1 + lambda * segment.p2.
                 * @param normal returns the normal at the contact point. If there is no intersection, the normal
                 * is not set.
                 * @param {boolean} solidShapes determines if shapes that the ray starts in are counted as hits.
                 * @returns the colliding shape shape, or null if not found
                 * @see #raycast(Segment, Shape[], int, boolean, Object)
                 * @param {org.jbox2d.common.RaycastResult} result
                 * @param {*} userData
                 * @return {org.jbox2d.collision.shapes.Shape}
                 */
                raycastOne(segment, result, solidShapes, userData) {
                    let maxCount = 1;
                    let shapes = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(maxCount);
                    let count = this.raycast(segment, shapes, maxCount, solidShapes, userData);
                    if (count === 0)
                        return null;
                    shapes[0].testSegment(shapes[0].getBody().getMemberXForm(), result, segment, 1.0);
                    return shapes[0];
                }
                /*private*/ raycastSortKeyFunc(data) {
                    let shape = data;
                    let body = shape.getBody();
                    let world = body.getWorld();
                    if (world.m_contactFilter != null && !world.m_contactFilter.rayCollide(world.m_raycastUserData, shape)) {
                        return -1;
                    }
                    let result = new org.jbox2d.common.RaycastResult();
                    let collide = shape.testSegment(body.getMemberXForm(), result, world.m_raycastSegment, 1.0);
                    let lambda = result.lambda;
                    if (world.m_raycastSolidShape && collide === org.jbox2d.collision.SegmentCollide.MISS_COLLIDE) {
                        return -1;
                    }
                    if (!world.m_raycastSolidShape && collide !== org.jbox2d.collision.SegmentCollide.HIT_COLLIDE) {
                        return -1;
                    }
                    return lambda;
                }
            }
            dynamics.World = World;
            World["__class"] = "org.jbox2d.dynamics.World";
            (function (World) {
                class World$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                    }
                    apply(shape) {
                        return this.__parent.raycastSortKeyFunc(shape);
                    }
                }
                World.World$0 = World$0;
                World$0["__interfaces"] = ["org.jbox2d.collision.SortKeyFunc"];
            })(World = dynamics.World || (dynamics.World = {}));
        })(dynamics = jbox2d.dynamics || (jbox2d.dynamics = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * this is used internally, instead use {@link Body#createShape(ShapeDef)}
                 * with a {@link CircleDef}
                 *
                 * @see Body#createShape(ShapeDef)
                 * @see CircleDef
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def
                 * @class
                 * @extends org.jbox2d.collision.shapes.Shape
                 */
                class CircleShape extends org.jbox2d.collision.shapes.Shape {
                    constructor(def) {
                        super(def);
                        if (this.m_radius === undefined)
                            this.m_radius = 0;
                        if (this.m_localPosition === undefined)
                            this.m_localPosition = null;
                        let circleDef = def;
                        this.m_type = org.jbox2d.collision.shapes.ShapeType.CIRCLE_SHAPE;
                        this.m_localPosition = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(circleDef.localPosition);
                        this.m_radius = circleDef.radius;
                    }
                    /**
                     * @see Shape#updateSweepRadius(Vec2)
                     * @param {org.jbox2d.common.Vec2} center
                     */
                    updateSweepRadius(center) {
                        let dx = Math.fround(this.m_localPosition.x - center.x);
                        let dy = Math.fround(this.m_localPosition.y - center.y);
                        this.m_sweepRadius = Math.fround(Math.fround(org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy))) + this.m_radius) - org.jbox2d.common.Settings.toiSlop_$LI$());
                    }
                    static tlCenter_$LI$() { if (CircleShape.tlCenter == null)
                        CircleShape.tlCenter = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlCenter; }
                    ;
                    /**
                     * checks to see if the point is in this shape.
                     *
                     * @see Shape#testPoint(XForm, Vec2)
                     * @param {org.jbox2d.common.XForm} transform
                     * @param {org.jbox2d.common.Vec2} p
                     * @return {boolean}
                     */
                    testPoint(transform, p) {
                        let center = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlCenter_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, center);
                        center.addLocal$org_jbox2d_common_Vec2(transform.position);
                        let d = center.subLocal(p).negateLocal();
                        let ret = org.jbox2d.common.Vec2.dot(d, d) <= Math.fround(this.m_radius * this.m_radius);
                        return ret;
                    }
                    static tlS_$LI$() { if (CircleShape.tlS == null)
                        CircleShape.tlS = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlS; }
                    ;
                    static tlPosition_$LI$() { if (CircleShape.tlPosition == null)
                        CircleShape.tlPosition = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlPosition; }
                    ;
                    static tlR_$LI$() { if (CircleShape.tlR == null)
                        CircleShape.tlR = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlR; }
                    ;
                    /**
                     * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.RaycastResult} out
                     * @param {org.jbox2d.collision.Segment} segment
                     * @param {number} maxLambda
                     * @return {org.jbox2d.collision.SegmentCollide}
                     */
                    testSegment(xf, out, segment, maxLambda) {
                        let position = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlPosition_$LI$());
                        let s = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlS_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_localPosition, position);
                        position.addLocal$org_jbox2d_common_Vec2(xf.position);
                        s.set$org_jbox2d_common_Vec2(segment.p1);
                        s.subLocal(position);
                        let b = Math.fround(org.jbox2d.common.Vec2.dot(s, s) - Math.fround(this.m_radius * this.m_radius));
                        if (b < 0.0) {
                            return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
                        }
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlR_$LI$());
                        r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
                        let c = org.jbox2d.common.Vec2.dot(s, r);
                        let rr = org.jbox2d.common.Vec2.dot(r, r);
                        let sigma = Math.fround(Math.fround(c * c) - Math.fround(rr * b));
                        if (sigma < 0.0 || rr < org.jbox2d.common.Settings.EPSILON) {
                            return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                        }
                        let a = -(Math.fround(c + org.jbox2d.common.MathUtils.sqrt(sigma)));
                        if (0.0 <= a && a <= Math.fround(maxLambda * rr)) {
                            a /= rr;
                            out.lambda = a;
                            out.normal.set$org_jbox2d_common_Vec2(r).mulLocal(a).addLocal$org_jbox2d_common_Vec2(s);
                            out.normal.normalize();
                            return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
                        }
                        return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                    }
                    static tlP_$LI$() { if (CircleShape.tlP == null)
                        CircleShape.tlP = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return CircleShape.tlP; }
                    ;
                    /**
                     * @see Shape#computeAABB(AABB, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform
                     */
                    computeAABB(aabb, transform) {
                        let p = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlP_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, p);
                        p.addLocal$org_jbox2d_common_Vec2(transform.position);
                        aabb.lowerBound.x = Math.fround(p.x - this.m_radius);
                        aabb.lowerBound.y = Math.fround(p.y - this.m_radius);
                        aabb.upperBound.x = Math.fround(p.x + this.m_radius);
                        aabb.upperBound.y = Math.fround(p.y + this.m_radius);
                    }
                    /**
                     * @see Shape#computeSweptAABB(AABB, XForm, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform1
                     * @param {org.jbox2d.common.XForm} transform2
                     */
                    computeSweptAABB(aabb, transform1, transform2) {
                        let p1x = Math.fround(Math.fround(transform1.position.x + Math.fround(transform1.R.col1.x * this.m_localPosition.x)) + Math.fround(transform1.R.col2.x * this.m_localPosition.y));
                        let p1y = Math.fround(Math.fround(transform1.position.y + Math.fround(transform1.R.col1.y * this.m_localPosition.x)) + Math.fround(transform1.R.col2.y * this.m_localPosition.y));
                        let p2x = Math.fround(Math.fround(transform2.position.x + Math.fround(transform2.R.col1.x * this.m_localPosition.x)) + Math.fround(transform2.R.col2.x * this.m_localPosition.y));
                        let p2y = Math.fround(Math.fround(transform2.position.y + Math.fround(transform2.R.col1.y * this.m_localPosition.x)) + Math.fround(transform2.R.col2.y * this.m_localPosition.y));
                        let lowerx = p1x < p2x ? p1x : p2x;
                        let lowery = p1y < p2y ? p1y : p2y;
                        let upperx = p1x > p2x ? p1x : p2x;
                        let uppery = p1y > p2y ? p1y : p2y;
                        aabb.lowerBound.x = Math.fround(lowerx - this.m_radius);
                        aabb.lowerBound.y = Math.fround(lowery - this.m_radius);
                        aabb.upperBound.x = Math.fround(upperx + this.m_radius);
                        aabb.upperBound.y = Math.fround(uppery + this.m_radius);
                    }
                    /**
                     * @see Shape#computeMass(MassData)
                     * @param {org.jbox2d.collision.MassData} massData
                     */
                    computeMass(massData) {
                        massData.mass = Math.fround(Math.fround(Math.fround(this.m_density * org.jbox2d.common.MathUtils.PI_$LI$()) * this.m_radius) * this.m_radius);
                        massData.center.set$org_jbox2d_common_Vec2(this.m_localPosition);
                        massData.I = Math.fround(massData.mass * (Math.fround(Math.fround(Math.fround(0.5 * this.m_radius) * this.m_radius) + org.jbox2d.common.Vec2.dot(this.m_localPosition, this.m_localPosition))));
                    }
                    getRadius() {
                        return this.m_radius;
                    }
                    /**
                     * Returns a copy of the local position
                     *
                     * @return
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getLocalPosition() {
                        return ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(this.m_localPosition);
                    }
                    /**
                     * Returns the member variable of the local position. Don't change this.
                     *
                     * @return
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getMemberLocalPosition() {
                        return this.m_localPosition;
                    }
                    computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c) {
                        let p = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(CircleShape.tlP_$LI$());
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_localPosition, p);
                        let l = -(Math.fround(org.jbox2d.common.Vec2.dot(normal, p) - offset));
                        if (l < Math.fround(-this.m_radius + org.jbox2d.common.Settings.EPSILON)) {
                            return 0;
                        }
                        if (l > this.m_radius) {
                            c.set$org_jbox2d_common_Vec2(p);
                            return Math.fround(Math.fround(org.jbox2d.common.Settings.pi_$LI$() * this.m_radius) * this.m_radius);
                        }
                        let r2 = Math.fround(this.m_radius * this.m_radius);
                        let l2 = Math.fround(l * l);
                        let area = Math.fround((r2 * (Math.asin(Math.fround(l / this.m_radius)) + Math.fround(org.jbox2d.common.Settings.pi_$LI$() / 2.0)) + Math.fround(l * org.jbox2d.common.MathUtils.sqrt(Math.fround(r2 - l2)))));
                        let com = (Math.fround(Math.fround(Math.fround(-2.0 / 3.0) * org.jbox2d.common.MathUtils.pow(Math.fround(r2 - l2), 1.5)) / area));
                        c.x = Math.fround(p.x + Math.fround(normal.x * com));
                        c.y = Math.fround(p.y + Math.fround(normal.y * com));
                        return area;
                    }
                    /**
                     * @see Shape#computeSubmergedArea(Vec2, float, XForm, Vec2)
                     * @param {org.jbox2d.common.Vec2} normal
                     * @param {number} offset
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} c
                     * @return {number}
                     */
                    computeSubmergedArea(normal, offset, xf, c) {
                        if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof org.jbox2d.common.Vec2) || c === null)) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
                        }
                        else if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                shapes.CircleShape = CircleShape;
                CircleShape["__class"] = "org.jbox2d.collision.shapes.CircleShape";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Don't use this.  Instead create using {@link Body#createShape(ShapeDef)} with an
                 * {@link EdgeChainDef}, not the constructor here.
                 * @see Body#createShape(ShapeDef)
                 * @see EdgeChainDef
                 * @param {org.jbox2d.common.Vec2} v1
                 * @param {org.jbox2d.common.Vec2} v2
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def
                 * @class
                 * @extends org.jbox2d.collision.shapes.Shape
                 * @author daniel
                 */
                class EdgeShape extends org.jbox2d.collision.shapes.Shape {
                    constructor(v1, v2, def) {
                        super(def);
                        if (this.m_v1 === undefined)
                            this.m_v1 = null;
                        if (this.m_v2 === undefined)
                            this.m_v2 = null;
                        if (this.m_coreV1 === undefined)
                            this.m_coreV1 = null;
                        if (this.m_coreV2 === undefined)
                            this.m_coreV2 = null;
                        if (this.m_length === undefined)
                            this.m_length = 0;
                        if (this.m_normal === undefined)
                            this.m_normal = null;
                        if (this.m_direction === undefined)
                            this.m_direction = null;
                        if (this.m_cornerDir1 === undefined)
                            this.m_cornerDir1 = null;
                        if (this.m_cornerDir2 === undefined)
                            this.m_cornerDir2 = null;
                        if (this.m_cornerConvex1 === undefined)
                            this.m_cornerConvex1 = false;
                        if (this.m_cornerConvex2 === undefined)
                            this.m_cornerConvex2 = false;
                        if (this.m_nextEdge === undefined)
                            this.m_nextEdge = null;
                        if (this.m_prevEdge === undefined)
                            this.m_prevEdge = null;
                        this.m_type = org.jbox2d.collision.shapes.ShapeType.EDGE_SHAPE;
                        this.m_prevEdge = null;
                        this.m_nextEdge = null;
                        this.m_v1 = v1;
                        this.m_v2 = v2;
                        this.m_direction = this.m_v2.sub(this.m_v1);
                        this.m_length = this.m_direction.normalize();
                        this.m_normal = new org.jbox2d.common.Vec2(this.m_direction.y, -this.m_direction.x);
                        this.m_coreV1 = (this.m_normal.sub(this.m_direction)).mulLocal(-org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(this.m_v1);
                        this.m_coreV2 = (this.m_normal.add(this.m_direction)).mulLocal(-org.jbox2d.common.Settings.toiSlop_$LI$()).addLocal$org_jbox2d_common_Vec2(this.m_v2);
                        this.m_cornerDir1 = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(this.m_normal);
                        this.m_cornerDir2 = this.m_normal.mul(-1.0);
                    }
                    /**
                     * @see Shape#updateSweepRadius(Vec2)
                     * @param {org.jbox2d.common.Vec2} center
                     */
                    updateSweepRadius(center) {
                        let dx = Math.fround(this.m_coreV1.x - center.x);
                        let dy = Math.fround(this.m_coreV1.y - center.y);
                        let d1 = Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy));
                        let dx2 = Math.fround(this.m_coreV2.x - center.x);
                        let dy2 = Math.fround(this.m_coreV2.y - center.y);
                        let d2 = Math.fround(Math.fround(dx2 * dx2) + Math.fround(dy2 * dy2));
                        this.m_sweepRadius = org.jbox2d.common.MathUtils.sqrt(d1 > d2 ? d1 : d2);
                    }
                    /**
                     * @see Shape#testPoint(XForm, Vec2)
                     * @param {org.jbox2d.common.XForm} transform
                     * @param {org.jbox2d.common.Vec2} p
                     * @return {boolean}
                     */
                    testPoint(transform, p) {
                        return false;
                    }
                    static tlR_$LI$() { if (EdgeShape.tlR == null)
                        EdgeShape.tlR = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlR; }
                    ;
                    static tlV1_$LI$() { if (EdgeShape.tlV1 == null)
                        EdgeShape.tlV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV1; }
                    ;
                    static tlD_$LI$() { if (EdgeShape.tlD == null)
                        EdgeShape.tlD = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlD; }
                    ;
                    static tlN_$LI$() { if (EdgeShape.tlN == null)
                        EdgeShape.tlN = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlN; }
                    ;
                    static tlB_$LI$() { if (EdgeShape.tlB == null)
                        EdgeShape.tlB = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlB; }
                    ;
                    /**
                     * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.RaycastResult} out
                     * @param {org.jbox2d.collision.Segment} segment
                     * @param {number} maxLambda
                     * @return {org.jbox2d.collision.SegmentCollide}
                     */
                    testSegment(xf, out, segment, maxLambda) {
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlR_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlV1_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlD_$LI$());
                        let n = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlN_$LI$());
                        let b = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlB_$LI$());
                        r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_v1, v1);
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_v2, d);
                        d.subLocal(v1);
                        org.jbox2d.common.Vec2.crossToOut$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(d, 1.0, n);
                        let k_slop = Math.fround(100.0 * org.jbox2d.common.Settings.EPSILON);
                        let denom = -org.jbox2d.common.Vec2.dot(r, n);
                        if (denom > k_slop) {
                            b.set$org_jbox2d_common_Vec2(segment.p1).subLocal(v1);
                            let a = org.jbox2d.common.Vec2.dot(b, n);
                            if (0.0 <= a && a <= Math.fround(maxLambda * denom)) {
                                let mu2 = Math.fround(Math.fround(-r.x * b.y) + Math.fround(r.y * b.x));
                                if (Math.fround(-k_slop * denom) <= mu2 && mu2 <= Math.fround(denom * (Math.fround(1.0 + k_slop)))) {
                                    a /= denom;
                                    n.normalize();
                                    out.lambda = a;
                                    out.normal.set$org_jbox2d_common_Vec2(n);
                                    return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
                                }
                            }
                        }
                        return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                    }
                    static tlV2_$LI$() { if (EdgeShape.tlV2 == null)
                        EdgeShape.tlV2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV2; }
                    ;
                    /**
                     * @see Shape#computeAABB(AABB, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform
                     */
                    computeAABB(aabb, transform) {
                        org.jbox2d.common.XForm.mulToOut(transform, this.m_v1, aabb.lowerBound);
                        let v2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlV2_$LI$());
                        org.jbox2d.common.XForm.mulToOut(transform, this.m_v2, v2);
                        org.jbox2d.common.Vec2.maxToOut(aabb.lowerBound, v2, aabb.upperBound);
                        org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, v2, aabb.lowerBound);
                    }
                    static tlSwept1_$LI$() { if (EdgeShape.tlSwept1 == null)
                        EdgeShape.tlSwept1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept1; }
                    ;
                    static tlSwept2_$LI$() { if (EdgeShape.tlSwept2 == null)
                        EdgeShape.tlSwept2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept2; }
                    ;
                    static tlSwept3_$LI$() { if (EdgeShape.tlSwept3 == null)
                        EdgeShape.tlSwept3 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept3; }
                    ;
                    static tlSwept4_$LI$() { if (EdgeShape.tlSwept4 == null)
                        EdgeShape.tlSwept4 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSwept4; }
                    ;
                    /**
                     * @see Shape#computeSweptAABB(AABB, XForm, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform1
                     * @param {org.jbox2d.common.XForm} transform2
                     */
                    computeSweptAABB(aabb, transform1, transform2) {
                        let sweptV1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSwept1_$LI$());
                        let sweptV2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSwept2_$LI$());
                        let sweptV3 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSwept3_$LI$());
                        let sweptV4 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSwept4_$LI$());
                        org.jbox2d.common.XForm.mulToOut(transform1, this.m_v1, sweptV1);
                        org.jbox2d.common.XForm.mulToOut(transform1, this.m_v2, sweptV2);
                        org.jbox2d.common.XForm.mulToOut(transform2, this.m_v1, sweptV3);
                        org.jbox2d.common.XForm.mulToOut(transform2, this.m_v2, sweptV4);
                        org.jbox2d.common.Vec2.minToOut(sweptV1, sweptV2, aabb.lowerBound);
                        org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, sweptV3, aabb.lowerBound);
                        org.jbox2d.common.Vec2.minToOut(aabb.lowerBound, sweptV4, aabb.lowerBound);
                        org.jbox2d.common.Vec2.maxToOut(sweptV1, sweptV2, aabb.upperBound);
                        org.jbox2d.common.Vec2.maxToOut(aabb.upperBound, sweptV3, aabb.upperBound);
                        org.jbox2d.common.Vec2.maxToOut(aabb.upperBound, sweptV4, aabb.upperBound);
                    }
                    /**
                     * @see Shape#computeMass(MassData)
                     * @param {org.jbox2d.collision.MassData} massData
                     */
                    computeMass(massData) {
                        massData.mass = 0;
                        massData.center.set$org_jbox2d_common_Vec2(this.m_v1);
                        massData.I = 0;
                    }
                    static tlSupportV1_$LI$() { if (EdgeShape.tlSupportV1 == null)
                        EdgeShape.tlSupportV1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSupportV1; }
                    ;
                    static tlSupportV2_$LI$() { if (EdgeShape.tlSupportV2 == null)
                        EdgeShape.tlSupportV2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlSupportV2; }
                    ;
                    /**
                     * @see SupportsGenericDistance#support(Vec2, XForm, Vec2)
                     * @param {org.jbox2d.common.Vec2} dest
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} d
                     */
                    support(dest, xf, d) {
                        let supportV1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSupportV1_$LI$());
                        let supportV2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlSupportV2_$LI$());
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV1, supportV1);
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV2, supportV2);
                        dest.set$org_jbox2d_common_Vec2(org.jbox2d.common.Vec2.dot(supportV1, d) > org.jbox2d.common.Vec2.dot(supportV2, d) ? supportV1 : supportV2);
                    }
                    setPrevEdge(edge, core, cornerDir, convex) {
                        this.m_prevEdge = edge;
                        this.m_coreV1.set$org_jbox2d_common_Vec2(core);
                        this.m_cornerDir1.set$org_jbox2d_common_Vec2(cornerDir);
                        this.m_cornerConvex1 = convex;
                    }
                    setNextEdge(edge, core, cornerDir, convex) {
                        this.m_nextEdge = edge;
                        this.m_coreV2.set$org_jbox2d_common_Vec2(core);
                        this.m_cornerDir2.set$org_jbox2d_common_Vec2(cornerDir);
                        this.m_cornerConvex2 = convex;
                    }
                    /**
                     * Linear distance from vertex1 to vertex2
                     * @return {number}
                     */
                    getLength() {
                        return this.m_length;
                    }
                    /**
                     * Local position of vertex in parent body
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getVertex1() {
                        return this.m_v1;
                    }
                    /**
                     * Local position of vertex in parent body
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getVertex2() {
                        return this.m_v2;
                    }
                    /**
                     * "Core" vertex with TOI slop for b2Distance functions
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getCoreVertex1() {
                        return this.m_coreV1;
                    }
                    /**
                     * "Core" vertex with TOI slop for b2Distance functions
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getCoreVertex2() {
                        return this.m_coreV2;
                    }
                    /**
                     * Perpendecular unit vector point, pointing from the solid side to the empty side.
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getNormalVector() {
                        return this.m_normal;
                    }
                    /**
                     * Parallel unit vector, pointing from vertex1 to vertex2
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getDirectionVector() {
                        return this.m_direction;
                    }
                    getCorner1Vector() {
                        return this.m_cornerDir1;
                    }
                    getCorner2Vector() {
                        return this.m_cornerDir2;
                    }
                    /**
                     * Get the next edge in the chain.
                     * @return {org.jbox2d.collision.shapes.EdgeShape}
                     */
                    getNextEdge() {
                        return this.m_nextEdge;
                    }
                    /**
                     * Get the previous edge in the chain.
                     * @return {org.jbox2d.collision.shapes.EdgeShape}
                     */
                    getPrevEdge() {
                        return this.m_prevEdge;
                    }
                    /**
                     * @see SupportsGenericDistance#getFirstVertexToOut(XForm, Vec2)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} out
                     */
                    getFirstVertexToOut(xf, out) {
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_coreV1, out);
                    }
                    corner1IsConvex() {
                        return this.m_cornerConvex1;
                    }
                    corner2IsConvex() {
                        return this.m_cornerConvex2;
                    }
                    static tlV0_$LI$() { if (EdgeShape.tlV0 == null)
                        EdgeShape.tlV0 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlV0; }
                    ;
                    static tlTemp_$LI$() { if (EdgeShape.tlTemp == null)
                        EdgeShape.tlTemp = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlTemp; }
                    ;
                    static tlE1_$LI$() { if (EdgeShape.tlE1 == null)
                        EdgeShape.tlE1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlE1; }
                    ;
                    static tlE2_$LI$() { if (EdgeShape.tlE2 == null)
                        EdgeShape.tlE2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return EdgeShape.tlE2; }
                    ;
                    computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c) {
                        let v0 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlV0_$LI$());
                        let v1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlV1_$LI$());
                        let v2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlV2_$LI$());
                        let temp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlTemp_$LI$());
                        v0.set$org_jbox2d_common_Vec2(normal).mul(offset);
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_v1, v1);
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_v2, v2);
                        let d1 = Math.fround(org.jbox2d.common.Vec2.dot(normal, v1) - offset);
                        let d2 = Math.fround(org.jbox2d.common.Vec2.dot(normal, v2) - offset);
                        if (d1 > 0.0) {
                            if (d2 > 0.0) {
                                return 0.0;
                            }
                            else {
                                temp.set$org_jbox2d_common_Vec2(v2).mulLocal(Math.fround(d1 / (Math.fround(d1 - d2))));
                                v1.mulLocal(Math.fround(-d2 / (Math.fround(d1 - d2)))).addLocal$org_jbox2d_common_Vec2(temp);
                            }
                        }
                        else {
                            if (d2 > 0.0) {
                                temp.set$org_jbox2d_common_Vec2(v1).mulLocal(Math.fround(-d2 / (Math.fround(d1 - d2))));
                                v2.mulLocal(Math.fround(d1 / (Math.fround(d1 - d2)))).addLocal$org_jbox2d_common_Vec2(temp);
                            }
                            else {
                            }
                        }
                        let e1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlE1_$LI$());
                        let e2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(EdgeShape.tlE2_$LI$());
                        let k_inv3 = Math.fround(1.0 / 3.0);
                        c.x = Math.fround(k_inv3 * (Math.fround(Math.fround(v0.x + v1.x) + v2.x)));
                        c.y = Math.fround(k_inv3 * (Math.fround(Math.fround(v0.y + v1.y) + v2.y)));
                        e1.set$org_jbox2d_common_Vec2(v1).subLocal(v0);
                        e2.set$org_jbox2d_common_Vec2(v2).subLocal(v0);
                        return Math.fround(0.5 * org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2));
                    }
                    computeSubmergedArea(normal, offset, xf, c) {
                        if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof org.jbox2d.common.Vec2) || c === null)) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
                        }
                        else if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                shapes.EdgeShape = EdgeShape;
                EdgeShape["__class"] = "org.jbox2d.collision.shapes.EdgeShape";
                EdgeShape["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * Point shape.  Like a circle shape of zero radius, except
                 * that it has a finite mass.
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def
                 * @class
                 * @extends org.jbox2d.collision.shapes.Shape
                 */
                class PointShape extends org.jbox2d.collision.shapes.Shape {
                    constructor(def) {
                        super(def);
                        if (this.m_localPosition === undefined)
                            this.m_localPosition = null;
                        if (this.m_mass === undefined)
                            this.m_mass = 0;
                        let pointDef = def;
                        this.m_type = org.jbox2d.collision.shapes.ShapeType.POINT_SHAPE;
                        this.m_localPosition = ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(pointDef.localPosition);
                        this.m_mass = pointDef.mass;
                    }
                    static tlP_$LI$() { if (PointShape.tlP == null)
                        PointShape.tlP = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlP; }
                    ;
                    /**
                     * @see Shape#computeAABB(AABB, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform
                     */
                    computeAABB(aabb, transform) {
                        let p = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlP_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform.R, this.m_localPosition, p);
                        p.add(transform.position);
                        aabb.lowerBound.set$float$float(Math.fround(p.x - org.jbox2d.common.Settings.EPSILON), Math.fround(p.y - org.jbox2d.common.Settings.EPSILON));
                        aabb.upperBound.set$float$float(Math.fround(p.x + org.jbox2d.common.Settings.EPSILON), Math.fround(p.y + org.jbox2d.common.Settings.EPSILON));
                    }
                    /**
                     * @see Shape#computeMass(MassData)
                     * @param {org.jbox2d.collision.MassData} massData
                     */
                    computeMass(massData) {
                        massData.mass = this.m_mass;
                        massData.center.set$org_jbox2d_common_Vec2(this.m_localPosition);
                        massData.I = 0.0;
                    }
                    static tlSwept1_$LI$() { if (PointShape.tlSwept1 == null)
                        PointShape.tlSwept1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlSwept1; }
                    ;
                    static tlSwept2_$LI$() { if (PointShape.tlSwept2 == null)
                        PointShape.tlSwept2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlSwept2; }
                    ;
                    /**
                     * @see Shape#computeSweptAABB(AABB, XForm, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform1
                     * @param {org.jbox2d.common.XForm} transform2
                     */
                    computeSweptAABB(aabb, transform1, transform2) {
                        let sweptP1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlSwept1_$LI$());
                        let sweptP2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlSwept2_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform2.R, this.m_localPosition, sweptP1);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(transform2.R, this.m_localPosition, sweptP2);
                        org.jbox2d.common.Vec2.minToOut(sweptP1, sweptP2, aabb.lowerBound);
                        org.jbox2d.common.Vec2.maxToOut(sweptP1, sweptP2, aabb.upperBound);
                        aabb.lowerBound.x -= org.jbox2d.common.Settings.EPSILON;
                        aabb.lowerBound.y -= org.jbox2d.common.Settings.EPSILON;
                        aabb.upperBound.x += org.jbox2d.common.Settings.EPSILON;
                        aabb.upperBound.y += org.jbox2d.common.Settings.EPSILON;
                    }
                    /**
                     * @see Shape#testPoint(XForm, Vec2)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} p
                     * @return {boolean}
                     */
                    testPoint(xf, p) {
                        return false;
                    }
                    static tlS_$LI$() { if (PointShape.tlS == null)
                        PointShape.tlS = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlS; }
                    ;
                    static tlPosition_$LI$() { if (PointShape.tlPosition == null)
                        PointShape.tlPosition = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlPosition; }
                    ;
                    static tlR_$LI$() { if (PointShape.tlR == null)
                        PointShape.tlR = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PointShape.tlR; }
                    ;
                    /**
                     * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.RaycastResult} out
                     * @param {org.jbox2d.collision.Segment} segment
                     * @param {number} maxLambda
                     * @return {org.jbox2d.collision.SegmentCollide}
                     */
                    testSegment(xf, out, segment, maxLambda) {
                        let position = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlPosition_$LI$());
                        let s = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlS_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_localPosition, position);
                        position.addLocal$org_jbox2d_common_Vec2(xf.position);
                        s.set$org_jbox2d_common_Vec2(segment.p1);
                        s.subLocal(position);
                        let b = org.jbox2d.common.Vec2.dot(s, s);
                        if (b < 0.0) {
                            return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
                        }
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PointShape.tlR_$LI$());
                        r.set$org_jbox2d_common_Vec2(segment.p2).subLocal(segment.p1);
                        let c = org.jbox2d.common.Vec2.dot(s, r);
                        let rr = org.jbox2d.common.Vec2.dot(r, r);
                        let sigma = Math.fround(Math.fround(c * c) - Math.fround(rr * b));
                        if (sigma < 0.0 || rr < org.jbox2d.common.Settings.EPSILON) {
                            return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                        }
                        let a = -(Math.fround(c + org.jbox2d.common.MathUtils.sqrt(sigma)));
                        if (0.0 <= a && a <= Math.fround(maxLambda * rr)) {
                            a /= rr;
                            out.lambda = a;
                            out.normal.set$org_jbox2d_common_Vec2(r).mulLocal(a).addLocal$org_jbox2d_common_Vec2(s);
                            out.normal.normalize();
                            return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
                        }
                        return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                    }
                    /**
                     * @see Shape#updateSweepRadius(Vec2)
                     * @param {org.jbox2d.common.Vec2} center
                     */
                    updateSweepRadius(center) {
                        let dx = Math.fround(this.m_localPosition.x - center.x);
                        let dy = Math.fround(this.m_localPosition.y - center.y);
                        this.m_sweepRadius = Math.fround(org.jbox2d.common.MathUtils.sqrt(Math.fround(Math.fround(dx * dx) + Math.fround(dy * dy))) - org.jbox2d.common.Settings.toiSlop_$LI$());
                    }
                    /**
                     * @return {org.jbox2d.common.Vec2} a copy of local position
                     */
                    getLocalPosition() {
                        return ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(this.m_localPosition);
                    }
                    /**
                     * This is the member variable for the local position.
                     * Don't change this.
                     * @return
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getMemberLocalPosition() {
                        return this.m_localPosition;
                    }
                    getMass() {
                        return this.m_mass;
                    }
                }
                shapes.PointShape = PointShape;
                PointShape["__class"] = "org.jbox2d.collision.shapes.PointShape";
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
(function (org) {
    var jbox2d;
    (function (jbox2d) {
        var collision;
        (function (collision) {
            var shapes;
            (function (shapes) {
                /**
                 * A convex polygon shape.  Create using Body.createShape(ShapeDef), not the constructor here.
                 * @param {org.jbox2d.collision.shapes.ShapeDef} def
                 * @class
                 * @extends org.jbox2d.collision.shapes.Shape
                 */
                class PolygonShape extends org.jbox2d.collision.shapes.Shape {
                    constructor(def) {
                        super(def);
                        if (this.m_centroid === undefined)
                            this.m_centroid = null;
                        if (this.m_obb === undefined)
                            this.m_obb = null;
                        if (this.m_vertices === undefined)
                            this.m_vertices = null;
                        if (this.m_normals === undefined)
                            this.m_normals = null;
                        if (this.m_coreVertices === undefined)
                            this.m_coreVertices = null;
                        if (this.m_vertexCount === undefined)
                            this.m_vertexCount = 0;
                        this.m_type = org.jbox2d.collision.shapes.ShapeType.POLYGON_SHAPE;
                        let poly = def;
                        this.m_vertexCount = poly.getVertexCount();
                        this.m_vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.m_vertexCount);
                        this.m_normals = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.m_vertexCount);
                        this.m_coreVertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.m_vertexCount);
                        this.m_obb = new org.jbox2d.collision.OBB();
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                this.m_vertices[i] = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(/* get */ poly.vertices[i]);
                            }
                            ;
                        }
                        let edge = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlEdge_$LI$());
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                let i1 = i;
                                let i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
                                edge.set$org_jbox2d_common_Vec2(this.m_vertices[i2]).subLocal(this.m_vertices[i1]);
                                this.m_normals[i] = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$float(edge, 1.0);
                                this.m_normals[i].normalize();
                            }
                            ;
                        }
                        if (PolygonShape.m_debug) {
                            for (let i = 0; i < this.m_vertexCount; ++i) {
                                {
                                    for (let j = 0; j < this.m_vertexCount; ++j) {
                                        {
                                            if (j === i || j === (i + 1) % this.m_vertexCount) {
                                                continue;
                                            }
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                            for (let i = 1; i < this.m_vertexCount; ++i) {
                                {
                                    let cross = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(this.m_normals[i - 1], this.m_normals[i]);
                                    cross = org.jbox2d.common.MathUtils.clamp$float$float$float(cross, -1.0, 1.0);
                                    let angle = Math.fround(Math.asin(cross));
                                }
                                ;
                            }
                        }
                        this.m_centroid = PolygonShape.computeCentroid(poly.vertices);
                        PolygonShape.computeOBB(this.m_obb, this.m_vertices);
                        let v = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlV_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlD_$LI$());
                        let A = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlA_$LI$());
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                let i1 = i - 1 >= 0 ? i - 1 : this.m_vertexCount - 1;
                                let i2 = i;
                                let n1 = this.m_normals[i1];
                                let n2 = this.m_normals[i2];
                                v.set$org_jbox2d_common_Vec2(this.m_vertices[i]).subLocal(this.m_centroid);
                                d.x = Math.fround(org.jbox2d.common.Vec2.dot(n1, v) - org.jbox2d.common.Settings.toiSlop_$LI$());
                                d.y = Math.fround(org.jbox2d.common.Vec2.dot(n2, v) - org.jbox2d.common.Settings.toiSlop_$LI$());
                                if ((d.x < 0.0 || d.y < 0.0)) {
                                    console.info("Error, polygon extents less than b2_toiSlop, dumping details: ");
                                    console.info("d.x: " + d.x + "d.y: " + d.y);
                                    console.info("n1: " + n1 + "; n2: " + n2);
                                    console.info("v: " + v);
                                }
                                A.col1.x = n1.x;
                                A.col2.x = n1.y;
                                A.col1.y = n2.x;
                                A.col2.y = n2.y;
                                this.m_coreVertices[i] = A.solve(d).addLocal$org_jbox2d_common_Vec2(this.m_centroid);
                            }
                            ;
                        }
                        if (PolygonShape.m_debug) {
                            console.info("\nDumping polygon shape...");
                            console.info("Vertices: ");
                            for (let i = 0; i < this.m_vertexCount; ++i) {
                                {
                                    console.info(this.m_vertices[i]);
                                }
                                ;
                            }
                            console.info("Core Vertices: ");
                            for (let i = 0; i < this.m_vertexCount; ++i) {
                                {
                                    console.info(this.m_coreVertices[i]);
                                }
                                ;
                            }
                            console.info("Normals: ");
                            for (let i = 0; i < this.m_vertexCount; ++i) {
                                {
                                    console.info(this.m_normals[i]);
                                }
                                ;
                            }
                            console.info("Centroid: " + this.m_centroid);
                        }
                    }
                    static tlEdge_$LI$() { if (PolygonShape.tlEdge == null)
                        PolygonShape.tlEdge = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlEdge; }
                    ;
                    static tlV_$LI$() { if (PolygonShape.tlV == null)
                        PolygonShape.tlV = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlV; }
                    ;
                    static tlD_$LI$() { if (PolygonShape.tlD == null)
                        PolygonShape.tlD = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlD; }
                    ;
                    static tlA_$LI$() { if (PolygonShape.tlA == null)
                        PolygonShape.tlA = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return PolygonShape.tlA; }
                    ;
                    /**
                     * @see Shape#updateSweepRadius(Vec2)
                     * @param {org.jbox2d.common.Vec2} center
                     */
                    updateSweepRadius(center) {
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlD_$LI$());
                        this.m_sweepRadius = 0.0;
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                d.set$org_jbox2d_common_Vec2(this.m_coreVertices[i]);
                                d.subLocal(center);
                                this.m_sweepRadius = org.jbox2d.common.MathUtils.max$float$float(this.m_sweepRadius, d.length());
                            }
                            ;
                        }
                    }
                    static tlTemp_$LI$() { if (PolygonShape.tlTemp == null)
                        PolygonShape.tlTemp = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlTemp; }
                    ;
                    static tlPLocal_$LI$() { if (PolygonShape.tlPLocal == null)
                        PolygonShape.tlPLocal = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlPLocal; }
                    ;
                    /**
                     * @see Shape#testPoint(XForm, Vec2)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} p
                     * @return {boolean}
                     */
                    testPoint(xf, p) {
                        let temp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlTemp_$LI$());
                        let pLocal = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlPLocal_$LI$());
                        temp.set$org_jbox2d_common_Vec2(p);
                        temp.subLocal(xf.position);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, temp, pLocal);
                        if (PolygonShape.m_debug) {
                            console.info("--testPoint debug--");
                            console.info("Vertices: ");
                            for (let i = 0; i < this.m_vertexCount; ++i) {
                                {
                                    console.info(this.m_vertices[i]);
                                }
                                ;
                            }
                            console.info("pLocal: " + pLocal);
                        }
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                temp.set$org_jbox2d_common_Vec2(pLocal);
                                temp.subLocal(this.m_vertices[i]);
                                let dot = org.jbox2d.common.Vec2.dot(this.m_normals[i], temp);
                                if (dot > 0.0) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    }
                    static tlP1_$LI$() { if (PolygonShape.tlP1 == null)
                        PolygonShape.tlP1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP1; }
                    ;
                    static tlP2_$LI$() { if (PolygonShape.tlP2 == null)
                        PolygonShape.tlP2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP2; }
                    ;
                    /**
                     * @see Shape#testSegment(XForm, RaycastResult, Segment, float)
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.RaycastResult} out
                     * @param {org.jbox2d.collision.Segment} segment
                     * @param {number} maxLambda
                     * @return {org.jbox2d.collision.SegmentCollide}
                     */
                    testSegment(xf, out, segment, maxLambda) {
                        let lower = 0.0;
                        let upper = maxLambda;
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlP1_$LI$());
                        let p2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlP2_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlD_$LI$());
                        let temp = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlTemp_$LI$());
                        p1.set$org_jbox2d_common_Vec2(segment.p1).subLocal(xf.position);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, p1, p1);
                        p2.set$org_jbox2d_common_Vec2(segment.p2).subLocal(xf.position);
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, p2, p2);
                        d.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
                        let index = -1;
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                temp.set$org_jbox2d_common_Vec2(this.m_vertices[i]).subLocal(p1);
                                let numerator = org.jbox2d.common.Vec2.dot(this.m_normals[i], temp);
                                let denominator = org.jbox2d.common.Vec2.dot(this.m_normals[i], d);
                                if (denominator === 0.0) {
                                    if (numerator < 0.0) {
                                        return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                                    }
                                }
                                if (denominator < 0.0 && numerator < Math.fround(lower * denominator)) {
                                    lower = Math.fround(numerator / denominator);
                                    index = i;
                                }
                                else if (denominator > 0.0 && numerator < Math.fround(upper * denominator)) {
                                    upper = Math.fround(numerator / denominator);
                                }
                                if (upper < lower) {
                                    return org.jbox2d.collision.SegmentCollide.MISS_COLLIDE;
                                }
                            }
                            ;
                        }
                        if (index >= 0) {
                            out.lambda = lower;
                            org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_normals[index], out.normal);
                            return org.jbox2d.collision.SegmentCollide.HIT_COLLIDE;
                        }
                        out.lambda = 0.0;
                        return org.jbox2d.collision.SegmentCollide.STARTS_INSIDE_COLLIDE;
                    }
                    static tlSupDLocal_$LI$() { if (PolygonShape.tlSupDLocal == null)
                        PolygonShape.tlSupDLocal = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlSupDLocal; }
                    ;
                    /**
                     * Get the support point in the given world direction.
                     * Use the supplied transform.
                     * @see SupportsGenericDistance#support(Vec2, XForm, Vec2)
                     * @param {org.jbox2d.common.Vec2} dest
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} d
                     */
                    support(dest, xf, d) {
                        let supportDLocal = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlSupDLocal_$LI$());
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, d, supportDLocal);
                        let bestIndex = 0;
                        let bestValue = org.jbox2d.common.Vec2.dot(this.m_coreVertices[0], supportDLocal);
                        for (let i = 1; i < this.m_vertexCount; ++i) {
                            {
                                let value = org.jbox2d.common.Vec2.dot(this.m_coreVertices[i], supportDLocal);
                                if (value > bestValue) {
                                    bestIndex = i;
                                    bestValue = value;
                                }
                            }
                            ;
                        }
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_coreVertices[bestIndex], dest);
                    }
                    static tlPRef_$LI$() { if (PolygonShape.tlPRef == null)
                        PolygonShape.tlPRef = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlPRef; }
                    ;
                    static tlE1_$LI$() { if (PolygonShape.tlE1 == null)
                        PolygonShape.tlE1 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlE1; }
                    ;
                    static tlE2_$LI$() { if (PolygonShape.tlE2 == null)
                        PolygonShape.tlE2 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlE2; }
                    ;
                    static computeCentroid(vs) {
                        let count = vs.length;
                        let c = new org.jbox2d.common.Vec2();
                        let area = 0.0;
                        let pRef = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlPRef_$LI$());
                        pRef.setZero();
                        let inv3 = Math.fround(1.0 / 3.0);
                        let e1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE1_$LI$());
                        let e2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE2_$LI$());
                        let p1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlP1_$LI$());
                        for (let i = 0; i < count; ++i) {
                            {
                                p1.set$org_jbox2d_common_Vec2(pRef);
                                let p2 = vs[i];
                                let p3 = i + 1 < count ? vs[i + 1] : vs[0];
                                e1.set$org_jbox2d_common_Vec2(p2).subLocal(p1);
                                e2.set$org_jbox2d_common_Vec2(p3).subLocal(p1);
                                let D = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                                let triangleArea = Math.fround(0.5 * D);
                                area += triangleArea;
                                c.x += Math.fround(Math.fround(triangleArea * inv3) * (Math.fround(Math.fround(p1.x + p2.x) + p3.x)));
                                c.y += Math.fround(Math.fround(triangleArea * inv3) * (Math.fround(Math.fround(p1.y + p2.y) + p3.y)));
                            }
                            ;
                        }
                        c.mulLocal(Math.fround(1.0 / area));
                        return c;
                    }
                    static tlUX_$LI$() { if (PolygonShape.tlUX == null)
                        PolygonShape.tlUX = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUX; }
                    ;
                    static tlUY_$LI$() { if (PolygonShape.tlUY == null)
                        PolygonShape.tlUY = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUY; }
                    ;
                    static tlLower_$LI$() { if (PolygonShape.tlLower == null)
                        PolygonShape.tlLower = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlLower; }
                    ;
                    static tlUpper_$LI$() { if (PolygonShape.tlUpper == null)
                        PolygonShape.tlUpper = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlUpper; }
                    ;
                    static tlR_$LI$() { if (PolygonShape.tlR == null)
                        PolygonShape.tlR = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlR; }
                    ;
                    static tlCenter_$LI$() { if (PolygonShape.tlCenter == null)
                        PolygonShape.tlCenter = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlCenter; }
                    ;
                    static computeOBB(obb, vs) {
                        let count = vs.length;
                        let ux = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlUX_$LI$());
                        let uy = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlUY_$LI$());
                        let lower = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlLower_$LI$());
                        let upper = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlUpper_$LI$());
                        let d = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlD_$LI$());
                        let r = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlR_$LI$());
                        let center = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlCenter_$LI$());
                        let pRay = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(org.jbox2d.common.Settings.maxPolygonVertices + 1);
                        for (let i = 0; i < count; ++i) {
                            {
                                pRay[i] = vs[i];
                            }
                            ;
                        }
                        pRay[count] = pRay[0];
                        let minArea = 3.4028235E38;
                        for (let i = 1; i <= count; ++i) {
                            {
                                let root = pRay[i - 1];
                                ux.set$org_jbox2d_common_Vec2(pRay[i]);
                                ux.subLocal(root);
                                let length = ux.normalize();
                                uy.x = -ux.y;
                                uy.y = ux.x;
                                lower.x = 3.4028235E38;
                                lower.y = 3.4028235E38;
                                upper.x = -3.4028235E38;
                                upper.y = -3.4028235E38;
                                for (let j = 0; j < count; ++j) {
                                    {
                                        d.set$org_jbox2d_common_Vec2(pRay[j]);
                                        d.subLocal(root);
                                        r.x = org.jbox2d.common.Vec2.dot(ux, d);
                                        r.y = org.jbox2d.common.Vec2.dot(uy, d);
                                        org.jbox2d.common.Vec2.minToOut(lower, r, lower);
                                        org.jbox2d.common.Vec2.maxToOut(upper, r, upper);
                                    }
                                    ;
                                }
                                let area = Math.fround((Math.fround(upper.x - lower.x)) * (Math.fround(upper.y - lower.y)));
                                if (area < Math.fround(0.95 * minArea)) {
                                    minArea = area;
                                    obb.R.col1.set$org_jbox2d_common_Vec2(ux);
                                    obb.R.col2.set$org_jbox2d_common_Vec2(uy);
                                    center.set$float$float(Math.fround(0.5 * (Math.fround(lower.x + upper.x))), Math.fround(0.5 * (Math.fround(lower.y + upper.y))));
                                    org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(obb.R, center, obb.center);
                                    obb.center.addLocal$org_jbox2d_common_Vec2(root);
                                    obb.extents.x = Math.fround(0.5 * (Math.fround(upper.x - lower.x)));
                                    obb.extents.y = Math.fround(0.5 * (Math.fround(upper.y - lower.y)));
                                }
                            }
                            ;
                        }
                    }
                    static tlCaabbR_$LI$() { if (PolygonShape.tlCaabbR == null)
                        PolygonShape.tlCaabbR = (() => { let __o = new org.jbox2d.pooling.TLMat22(); __o.__delegate = new org.jbox2d.pooling.TLMat22(); return __o; })(); return PolygonShape.tlCaabbR; }
                    ;
                    static tlCaabbH_$LI$() { if (PolygonShape.tlCaabbH == null)
                        PolygonShape.tlCaabbH = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlCaabbH; }
                    ;
                    /**
                     * @see Shape#computeAABB(AABB, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} xf
                     */
                    computeAABB(aabb, xf) {
                        let caabbR = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlCaabbR_$LI$());
                        let caabbH = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlCaabbH_$LI$());
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22$org_jbox2d_common_Mat22(xf.R, this.m_obb.R, caabbR);
                        caabbR.absLocal();
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(caabbR, this.m_obb.extents, caabbH);
                        org.jbox2d.common.Mat22.mulToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, this.m_obb.center, aabb.lowerBound);
                        aabb.lowerBound.addLocal$org_jbox2d_common_Vec2(xf.position);
                        aabb.upperBound.set$org_jbox2d_common_Vec2(aabb.lowerBound);
                        aabb.lowerBound.subLocal(caabbH);
                        aabb.upperBound.addLocal$org_jbox2d_common_Vec2(caabbH);
                    }
                    static tlSwept1_$LI$() { if (PolygonShape.tlSwept1 == null)
                        PolygonShape.tlSwept1 = (() => { let __o = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return PolygonShape.tlSwept1; }
                    ;
                    static tlSwept2_$LI$() { if (PolygonShape.tlSwept2 == null)
                        PolygonShape.tlSwept2 = (() => { let __o = new org.jbox2d.pooling.TLAABB(); __o.__delegate = new org.jbox2d.pooling.TLAABB(); return __o; })(); return PolygonShape.tlSwept2; }
                    ;
                    /**
                     * @see Shape#computeSweptAABB(AABB, XForm, XForm)
                     * @param {org.jbox2d.collision.AABB} aabb
                     * @param {org.jbox2d.common.XForm} transform1
                     * @param {org.jbox2d.common.XForm} transform2
                     */
                    computeSweptAABB(aabb, transform1, transform2) {
                        let sweptAABB1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlSwept1_$LI$());
                        let sweptAABB2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlSwept2_$LI$());
                        this.computeAABB(sweptAABB1, transform1);
                        this.computeAABB(sweptAABB2, transform2);
                        org.jbox2d.common.Vec2.minToOut(sweptAABB1.lowerBound, sweptAABB2.lowerBound, aabb.lowerBound);
                        org.jbox2d.common.Vec2.maxToOut(sweptAABB1.upperBound, sweptAABB2.upperBound, aabb.upperBound);
                    }
                    computeMass$org_jbox2d_collision_MassData(massData) {
                        this.computeMass$org_jbox2d_collision_MassData$float(massData, this.m_density);
                    }
                    computeMass$org_jbox2d_collision_MassData$float(massData, density) {
                        let center = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlCenter_$LI$());
                        center.setZero();
                        let area = 0.0;
                        let I = 0.0;
                        let pRef = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlPRef_$LI$());
                        pRef.setZero();
                        let k_inv3 = Math.fround(1.0 / 3.0);
                        let e1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE1_$LI$());
                        let e2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE2_$LI$());
                        for (let i = 0; i < this.m_vertexCount; ++i) {
                            {
                                let p1 = pRef;
                                let p2 = this.m_vertices[i];
                                let p3 = i + 1 < this.m_vertexCount ? this.m_vertices[i + 1] : this.m_vertices[0];
                                e1.set$org_jbox2d_common_Vec2(p2);
                                e1.subLocal(p1);
                                e2.set$org_jbox2d_common_Vec2(p3);
                                e2.subLocal(p1);
                                let D = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                                let triangleArea = Math.fround(0.5 * D);
                                area += triangleArea;
                                center.x += Math.fround(Math.fround(triangleArea * k_inv3) * (Math.fround(Math.fround(p1.x + p2.x) + p3.x)));
                                center.y += Math.fround(Math.fround(triangleArea * k_inv3) * (Math.fround(Math.fround(p1.y + p2.y) + p3.y)));
                                let px = p1.x;
                                let py = p1.y;
                                let ex1 = e1.x;
                                let ey1 = e1.y;
                                let ex2 = e2.x;
                                let ey2 = e2.y;
                                let intx2 = Math.fround(Math.fround(k_inv3 * (Math.fround(Math.fround(0.25 * (Math.fround(Math.fround(Math.fround(ex1 * ex1) + Math.fround(ex2 * ex1)) + Math.fround(ex2 * ex2)))) + (Math.fround(Math.fround(px * ex1) + Math.fround(px * ex2)))))) + Math.fround(Math.fround(0.5 * px) * px));
                                let inty2 = Math.fround(Math.fround(k_inv3 * (Math.fround(Math.fround(0.25 * (Math.fround(Math.fround(Math.fround(ey1 * ey1) + Math.fround(ey2 * ey1)) + Math.fround(ey2 * ey2)))) + (Math.fround(Math.fround(py * ey1) + Math.fround(py * ey2)))))) + Math.fround(Math.fround(0.5 * py) * py));
                                I += Math.fround(D * (Math.fround(intx2 + inty2)));
                            }
                            ;
                        }
                        massData.mass = Math.fround(density * area);
                        center.mulLocal(Math.fround(1.0 / area));
                        massData.center.set$org_jbox2d_common_Vec2(center);
                        massData.I = Math.fround(I * density);
                    }
                    /**
                     * @see Shape#computeMass(MassData)
                     * @param {org.jbox2d.collision.MassData} massData
                     * @param {number} density
                     */
                    computeMass(massData, density) {
                        if (((massData != null && massData instanceof org.jbox2d.collision.MassData) || massData === null) && ((typeof density === 'number') || density === null)) {
                            return this.computeMass$org_jbox2d_collision_MassData$float(massData, density);
                        }
                        else if (((massData != null && massData instanceof org.jbox2d.collision.MassData) || massData === null) && density === undefined) {
                            return this.computeMass$org_jbox2d_collision_MassData(massData);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Get the first vertex and apply the supplied transform.
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} out
                     */
                    getFirstVertexToOut(xf, out) {
                        org.jbox2d.common.XForm.mulToOut(xf, this.m_coreVertices[0], out);
                    }
                    /**
                     * Get the oriented bounding box relative to the parent body.
                     * @return {org.jbox2d.collision.OBB}
                     */
                    getOBB() {
                        return ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(this.m_obb);
                    }
                    /**
                     * Get the local centroid relative to the parent body.
                     * @return {org.jbox2d.common.Vec2}
                     */
                    getCentroid() {
                        return ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(this.m_centroid);
                    }
                    /**
                     * Get the number of vertices.
                     * @return {number}
                     */
                    getVertexCount() {
                        return this.m_vertexCount;
                    }
                    /**
                     * Get the vertices in local coordinates.
                     * @return {Array}
                     */
                    getVertices() {
                        return this.m_vertices;
                    }
                    /**
                     * Get the core vertices in local coordinates. These vertices
                     * represent a smaller polygon that is used for time of impact
                     * computations.
                     * @return {Array}
                     */
                    getCoreVertices() {
                        return this.m_coreVertices;
                    }
                    /**
                     * Get the edge normal vectors.  There is one for each vertex.
                     * @return {Array}
                     */
                    getNormals() {
                        return this.m_normals;
                    }
                    /**
                     * Get the centroid and apply the supplied transform.
                     * @param {org.jbox2d.common.XForm} xf
                     * @return {org.jbox2d.common.Vec2}
                     */
                    centroid(xf) {
                        return org.jbox2d.common.XForm.mul(xf, this.m_centroid);
                    }
                    static tlNormalL_$LI$() { if (PolygonShape.tlNormalL == null)
                        PolygonShape.tlNormalL = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlNormalL; }
                    ;
                    static tlMd_$LI$() { if (PolygonShape.tlMd == null)
                        PolygonShape.tlMd = (() => { let __o = new org.jbox2d.pooling.TLMassData(); __o.__delegate = new org.jbox2d.pooling.TLMassData(); return __o; })(); return PolygonShape.tlMd; }
                    ;
                    static tlIntoVec_$LI$() { if (PolygonShape.tlIntoVec == null)
                        PolygonShape.tlIntoVec = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlIntoVec; }
                    ;
                    static tlOutoVec_$LI$() { if (PolygonShape.tlOutoVec == null)
                        PolygonShape.tlOutoVec = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlOutoVec; }
                    ;
                    static tlP2b_$LI$() { if (PolygonShape.tlP2b == null)
                        PolygonShape.tlP2b = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP2b; }
                    ;
                    static tlP3_$LI$() { if (PolygonShape.tlP3 == null)
                        PolygonShape.tlP3 = (() => { let __o = new org.jbox2d.pooling.TLVec2(); __o.__delegate = new org.jbox2d.pooling.TLVec2(); return __o; })(); return PolygonShape.tlP3; }
                    ;
                    computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c) {
                        let normalL = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlNormalL_$LI$());
                        let md = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlMd_$LI$());
                        org.jbox2d.common.Mat22.mulTransToOut$org_jbox2d_common_Mat22$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(xf.R, normal, normalL);
                        let offsetL = Math.fround(offset - org.jbox2d.common.Vec2.dot(normal, xf.position));
                        let depths = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(org.jbox2d.common.Settings.maxPolygonVertices);
                        let diveCount = 0;
                        let intoIndex = -1;
                        let outoIndex = -1;
                        let lastSubmerged = false;
                        let i = 0;
                        for (i = 0; i < this.m_vertexCount; ++i) {
                            {
                                depths[i] = Math.fround(org.jbox2d.common.Vec2.dot(normalL, this.m_vertices[i]) - offsetL);
                                let isSubmerged = depths[i] < -org.jbox2d.common.Settings.EPSILON;
                                if (i > 0) {
                                    if (isSubmerged) {
                                        if (!lastSubmerged) {
                                            intoIndex = i - 1;
                                            diveCount++;
                                        }
                                    }
                                    else {
                                        if (lastSubmerged) {
                                            outoIndex = i - 1;
                                            diveCount++;
                                        }
                                    }
                                }
                                lastSubmerged = isSubmerged;
                            }
                            ;
                        }
                        switch ((diveCount)) {
                            case 0:
                                if (lastSubmerged) {
                                    this.computeMass$org_jbox2d_collision_MassData$float(md, 1.0);
                                    org.jbox2d.common.XForm.mulToOut(xf, md.center, c);
                                    return md.mass;
                                }
                                else {
                                    return 0;
                                }
                            case 1:
                                if (intoIndex === -1) {
                                    intoIndex = this.m_vertexCount - 1;
                                }
                                else {
                                    outoIndex = this.m_vertexCount - 1;
                                }
                                break;
                        }
                        let intoVec = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlIntoVec_$LI$());
                        let outoVec = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlOutoVec_$LI$());
                        let e1 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE1_$LI$());
                        let e2 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlE2_$LI$());
                        let intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
                        let outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
                        let intoLambda = Math.fround((Math.fround(0 - depths[intoIndex])) / (Math.fround(depths[intoIndex2] - depths[intoIndex])));
                        let outoLambda = Math.fround((Math.fround(0 - depths[outoIndex])) / (Math.fround(depths[outoIndex2] - depths[outoIndex])));
                        intoVec.set$float$float(Math.fround(Math.fround(this.m_vertices[intoIndex].x * (Math.fround(1 - intoLambda))) + Math.fround(this.m_vertices[intoIndex2].x * intoLambda)), Math.fround(Math.fround(this.m_vertices[intoIndex].y * (Math.fround(1 - intoLambda))) + Math.fround(this.m_vertices[intoIndex2].y * intoLambda)));
                        outoVec.set$float$float(Math.fround(Math.fround(this.m_vertices[outoIndex].x * (Math.fround(1 - outoLambda))) + Math.fround(this.m_vertices[outoIndex2].x * outoLambda)), Math.fround(Math.fround(this.m_vertices[outoIndex].y * (Math.fround(1 - outoLambda))) + Math.fround(this.m_vertices[outoIndex2].y * outoLambda)));
                        let area = 0;
                        let center = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlCenter_$LI$());
                        center.setZero();
                        let p2b = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlP2b_$LI$()).set$org_jbox2d_common_Vec2(this.m_vertices[intoIndex2]);
                        let p3 = ((tlObj) => { if (tlObj.___value) {
                            return tlObj.___value;
                        }
                        else {
                            return tlObj.___value = tlObj.initialValue();
                        } })(PolygonShape.tlP3_$LI$());
                        p3.setZero();
                        let k_inv3 = Math.fround(1.0 / 3.0);
                        i = intoIndex2;
                        while ((i !== outoIndex2)) {
                            {
                                i = (i + 1) % this.m_vertexCount;
                                if (i === outoIndex2) {
                                    p3.set$org_jbox2d_common_Vec2(outoVec);
                                }
                                else {
                                    p3.set$org_jbox2d_common_Vec2(this.m_vertices[i]);
                                }
                                {
                                    e1.set$org_jbox2d_common_Vec2(p2b).subLocal(intoVec);
                                    e2.set$org_jbox2d_common_Vec2(p3).subLocal(intoVec);
                                    let D = org.jbox2d.common.Vec2.cross$org_jbox2d_common_Vec2$org_jbox2d_common_Vec2(e1, e2);
                                    let triangleArea = Math.fround(0.5 * D);
                                    area += triangleArea;
                                    center.x += Math.fround(Math.fround(triangleArea * k_inv3) * (Math.fround(Math.fround(intoVec.x + p2b.x) + p3.x)));
                                    center.y += Math.fround(Math.fround(triangleArea * k_inv3) * (Math.fround(Math.fround(intoVec.y + p2b.y) + p3.y)));
                                }
                                ;
                                p2b.set$org_jbox2d_common_Vec2(p3);
                            }
                        }
                        ;
                        center.x *= Math.fround(1.0 / area);
                        center.y *= Math.fround(1.0 / area);
                        org.jbox2d.common.XForm.mulToOut(xf, center, c);
                        return area;
                    }
                    /**
                     * @see Shape#computeSubmergedArea(Vec2, float, XForm, Vec2)
                     * @param {org.jbox2d.common.Vec2} normal
                     * @param {number} offset
                     * @param {org.jbox2d.common.XForm} xf
                     * @param {org.jbox2d.common.Vec2} c
                     * @return {number}
                     */
                    computeSubmergedArea(normal, offset, xf, c) {
                        if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.XForm) || xf === null) && ((c != null && c instanceof org.jbox2d.common.Vec2) || c === null)) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_XForm$org_jbox2d_common_Vec2(normal, offset, xf, c);
                        }
                        else if (((normal != null && normal instanceof org.jbox2d.common.Vec2) || normal === null) && ((typeof offset === 'number') || offset === null) && ((xf != null && xf instanceof org.jbox2d.common.Vec2) || xf === null) && c === undefined) {
                            return this.computeSubmergedArea$org_jbox2d_common_Vec2$float$org_jbox2d_common_Vec2(normal, offset, xf);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                /**
                 * Dump lots of debug information.
                 */
                PolygonShape.m_debug = false;
                shapes.PolygonShape = PolygonShape;
                PolygonShape["__class"] = "org.jbox2d.collision.shapes.PolygonShape";
                PolygonShape["__interfaces"] = ["org.jbox2d.collision.SupportsGenericDistance"];
            })(shapes = collision.shapes || (collision.shapes = {}));
        })(collision = jbox2d.collision || (jbox2d.collision = {}));
    })(jbox2d = org.jbox2d || (org.jbox2d = {}));
})(org || (org = {}));
var __Function = Function;
org.jbox2d.collision.shapes.PolygonShape.tlP3_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlP2b_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlOutoVec_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlIntoVec_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlMd_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlNormalL_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlSwept2_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlSwept1_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlCaabbH_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlCaabbR_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlCenter_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlR_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlUpper_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlLower_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlUY_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlUX_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlE2_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlE1_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlPRef_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlSupDLocal_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlP2_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlP1_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlPLocal_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlTemp_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlA_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlD_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlV_$LI$();
org.jbox2d.collision.shapes.PolygonShape.tlEdge_$LI$();
org.jbox2d.collision.shapes.PointShape.tlR_$LI$();
org.jbox2d.collision.shapes.PointShape.tlPosition_$LI$();
org.jbox2d.collision.shapes.PointShape.tlS_$LI$();
org.jbox2d.collision.shapes.PointShape.tlSwept2_$LI$();
org.jbox2d.collision.shapes.PointShape.tlSwept1_$LI$();
org.jbox2d.collision.shapes.PointShape.tlP_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlE2_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlE1_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlTemp_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlV0_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSupportV2_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSupportV1_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSwept4_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSwept3_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSwept2_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlSwept1_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlV2_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlB_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlN_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlD_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlV1_$LI$();
org.jbox2d.collision.shapes.EdgeShape.tlR_$LI$();
org.jbox2d.collision.shapes.CircleShape.tlP_$LI$();
org.jbox2d.collision.shapes.CircleShape.tlR_$LI$();
org.jbox2d.collision.shapes.CircleShape.tlPosition_$LI$();
org.jbox2d.collision.shapes.CircleShape.tlS_$LI$();
org.jbox2d.collision.shapes.CircleShape.tlCenter_$LI$();
org.jbox2d.dynamics.World.LIQUID_INT_$LI$();
org.jbox2d.dynamics.World.steps_$LI$();
org.jbox2d.dynamics.World.islands_$LI$();
org.jbox2d.dynamics.World.tlStep_$LI$();
org.jbox2d.dynamics.Island.contactSolvers_$LI$();
org.jbox2d.dynamics.joints.ConstantVolumeJoint.tlD_$LI$();
org.jbox2d.collision.BroadPhase.tlResults_$LI$();
org.jbox2d.collision.BroadPhase.tlOldValues_$LI$();
org.jbox2d.collision.BroadPhase.tlNewValues_$LI$();
org.jbox2d.collision.BroadPhase.tlIgnored_$LI$();
org.jbox2d.collision.BroadPhase.tlIndexes_$LI$();
org.jbox2d.collision.BroadPhase.tlUpperValues_$LI$();
org.jbox2d.collision.BroadPhase.tlLowerValues_$LI$();
org.jbox2d.collision.BroadPhase.NULL_EDGE_$LI$();
org.jbox2d.collision.BroadPhase.INVALID_$LI$();
org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlPersisted_$LI$();
org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.PolyAndEdgeContact.tlm0_$LI$();
org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlPersisted_$LI$();
org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.PolyAndCircleContact.tlm0_$LI$();
org.jbox2d.dynamics.contacts.PointAndPolyContact.tlPersisted_$LI$();
org.jbox2d.dynamics.contacts.PointAndPolyContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.PointAndPolyContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.PointAndPolyContact.tlm0_$LI$();
game.GameSingleThread.initState_$LI$();
game.GameSingleThread.lLArmMassData_$LI$();
game.GameSingleThread.rLArmMassData_$LI$();
game.GameSingleThread.lUArmMassData_$LI$();
game.GameSingleThread.rUArmMassData_$LI$();
game.GameSingleThread.headMassData_$LI$();
game.GameSingleThread.torsoMassData_$LI$();
game.GameSingleThread.lThighMassData_$LI$();
game.GameSingleThread.rThighMassData_$LI$();
game.GameSingleThread.lCalfMassData_$LI$();
game.GameSingleThread.rCalfMassData_$LI$();
game.GameSingleThread.lFootMassData_$LI$();
game.GameSingleThread.rFootMassData_$LI$();
game.GameSingleThread.headShape_$LI$();
game.GameSingleThread.lLArmShape_$LI$();
game.GameSingleThread.rLArmShape_$LI$();
game.GameSingleThread.lUArmShape_$LI$();
game.GameSingleThread.rUArmShape_$LI$();
game.GameSingleThread.torsoShape_$LI$();
game.GameSingleThread.lThighShape_$LI$();
game.GameSingleThread.rThighShape_$LI$();
game.GameSingleThread.lCalfShape_$LI$();
game.GameSingleThread.rCalfShape_$LI$();
game.GameSingleThread.lFootShape_$LI$();
game.GameSingleThread.rFootShape_$LI$();
game.GameSingleThread.trackShape_$LI$();
game.GameSingleThread.lLArmDef_$LI$();
game.GameSingleThread.rLArmDef_$LI$();
game.GameSingleThread.lUArmDef_$LI$();
game.GameSingleThread.rUArmDef_$LI$();
game.GameSingleThread.headDef_$LI$();
game.GameSingleThread.torsoDef_$LI$();
game.GameSingleThread.lThighDef_$LI$();
game.GameSingleThread.rThighDef_$LI$();
game.GameSingleThread.lCalfDef_$LI$();
game.GameSingleThread.rCalfDef_$LI$();
game.GameSingleThread.lFootDef_$LI$();
game.GameSingleThread.rFootDef_$LI$();
game.GameSingleThread.trackDef_$LI$();
game.GameSingleThread.shapeList_$LI$();
game.GameSingleThread.neckPos_$LI$();
game.GameSingleThread.lElbowPos_$LI$();
game.GameSingleThread.rElbowPos_$LI$();
game.GameSingleThread.lShoulderPos_$LI$();
game.GameSingleThread.rShoulderPos_$LI$();
game.GameSingleThread.lHipPos_$LI$();
game.GameSingleThread.rHipPos_$LI$();
game.GameSingleThread.lKneePos_$LI$();
game.GameSingleThread.rKneePos_$LI$();
game.GameSingleThread.lAnklePos_$LI$();
game.GameSingleThread.rAnklePos_$LI$();
game.GameSingleThread.lLArmPos_$LI$();
game.GameSingleThread.rLArmPos_$LI$();
game.GameSingleThread.lUArmPos_$LI$();
game.GameSingleThread.rUArmPos_$LI$();
game.GameSingleThread.headPos_$LI$();
game.GameSingleThread.torsoPos_$LI$();
game.GameSingleThread.lThighPos_$LI$();
game.GameSingleThread.rThighPos_$LI$();
game.GameSingleThread.lCalfPos_$LI$();
game.GameSingleThread.rCalfPos_$LI$();
game.GameSingleThread.lFootPos_$LI$();
game.GameSingleThread.rFootPos_$LI$();
game.GameSingleThread.gravity_$LI$();
game.GameSingleThread.worldAABB_$LI$();
org.jbox2d.dynamics.Body.tlXf1_$LI$();
org.jbox2d.dynamics.Body.tlCenter_$LI$();
org.jbox2d.dynamics.Body.idLock_$LI$();
org.jbox2d.collision.TOI.tlP2_$LI$();
org.jbox2d.collision.TOI.tlP1_$LI$();
org.jbox2d.collision.TOI.tlxf2_$LI$();
org.jbox2d.collision.TOI.tlxf1_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlimpulse_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlptpC_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlp2_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlp1_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlpivotForce_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlpivotCdot_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tltemp_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlK3_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlK2_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlK1_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlr2_$LI$();
org.jbox2d.dynamics.joints.RevoluteJoint.tlr1_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlv2_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlv1_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlP2_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlP1_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tls2_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tls1_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlp2_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlp1_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlr2_$LI$();
org.jbox2d.dynamics.joints.PulleyJoint.tlr1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlreactionAx1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlw1xR1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlw2xR2_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlv22_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlw1xAxis_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlaxis_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tldz_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlp2z_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlp1z_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlr2z_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlr1z_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlp2_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlp1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tltemp_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tld_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlay1Neg_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlax1Neg_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tle_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlay1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlax1_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlr2_$LI$();
org.jbox2d.dynamics.joints.PrismaticJoint.tlr1_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlP_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tloldForce_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlforce_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlCdot_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlK2_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlK1_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlr_$LI$();
org.jbox2d.dynamics.joints.MouseJoint.tlanchor2_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlv2_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlv1_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tld_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlP_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlr2_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlr1_$LI$();
org.jbox2d.dynamics.joints.DistanceJoint.tlReactionForce_$LI$();
org.jbox2d.dynamics.contacts.PolyContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.PolyContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.PolyContact.tlm0_$LI$();
org.jbox2d.dynamics.contacts.PointAndCircleContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.PointAndCircleContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.PointAndCircleContact.tlm0_$LI$();
org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.EdgeAndCircleContact.tlm0_$LI$();
org.jbox2d.dynamics.contacts.CircleContact.tlCp_$LI$();
org.jbox2d.dynamics.contacts.CircleContact.tlV1_$LI$();
org.jbox2d.dynamics.contacts.CircleContact.tlm0_$LI$();
org.jbox2d.dynamics.ContactManager.tlCp_$LI$();
org.jbox2d.dynamics.ContactManager.tlV1_$LI$();
org.jbox2d.collision.Segment.tlB_$LI$();
org.jbox2d.collision.Segment.tlN_$LI$();
org.jbox2d.collision.Segment.tlD_$LI$();
org.jbox2d.collision.Segment.tlR_$LI$();
org.jbox2d.common.OBBViewportTransform.tlInv_$LI$();
org.jbox2d.collision.shapes.Shape.tlAabb_$LI$();
org.jbox2d.util.nonconvex.Polygon.maxPolygonVertices_$LI$();
org.jbox2d.util.nonconvex.Polygon.COLLAPSE_DIST_SQR_$LI$();
org.jbox2d.util.nonconvex.Polygon.toiSlop_$LI$();
org.jbox2d.common.MathUtils.cosLUT_$LI$();
org.jbox2d.common.MathUtils.sinLUT_$LI$();
org.jbox2d.common.MathUtils.TWOPI_$LI$();
org.jbox2d.common.MathUtils.PI_$LI$();
org.jbox2d.common.MathUtils.__static_initialize();
org.jbox2d.collision.PairManager.TABLE_MASK_$LI$();
org.jbox2d.collision.PairManager.TABLE_CAPACITY_$LI$();
org.jbox2d.collision.PairManager.NULL_PROXY_$LI$();
org.jbox2d.collision.PairManager.NULL_PAIR_$LI$();
org.jbox2d.pooling.SingletonPool.pool_$LI$();
org.jbox2d.common.XForm.identity_$LI$();
org.jbox2d.common.XForm.__static_initialize();
org.jbox2d.common.Settings.maxAngularVelocitySquared_$LI$();
org.jbox2d.common.Settings.maxLinearVelocitySquared_$LI$();
org.jbox2d.common.Settings.toiSlop_$LI$();
org.jbox2d.common.Settings.angularSleepTolerance_$LI$();
org.jbox2d.common.Settings.linearSleepTolerance_$LI$();
org.jbox2d.common.Settings.timeToSleep_$LI$();
org.jbox2d.common.Settings.maxAngularCorrection_$LI$();
org.jbox2d.common.Settings.maxLinearCorrection_$LI$();
org.jbox2d.common.Settings.velocityThreshold_$LI$();
org.jbox2d.common.Settings.angularSlop_$LI$();
org.jbox2d.common.Settings.linearSlop_$LI$();
org.jbox2d.common.Settings.maxPairs_$LI$();
org.jbox2d.common.Settings.SINCOS_LUT_LENGTH_$LI$();
org.jbox2d.common.Settings.pi_$LI$();
org.jbox2d.common.Color3f.RED_$LI$();
org.jbox2d.common.Color3f.GREEN_$LI$();
org.jbox2d.common.Color3f.BLUE_$LI$();
org.jbox2d.common.Color3f.BLACK_$LI$();
org.jbox2d.common.Color3f.WHITE_$LI$();
org.jbox2d.collision.Collision.NULL_FEATURE_$LI$();
